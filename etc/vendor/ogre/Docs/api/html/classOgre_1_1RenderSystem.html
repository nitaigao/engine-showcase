<html>
<head>
<title>OGRE: Ogre::RenderSystem Class Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespaceOgre.html">Ogre</a>::<a class="el" href="classOgre_1_1RenderSystem.html">RenderSystem</a></div>
<h1>Ogre::RenderSystem Class Reference</h1><!-- doxytag: class="Ogre::RenderSystem" --><!-- doxytag: inherits="Ogre::AllocatedObject" -->Defines the functionality of a 3D API.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Ogre::RenderSystem:</div>
<div class="dynsection">
<p><center><img src="classOgre_1_1RenderSystem__inherit__graph.gif" border="0" usemap="#Ogre_1_1RenderSystem__inherit__map" alt="Inheritance graph"></center>
<map name="Ogre_1_1RenderSystem__inherit__map">
<area shape="rect" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new..." alt="" coords="21,5,139,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classOgre_1_1RenderSystem-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a><br>
&lt; <a class="el" href="namespaceOgre.html#2551e2d3573c437f3beccf7d3ac7a45e">Ogre::RenderTargetMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#50a15a7bbc1beca5c91b6584a3060f1b">RenderTargetIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator over RenderTargets.  <a href="#50a15a7bbc1beca5c91b6584a3060f1b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#3391b683d588628272d8d9de633e472e">RenderSystem</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Constructor.  <a href="#3391b683d588628272d8d9de633e472e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#785f83ff8a4ee8fb21a11c9d6fe5c928">~RenderSystem</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#785f83ff8a4ee8fb21a11c9d6fe5c928"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#19b810b6fe61b526010812e9af80bf63">getName</a> (void) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of the rendering system.  <a href="#19b810b6fe61b526010812e9af80bf63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#9f6262ba9e855a064430936555d0ba62">ConfigOptionMap</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#7a6236866e64cc19c078383b43872aa8">getConfigOptions</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the details of this API's configuration options.  <a href="#7a6236866e64cc19c078383b43872aa8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#606200a27a8adebfa62b3e388a49cf39">setConfigOption</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets an option for this API.  <a href="#606200a27a8adebfa62b3e388a49cf39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1HardwareOcclusionQuery.html">HardwareOcclusionQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#2b7725995f951adff614db3874c8566c">createHardwareOcclusionQuery</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an object for performing hardware occlusion queries.  <a href="#2b7725995f951adff614db3874c8566c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#c4c60bf4c5d4347fd2b9346a90545e2b">destroyHardwareOcclusionQuery</a> (<a class="el" href="classOgre_1_1HardwareOcclusionQuery.html">HardwareOcclusionQuery</a> *hq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a hardware occlusion query object.  <a href="#c4c60bf4c5d4347fd2b9346a90545e2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#b19828ac45b10a64357d8b9fc0918351">validateConfigOptions</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Validates the options set for the rendering system, returning a message if there are problems.  <a href="#b19828ac45b10a64357d8b9fc0918351"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1RenderWindow.html">RenderWindow</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#ad26b5af908674412c89242003f5991e">_initialise</a> (bool autoCreateWindow, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;windowTitle=&quot;OGRE Render Window&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start up the renderer using the settings selected (Or the defaults if none have been selected).  <a href="#ad26b5af908674412c89242003f5991e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#4cd432497387d2c630a95ad9c0cd9772">createRenderSystemCapabilities</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the real capabilities of the GPU and driver in the <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a>.  <a href="#4cd432497387d2c630a95ad9c0cd9772"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#6219a2d1f92be5548983a03de9522365">useCustomRenderSystemCapabilities</a> (<a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a> *capabilities)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force the render system to use the special capabilities.  <a href="#6219a2d1f92be5548983a03de9522365"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#32e21b240c7b6c75eab05cbc870f9868">reinitialise</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restart the renderer (normally following a change in settings).  <a href="#32e21b240c7b6c75eab05cbc870f9868"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#987cf400154a21403b4ff5192d423971">shutdown</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown the renderer and cleanup resources.  <a href="#987cf400154a21403b4ff5192d423971"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#b11411028dca873b5739bb42460ce47a">setAmbientLight</a> (float r, float g, float b)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the colour &amp; strength of the ambient (global directionless) light in the world.  <a href="#b11411028dca873b5739bb42460ce47a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#5f59ae6268d2cdcc664d161db7f57ea5">setShadingType</a> (<a class="el" href="namespaceOgre.html#7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a> so)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the type of light shading required (default = Gouraud).  <a href="#5f59ae6268d2cdcc664d161db7f57ea5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#5a94b198cfcd383839ea54de695d1700">setLightingEnabled</a> (bool enabled)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not dynamic lighting is enabled.  <a href="#5a94b198cfcd383839ea54de695d1700"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#01c339f6e89d82b526fb7725424a4263">setWBufferEnabled</a> (bool enabled)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not W-buffers are enabled if they are available for this renderer.  <a href="#01c339f6e89d82b526fb7725424a4263"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#8f7260f2196b08677b2a233f9f7ef8e5">getWBufferEnabled</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the renderer will try to use W-buffers when avalible.  <a href="#8f7260f2196b08677b2a233f9f7ef8e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1RenderWindow.html">RenderWindow</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#af156b9f935396e6c17f532f6e6c847e">_createRenderWindow</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, unsigned int width, unsigned int height, bool fullScreen, const <a class="el" href="namespaceOgre.html#0537f38d7a77fcbe9f600f6ed8a926d6">NameValuePairList</a> *miscParams=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new rendering window.  <a href="#af156b9f935396e6c17f532f6e6c847e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1MultiRenderTarget.html">MultiRenderTarget</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#857191a1acd18fd25498517bf183efe2">createMultiRenderTarget</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classOgre_1_1MultiRenderTarget.html" title="This class represents a render target that renders to multiple RenderTextures at...">MultiRenderTarget</a>, which is a render target that renders to multiple RenderTextures at once.  <a href="#857191a1acd18fd25498517bf183efe2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#65ddf1db4aa3f463e0479c240ffc3dc5">destroyRenderWindow</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a render window.  <a href="#65ddf1db4aa3f463e0479c240ffc3dc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#354ceaa02574d1cf68dcb5999b34df50">destroyRenderTexture</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a render texture.  <a href="#354ceaa02574d1cf68dcb5999b34df50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#43a03671d1c7efd7e95100d77080eb8c">destroyRenderTarget</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a render target of any sort.  <a href="#43a03671d1c7efd7e95100d77080eb8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#e3aa9e2fd13e2b066f3f2f56018bd4be">attachRenderTarget</a> (<a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a> &amp;target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attaches the passed render target to the render system.  <a href="#e3aa9e2fd13e2b066f3f2f56018bd4be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#313d7af5018e65802d96aa7124700db7">getRenderTarget</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the render target with the passed name, or NULL if that render target cannot be found.  <a href="#313d7af5018e65802d96aa7124700db7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#38e818fa1817fd1cfec8655b7702e230">detachRenderTarget</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches the render target with the passed name from the render system and returns a pointer to it.  <a href="#38e818fa1817fd1cfec8655b7702e230"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1MapIterator.html">RenderTargetIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#2e8f34e7464302fbce845f1d3fd468c8">getRenderTargetIterator</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a specialised <a class="el" href="classOgre_1_1MapIterator.html" title="Wraps iteration over a map.">MapIterator</a> over all render targets attached to the <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a>.  <a href="#2e8f34e7464302fbce845f1d3fd468c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#847238effa8920edf9aee7aa5b8cd7be">getErrorDescription</a> (long errorNumber) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a description of an error code.  <a href="#847238effa8920edf9aee7aa5b8cd7be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a18ec4f5823ecb28f2cccdee85e5337c">setWaitForVerticalBlank</a> (bool enabled)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines whether or now fullscreen render windows wait for the vertical blank before flipping buffers.  <a href="#a18ec4f5823ecb28f2cccdee85e5337c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#16bc1ae27d9e3cdf9cfffdb4ed4724c6">getWaitForVerticalBlank</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the system is synchronising frames with the monitor vertical blank.  <a href="#16bc1ae27d9e3cdf9cfffdb4ed4724c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#c8e632a4d601721d18f7a6758c9fc0af">_useLights</a> (const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> &amp;lights, unsigned short limit)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the rendersystem to use the attached set of lights (and no others) up to the number specified (this allows the same list to be used with different count limits).  <a href="#c8e632a4d601721d18f7a6758c9fc0af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#97cfab83fc9bf9e3df7e2d5ea6fae5c5">_setWorldMatrix</a> (const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;m)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the world transform matrix.  <a href="#97cfab83fc9bf9e3df7e2d5ea6fae5c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#9442fcdf97b2723c588dee0489f2aefc">_setWorldMatrices</a> (const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> *m, unsigned short count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets multiple world matrices (vertex blending).  <a href="#9442fcdf97b2723c588dee0489f2aefc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#8cdef3669e7f8e87d6fc8db1ad102f1e">_setViewMatrix</a> (const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;m)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the view transform matrix.  <a href="#8cdef3669e7f8e87d6fc8db1ad102f1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#968dffb7114639b2c3aa39f6323fd66e">_setProjectionMatrix</a> (const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;m)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the projection transform matrix.  <a href="#968dffb7114639b2c3aa39f6323fd66e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#d504623eff0678f9f79b075f32673414">_setTextureUnitSettings</a> (size_t texUnit, <a class="el" href="classOgre_1_1TextureUnitState.html">TextureUnitState</a> &amp;tl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility function for setting all the properties of a texture unit at once.  <a href="#d504623eff0678f9f79b075f32673414"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#058d6805142fce7ec095a018447cbe33">_disableTextureUnit</a> (size_t texUnit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns off a texture unit.  <a href="#058d6805142fce7ec095a018447cbe33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#68e0ecb23c3eba58b5aeb06d646ce4cd">_disableTextureUnitsFrom</a> (size_t texUnit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables all texture units from the given unit upwards.  <a href="#68e0ecb23c3eba58b5aeb06d646ce4cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#ca86be508b2afbbe67e2eac635ac640d">_setSurfaceParams</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;ambient, const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;diffuse, const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;specular, const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;emissive, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> shininess, <a class="el" href="namespaceOgre.html#f3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a> tracking=TVC_NONE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the surface properties to be used for future rendering.  <a href="#ca86be508b2afbbe67e2eac635ac640d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#7cca254fe5034f59e9d4dc4b9dc95742">_setPointSpritesEnabled</a> (bool enabled)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not rendering points using OT_POINT_LIST will render point sprites (textured quads) or plain points.  <a href="#7cca254fe5034f59e9d4dc4b9dc95742"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#6ca319dee8eb1693186b85bbb423533f">_setPointParameters</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> size, bool attenuationEnabled, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> constant, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linear, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> quadratic, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> minSize, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> maxSize)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of points and how they are attenuated with distance.  <a href="#6ca319dee8eb1693186b85bbb423533f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#2cb551bfdd04b7426f73a84cbcbc93f7">_setTexture</a> (size_t unit, bool enabled, const <a class="el" href="classOgre_1_1TexturePtr.html">TexturePtr</a> &amp;texPtr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the texture to bind to a given texture unit.  <a href="#2cb551bfdd04b7426f73a84cbcbc93f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#aa2dacc8b8fc28c649a8a603d1f5909c">_setTexture</a> (size_t unit, bool enabled, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;texname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the texture to bind to a given texture unit.  <a href="#aa2dacc8b8fc28c649a8a603d1f5909c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#f40bfb084b051d8433b0893921613ba7">_setVertexTexture</a> (size_t unit, const <a class="el" href="classOgre_1_1TexturePtr.html">TexturePtr</a> &amp;tex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binds a texture to a vertex sampler.  <a href="#f40bfb084b051d8433b0893921613ba7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#d8ca02fa31e477271f35054173e1836b">_setTextureCoordSet</a> (size_t unit, size_t index)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the texture coordinate set to use for a texture unit.  <a href="#d8ca02fa31e477271f35054173e1836b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#8f37341fd724098023aa0be0850302b0">_setTextureCoordCalculation</a> (size_t unit, <a class="el" href="namespaceOgre.html#a9c06899edc6b7aed7bf3b29abe9bb31">TexCoordCalcMethod</a> m, const <a class="el" href="classOgre_1_1Frustum.html">Frustum</a> *frustum=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a method for automatically calculating texture coordinates for a stage.  <a href="#8f37341fd724098023aa0be0850302b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#33ce98658bb9f6fdb1aca70c8041ef81">_setTextureBlendMode</a> (size_t unit, const <a class="el" href="classOgre_1_1LayerBlendModeEx.html">LayerBlendModeEx</a> &amp;bm)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the texture blend modes from a <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> record.  <a href="#33ce98658bb9f6fdb1aca70c8041ef81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#dbc64c669661f87ee2f8db8dd18a0fe5">_setTextureUnitFiltering</a> (size_t unit, <a class="el" href="namespaceOgre.html#02306c6246268d35f45ad22278bd5d3d">FilterOptions</a> minFilter, <a class="el" href="namespaceOgre.html#02306c6246268d35f45ad22278bd5d3d">FilterOptions</a> magFilter, <a class="el" href="namespaceOgre.html#02306c6246268d35f45ad22278bd5d3d">FilterOptions</a> mipFilter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the filtering options for a given texture unit.  <a href="#dbc64c669661f87ee2f8db8dd18a0fe5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#1f0f550def3f4caa1173ed6eb0d09031">_setTextureUnitFiltering</a> (size_t unit, <a class="el" href="namespaceOgre.html#c1fc36ec2f4df4b2afa9fa39f9c66c06">FilterType</a> ftype, <a class="el" href="namespaceOgre.html#02306c6246268d35f45ad22278bd5d3d">FilterOptions</a> filter)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a single filter for a given texture unit.  <a href="#1f0f550def3f4caa1173ed6eb0d09031"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#ba523c0055a520d25fd7f08683e3c98e">_setTextureLayerAnisotropy</a> (size_t unit, unsigned int maxAnisotropy)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximal anisotropy for the specified texture unit.  <a href="#ba523c0055a520d25fd7f08683e3c98e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#67b3f87c6ef12e5b24812eeb61635308">_setTextureAddressingMode</a> (size_t unit, const <a class="el" href="structOgre_1_1TextureUnitState_1_1UVWAddressingMode.html">TextureUnitState::UVWAddressingMode</a> &amp;uvw)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the texture addressing mode for a texture unit.  <a href="#67b3f87c6ef12e5b24812eeb61635308"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#d771e198662c3316b13b2c86caff6f2e">_setTextureBorderColour</a> (size_t unit, const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;colour)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the texture border colour for a texture unit.  <a href="#d771e198662c3316b13b2c86caff6f2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#99f92ad60c2da38c7dfcf3f429e65572">_setTextureMipmapBias</a> (size_t unit, float bias)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mipmap bias value for a given texture unit.  <a href="#99f92ad60c2da38c7dfcf3f429e65572"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#1212c8aa766ec3b309ee2216bec0ef88">_setTextureMatrix</a> (size_t unit, const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;xform)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the texture coordinate transformation matrix for a texture unit.  <a href="#1212c8aa766ec3b309ee2216bec0ef88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#bf639b982318a0211e98329e0c22fc32">_setSceneBlending</a> (<a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the global blending factors for combining subsequent renders with the existing frame contents.  <a href="#bf639b982318a0211e98329e0c22fc32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#e6357924eafe2464bf665be474a9b4a3">_setSeparateSceneBlending</a> (<a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor, <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactorAlpha, <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactorAlpha)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the global blending factors for combining subsequent renders with the existing frame contents.  <a href="#e6357924eafe2464bf665be474a9b4a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#6a3facdc0f1b8c68af65598fd3fd34aa">_setAlphaRejectSettings</a> (<a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a> func, unsigned char value, bool alphaToCoverage)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the global alpha rejection approach for future renders.  <a href="#6a3facdc0f1b8c68af65598fd3fd34aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#91e7ee7dd1f244ffa9a0681efb6fae6c">_setTextureProjectionRelativeTo</a> (bool enabled, const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify the rendersystem that it should adjust texture projection to be relative to a different origin.  <a href="#91e7ee7dd1f244ffa9a0681efb6fae6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#80b7ab32b8f82cf340c47d55f6e69881">_beginFrame</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signifies the beginning of a frame, i.e.  <a href="#80b7ab32b8f82cf340c47d55f6e69881"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#ad966c6f361ac75304c1e03f9ec384c4">_endFrame</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends rendering of a frame to the current viewport.  <a href="#ad966c6f361ac75304c1e03f9ec384c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#7d7f7d706450808859f338352c5e9cd0">_setViewport</a> (<a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *vp)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the provided viewport as the active one for future rendering operations.  <a href="#7d7f7d706450808859f338352c5e9cd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a0cf9dc2df0748f3076c5f8f1f8064db">_getViewport</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current active viewport for rendering.  <a href="#a0cf9dc2df0748f3076c5f8f1f8064db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#8342819c24002599851457e459744561">_setCullingMode</a> (<a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a> mode)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the culling mode for the render system based on the 'vertex winding'.  <a href="#8342819c24002599851457e459744561"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#def5117e5f28fb39e04b59181558a970">_getCullingMode</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#49c162dc3d9b86e37d9085c0ab1e28c6">_setDepthBufferParams</a> (bool depthTest=true, bool depthWrite=true, <a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a> depthFunction=CMPF_LESS_EQUAL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mode of operation for depth buffer tests from this point onwards.  <a href="#49c162dc3d9b86e37d9085c0ab1e28c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#20c5b31b647e3cb6acc5742e75c34b22">_setDepthBufferCheckEnabled</a> (bool enabled=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not the depth buffer check is performed before a pixel write.  <a href="#20c5b31b647e3cb6acc5742e75c34b22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#00bd48a7ba0a2a919586c3b8548d2433">_setDepthBufferWriteEnabled</a> (bool enabled=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not the depth buffer is updated after a pixel write.  <a href="#00bd48a7ba0a2a919586c3b8548d2433"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#577ced6409b614ab393ca377052a385f">_setDepthBufferFunction</a> (<a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a> func=CMPF_LESS_EQUAL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the comparison function for the depth buffer check.  <a href="#577ced6409b614ab393ca377052a385f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#14f37eed62a9283df3f83241f7c0991a">_setColourBufferWriteEnabled</a> (bool red, bool green, bool blue, bool alpha)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not colour buffer writing is enabled, and for which channels.  <a href="#14f37eed62a9283df3f83241f7c0991a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#56beb1cebbf7f1ac372c666657a151cb">_setDepthBias</a> (float constantBias, float slopeScaleBias=0.0f)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the depth bias, NB you should use the <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> version of this.  <a href="#56beb1cebbf7f1ac372c666657a151cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#271a8850ebd5072986b15e875a1a4f44">_setFog</a> (<a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> mode=FOG_NONE, const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;colour=<a class="el" href="classOgre_1_1ColourValue.html#8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a>, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> expDensity=1.0, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearStart=0.0, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearEnd=1.0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the fogging mode for future geometry.  <a href="#271a8850ebd5072986b15e875a1a4f44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#385581061b5d8d9af914d0439392aa62">_beginGeometryCount</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> will keep a count of tris rendered, this resets the count.  <a href="#385581061b5d8d9af914d0439392aa62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#4405cc3651219c6422d04c9b3d843d32">_getFaceCount</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the number of tris rendered since the last _beginGeometryCount call.  <a href="#4405cc3651219c6422d04c9b3d843d32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#f7ed3c5ecb53897d3a17fc4d4b92e560">_getBatchCount</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the number of batches rendered since the last _beginGeometryCount call.  <a href="#f7ed3c5ecb53897d3a17fc4d4b92e560"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#0e59f9845067742cf26b04037b0ce332">_getVertexCount</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports the number of vertices passed to the renderer since the last _beginGeometryCount call.  <a href="#0e59f9845067742cf26b04037b0ce332"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#80d543b61b1152b0dd0049961be4798e">convertColourValue</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;colour, <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> *pDest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a packed data version of the passed in <a class="el" href="classOgre_1_1ColourValue.html" title="Class representing colour.">ColourValue</a> suitable for use as with this <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a>.  <a href="#80d543b61b1152b0dd0049961be4798e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#027109503a988ba85f4c63b55082907f">VertexElementType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#71bc0ec1bf3837dbcf7f4aa39849bb40">getColourVertexElementType</a> (void) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the native VertexElementType for a compact 32-bit colour value for this rendersystem.  <a href="#71bc0ec1bf3837dbcf7f4aa39849bb40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#dedbeb77d3def3967ee1a55c32d16a2b">_convertProjectionMatrix</a> (const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;matrix, <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;dest, bool forGpuProgram=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts a uniform projection matrix to suitable for this render system.  <a href="#dedbeb77d3def3967ee1a55c32d16a2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#d401520ec851d8a1577b97d9ba3924e1">_makeProjectionMatrix</a> (const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;fovy, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> aspect, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> nearPlane, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> farPlane, <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;dest, bool forGpuProgram=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a perspective projection matrix suitable for this render system.  <a href="#d401520ec851d8a1577b97d9ba3924e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a2bd398cb2fef4d6e68c251fab6a80da">_makeProjectionMatrix</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> left, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> right, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> bottom, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> top, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> nearPlane, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> farPlane, <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;dest, bool forGpuProgram=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds a perspective projection matrix for the case when frustum is not centered around camera.  <a href="#a2bd398cb2fef4d6e68c251fab6a80da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a18aad4d16f0448f1fa5a4fcdb224e4a">_makeOrthoMatrix</a> (const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;fovy, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> aspect, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> nearPlane, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> farPlane, <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;dest, bool forGpuProgram=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds an orthographic projection matrix suitable for this render system.  <a href="#a18aad4d16f0448f1fa5a4fcdb224e4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#877089932688a144c6979f648d8768fc">_applyObliqueDepthProjection</a> (<a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;matrix, const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;plane, bool forGpuProgram)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update a perspective projection matrix to use 'oblique depth projection'.  <a href="#877089932688a144c6979f648d8768fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#175e831e73f7c539f843907971836125">_setPolygonMode</a> (<a class="el" href="namespaceOgre.html#68866b02aa7f99e3431337511fbb3345">PolygonMode</a> level)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets how to rasterise triangles, as points, wireframe or solid polys.  <a href="#175e831e73f7c539f843907971836125"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#4b259bf4d4e5878ae8066e073d859287">setStencilCheckEnabled</a> (bool enabled)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns stencil buffer checking on or off.  <a href="#4b259bf4d4e5878ae8066e073d859287"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#86cd01946283fa411208b04197b883a3">setStencilBufferParams</a> (<a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a> func=CMPF_ALWAYS_PASS, <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> refValue=0, <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> mask=0xFFFFFFFF, StencilOperation stencilFailOp=SOP_KEEP, StencilOperation depthFailOp=SOP_KEEP, StencilOperation passOp=SOP_KEEP, bool twoSidedOperation=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if this system supports hardware accelerated stencil buffer.  <a href="#86cd01946283fa411208b04197b883a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#873dc2bc43f8a842fd08b6c7b9dfaabe">setVertexDeclaration</a> (<a class="el" href="classOgre_1_1VertexDeclaration.html">VertexDeclaration</a> *decl)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current vertex declaration, ie the source of vertex data.  <a href="#873dc2bc43f8a842fd08b6c7b9dfaabe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#5f72d5fd9f4af2d29096acb1de95f0e7">setVertexBufferBinding</a> (<a class="el" href="classOgre_1_1VertexBufferBinding.html">VertexBufferBinding</a> *binding)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the current vertex buffer binding state.  <a href="#5f72d5fd9f4af2d29096acb1de95f0e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a9ab2a6569fe30ab63a4714ec58933b4">setNormaliseNormals</a> (bool normalise)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not normals are to be automatically normalised.  <a href="#a9ab2a6569fe30ab63a4714ec58933b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#64961cc3cdc616beb264c51d532c94c1">_render</a> (const <a class="el" href="classOgre_1_1RenderOperation.html">RenderOperation</a> &amp;op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render something to the active viewport.  <a href="#64961cc3cdc616beb264c51d532c94c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <br>
<a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#1ea7609b7337a8b184c4348b09d5c46a">getCapabilities</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the capabilities of the render system.  <a href="#1ea7609b7337a8b184c4348b09d5c46a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="structOgre_1_1DriverVersion.html">DriverVersion</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#d9dbbbf4ae4dc539ebb31d99c7e6c724">getDriverVersion</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the driver version.  <a href="#d9dbbbf4ae4dc539ebb31d99c7e6c724"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#e8144a770f5bbe9390928abf24d37b16">bindGpuProgram</a> (<a class="el" href="classOgre_1_1GpuProgram.html">GpuProgram</a> *prg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binds a given <a class="el" href="classOgre_1_1GpuProgram.html" title="Defines a program which runs on the GPU such as a vertex or fragment program.">GpuProgram</a> (but not the parameters).  <a href="#e8144a770f5bbe9390928abf24d37b16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#09ad156f8a00e59fd6528a8f0204900c">bindGpuProgramParameters</a> (<a class="el" href="namespaceOgre.html#d08e89fa63e81d061ea9e2f37664976e">GpuProgramType</a> gptype, <a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a> params)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind Gpu program parameters.  <a href="#09ad156f8a00e59fd6528a8f0204900c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#e1f7904fe5f6a1d39fe8a0621dab7509">bindGpuProgramPassIterationParameters</a> (<a class="el" href="namespaceOgre.html#d08e89fa63e81d061ea9e2f37664976e">GpuProgramType</a> gptype)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Only binds Gpu program parameters used for passes that have more than one iteration rendering.  <a href="#e1f7904fe5f6a1d39fe8a0621dab7509"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#045731ce43fe553744e69664d5d648b3">unbindGpuProgram</a> (<a class="el" href="namespaceOgre.html#d08e89fa63e81d061ea9e2f37664976e">GpuProgramType</a> gptype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unbinds GpuPrograms of a given GpuProgramType.  <a href="#045731ce43fe553744e69664d5d648b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#1ac003196b5b51384f714924a0041081">isGpuProgramBound</a> (<a class="el" href="namespaceOgre.html#d08e89fa63e81d061ea9e2f37664976e">GpuProgramType</a> gptype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether or not a Gpu program of the given type is currently bound.  <a href="#1ac003196b5b51384f714924a0041081"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#23cc0a7d87b77ec3d0a34e92335bec1a">setClipPlanes</a> (const <a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a> &amp;clipPlanes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the user clipping region.  <a href="#23cc0a7d87b77ec3d0a34e92335bec1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#be0fbe6b4972baf14137235fe3f6c499">addClipPlane</a> (const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a user clipping plane.  <a href="#be0fbe6b4972baf14137235fe3f6c499"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#2eb75175291761881bdc0d73ec379089">addClipPlane</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> A, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> B, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> C, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> D)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a user clipping plane.  <a href="#2eb75175291761881bdc0d73ec379089"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#46a9b1385638112a80bf22fa1a5bf531">resetClipPlanes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the user clipping region.  <a href="#46a9b1385638112a80bf22fa1a5bf531"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#83ca87a7c74baff1db1a9ff6ec61ba54">_initRenderTargets</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility method for initialising all render targets attached to this rendering system.  <a href="#83ca87a7c74baff1db1a9ff6ec61ba54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#ecceb6f1a7d3113de8676d20e39260dc">_notifyCameraRemoved</a> (const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility method to notify all render targets that a camera has been removed, in case they were referring to it as their viewer.  <a href="#ecceb6f1a7d3113de8676d20e39260dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#8ef6bbe5a63769cfe73319ac418624a8">_updateAllRenderTargets</a> (bool swapBuffers=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for updating all render targets attached to this rendering system.  <a href="#8ef6bbe5a63769cfe73319ac418624a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#e8365c3a108964861ca4af053e84901f">_swapAllRenderTargetBuffers</a> (bool waitForVsync=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for swapping all the buffers on all render targets, if _updateAllRenderTargets was called with a 'false' parameter.  <a href="#e8365c3a108964861ca4af053e84901f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#0a0b42f82a637acb3df7fba70c1291aa">setInvertVertexWinding</a> (bool invert)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not vertex windings set should be inverted; this can be important for rendering reflections.  <a href="#0a0b42f82a637acb3df7fba70c1291aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#e0cf822105945ccbdc87a071c220be57">setScissorTest</a> (bool enabled, size_t left=0, size_t top=0, size_t right=800, size_t bottom=600)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the 'scissor region' ie the region of the target in which rendering can take place.  <a href="#e0cf822105945ccbdc87a071c220be57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#ae6b073aaf42ecea55bb972fd5166f42">clearFrameBuffer</a> (unsigned int buffers, const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;colour=<a class="el" href="classOgre_1_1ColourValue.html#7f8a06f2a9dd645417c36b560f496c1a">ColourValue::Black</a>, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> depth=1.0f, unsigned short stencil=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears one or more frame buffers on the active render target.  <a href="#ae6b073aaf42ecea55bb972fd5166f42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#6d706602114e1e4835890cfa4aa6eb2f">getHorizontalTexelOffset</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the horizontal texel offset value required for mapping texel origins to pixel origins in this rendersystem.  <a href="#6d706602114e1e4835890cfa4aa6eb2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#18238c4b41bfaab6ca5f5e19e20d0d55">getVerticalTexelOffset</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the vertical texel offset value required for mapping texel origins to pixel origins in this rendersystem.  <a href="#18238c4b41bfaab6ca5f5e19e20d0d55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#5ab53272b5edee4565c05caa605061d3">getMinimumDepthInputValue</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the minimum (closest) depth value to be used when rendering using identity transforms.  <a href="#5ab53272b5edee4565c05caa605061d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#19ea5b0880338661d1162987a22ab827">getMaximumDepthInputValue</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the maximum (farthest) depth value to be used when rendering using identity transforms.  <a href="#19ea5b0880338661d1162987a22ab827"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#207d38c53699525e2e49ee167f9c8eb5">setCurrentPassIterationCount</a> (const size_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set the current multi pass count value.  <a href="#207d38c53699525e2e49ee167f9c8eb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#927af19c2746aa2dd37018434bfc09f4">setDeriveDepthBias</a> (bool derive, float baseValue=0.0f, float multiplier=0.0f, float slopeScale=0.0f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell the render system whether to derive a depth bias on its own based on the values passed to it in setCurrentPassIterationCount.  <a href="#927af19c2746aa2dd37018434bfc09f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#da5d01c8a4eb8e64140d92fce245800c">addListener</a> (<a class="el" href="classOgre_1_1RenderSystem_1_1Listener.html">Listener</a> *l)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a listener to the custom events that this render system can raise.  <a href="#da5d01c8a4eb8e64140d92fce245800c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#7d9e3b4369f98e46dbea4cb4b9390f9d">removeListener</a> (<a class="el" href="classOgre_1_1RenderSystem_1_1Listener.html">Listener</a> *l)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a listener to the custom events that this render system can raise.  <a href="#7d9e3b4369f98e46dbea4cb4b9390f9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="namespaceOgre.html#783e5227595f351519627abfb740ec85">StringVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#8f3b7402316e7162fb5778235fc6e2f2">getRenderSystemEvents</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a list of the rendersystem specific events that this rendersystem can raise.  <a href="#8f3b7402316e7162fb5778235fc6e2f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#77766da49c29112c390fde51069f543a">preExtraThreadsStarted</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell the rendersystem to perform any prep tasks it needs to directly before other threads which might access the rendering API are registered.  <a href="#77766da49c29112c390fde51069f543a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#460fb2b67acdea8e3a72933e0348a82d">postExtraThreadsStarted</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#ae6874b97f0b5cb00e0bf32e10652540">registerThread</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the an additional thread which may make calls to rendersystem-related objects.  <a href="#ae6874b97f0b5cb00e0bf32e10652540"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#64138779fab3c6b157f2de40c3831e10">unregisterThread</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister an additional thread which may make calls to rendersystem-related objects.  <a href="#64138779fab3c6b157f2de40c3831e10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">operator new, with debug line info  <a href="#421b197ca3a38da17e2eb1531a645fa2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#c4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#b78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">placement operator new  <a href="#b78a921e54419be677839cdf15d1f0b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">array operator new, with debug line info  <a href="#4be37baef81876985aa1071ad5acc6dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#fa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#cb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>

<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::list<br>
&lt; <a class="el" href="classOgre_1_1RenderSystem_1_1Listener.html">Listener</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a1072468272ad965dbc651aa8fc09031">ListenerList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::list<br>
&lt; <a class="el" href="classOgre_1_1HardwareOcclusionQuery.html">HardwareOcclusionQuery</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#b56b367e25b74e95e6ad773a282c494d">HardwareOcclusionQueryList</a></td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#8b7b29f3b542c7cbaeb5da0c1269a388">updatePassIterationRenderState</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">updates pass iteration rendering state including bound gpu program parameter pass iteration auto constant entry  <a href="#8b7b29f3b542c7cbaeb5da0c1269a388"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#739194f14f07f7860f26af9a07fa1ce2">fireEvent</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespaceOgre.html#0537f38d7a77fcbe9f600f6ed8a926d6">NameValuePairList</a> *params=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for firing a rendersystem event.  <a href="#739194f14f07f7860f26af9a07fa1ce2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a5aa48b693e91657888fbb66d069b6f0">setClipPlanesImpl</a> (const <a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a> &amp;clipPlanes)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method used to set the underlying clip planes when needed.  <a href="#a5aa48b693e91657888fbb66d069b6f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#9e90c93fe313f39ee979bdf1179b4538">initialiseFromRenderSystemCapabilities</a> (<a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a> *caps, <a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a> *primary)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the render system from the capabilities.  <a href="#9e90c93fe313f39ee979bdf1179b4538"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#2551e2d3573c437f3beccf7d3ac7a45e">RenderTargetMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#5ea599be4da15690178a9aca2261e992">mRenderTargets</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The render targets.  <a href="#5ea599be4da15690178a9aca2261e992"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#eacbf68563f1c1e5660c4399d398608c">RenderTargetPriorityMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#69c3a5daa75ce78fd56226941f1c8126">mPrioritisedRenderTargets</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The render targets, ordered by priority.  <a href="#69c3a5daa75ce78fd56226941f1c8126"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#398254faea8f9fe6454abb38eee5b3f4">mActiveRenderTarget</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Active render target.  <a href="#398254faea8f9fe6454abb38eee5b3f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#e98e8807b322bccf0eb160afdb54537e">mActiveVertexGpuProgramParameters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Active GPU programs and gpu program parameters.  <a href="#e98e8807b322bccf0eb160afdb54537e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#2d602052ff01a8fd78455916c57a4cef">mActiveGeometryGpuProgramParameters</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#5b9972dd9bb47c45732ad1c82c55817d">mActiveFragmentGpuProgramParameters</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1TextureManager.html">TextureManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#80f14e152184bddc68f8ae05bcefb3be">mTextureManager</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#122f2e8cbddd313582f05677f5a26b1c">mActiveViewport</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#60ce74b29c3e1c9e11041029117a85ad">mCullingMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#c0df5de57fa3480f74c98c65a7211a30">mVSync</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#7c4ad7937f023a43ee43473750d2bfe9">mWBuffer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#039fe39c5374812e776c677404f00898">mBatchCount</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a735bd71b568209de09adfa86b737737">mFaceCount</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#0716f3fd1349f7c4399d805d03e4c394">mVertexCount</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a40237e355676bb7024fccd8699eee96">mManualBlendColours</a> [OGRE_MAX_TEXTURE_LAYERS][2]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saved manual colour blends.  <a href="#a40237e355676bb7024fccd8699eee96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#df3d0f2e777d97e2032ef01cb1b3ecee">mInvertVertexWinding</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#9a071dab9e9b40bfde6d2e85cb363274">mDisabledTexUnitsFrom</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> units from this upwards are disabled.  <a href="#9a071dab9e9b40bfde6d2e85cb363274"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#179ea5dd6f5b8f1430ebc10dd582fdb8">mCurrentPassIterationCount</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of times to render the current state  <a href="#179ea5dd6f5b8f1430ebc10dd582fdb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#633705eb827ce4ad1a0d65761d31335c">mCurrentPassIterationNum</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#d3c918fb9e33cd75b9a802d48acc800d">mDerivedDepthBias</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether to update the depth bias per render call.  <a href="#d3c918fb9e33cd75b9a802d48acc800d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#b852c2a4d985484527f4a701dad60981">mDerivedDepthBiasBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#55404396ef70888e6d7bf0e1d4177c8b">mDerivedDepthBiasMultiplier</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#671636ab611261911a21f52d7cc1c97a">mDerivedDepthBiasSlopeScale</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#783e5227595f351519627abfb740ec85">StringVector</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#b213f4023f49f961377aa52c8c11acc3">mEventNames</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of names of events this rendersystem may raise.  <a href="#b213f4023f49f961377aa52c8c11acc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1RenderSystem.html#a1072468272ad965dbc651aa8fc09031">ListenerList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#d0cf554e93303c9305d3446eb2efb411">mEventListeners</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1RenderSystem.html#b56b367e25b74e95e6ad773a282c494d">HardwareOcclusionQueryList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#7bb1437e3f40cda2bb1495b51ba88791">mHwOcclusionQueries</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#69173bf6d120d39f702c5de9e0815218">mVertexProgramBound</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#989d395609174738d5571fb6892262de">mGeometryProgramBound</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#79ba9d85873031a65a9548e65e50109d">mFragmentProgramBound</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#07c97ddc40ee60325e0bc21930ac5c79">mClipPlanes</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#3d14dfbb2f08906b57df424f9cd96bed">mClipPlanesDirty</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#a4c73904a4dc7b0c097d21acac1ec52f">mRealCapabilities</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to store the capabilities of the graphics card.  <a href="#a4c73904a4dc7b0c097d21acac1ec52f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#748f3ed723a45617a5adfd6c8d4decf2">mCurrentCapabilities</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#b68aeffbe5cb555e1057c0ac3afcee54">mUseCustomCapabilities</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structOgre_1_1DriverVersion.html">DriverVersion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#2a2b64fcb748ff0bd21231c23ad3fe98">mDriverVersion</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#7d062673a4505cc47867677fdb83e455">mTexProjRelative</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem.html#8b5ae0207f8d1faf47169be4a2ee2714">mTexProjRelativeOrigin</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1RenderSystem_1_1Listener.html">Listener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a listener on the custom events that this render system can raise.  <a href="classOgre_1_1RenderSystem_1_1Listener.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Defines the functionality of a 3D API. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> class provides a base interface which abstracts the general functionality of the 3D API e.g. Direct3D or OpenGL. Whilst a few of the general methods have implementations, most of this class is abstract, requiring a subclass based on a specific API to be constructed to provide the full functionality. Note there are 2 levels to the interface - one which will be used often by the caller of the <a class="el" href="namespaceOgre.html">Ogre</a> library, and one which is at a lower level and will be used by the other classes provided by <a class="el" href="namespaceOgre.html">Ogre</a>. These lower level methods are prefixed with '_' to differentiate them. The advanced user of the library may use these lower level methods to access the 3D API at a more fundamental level (dealing direct with render states and rendering primitives), but still benefiting from Ogre's abstraction of exactly which 3D API is in use. </dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Steven Streeting </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l00115">115</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="50a15a7bbc1beca5c91b6584a3060f1b"></a><!-- doxytag: member="Ogre::RenderSystem::RenderTargetIterator" ref="50a15a7bbc1beca5c91b6584a3060f1b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt;<a class="el" href="namespaceOgre.html#2551e2d3573c437f3beccf7d3ac7a45e">Ogre::RenderTargetMap</a>&gt; <a class="el" href="classOgre_1_1MapIterator.html">Ogre::RenderSystem::RenderTargetIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterator over RenderTargets. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l00409">409</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a1072468272ad965dbc651aa8fc09031"></a><!-- doxytag: member="Ogre::RenderSystem::ListenerList" ref="a1072468272ad965dbc651aa8fc09031" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classOgre_1_1RenderSystem_1_1Listener.html">Listener</a>*&gt; <a class="el" href="classOgre_1_1RenderSystem.html#a1072468272ad965dbc651aa8fc09031">Ogre::RenderSystem::ListenerList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01256">1256</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b56b367e25b74e95e6ad773a282c494d"></a><!-- doxytag: member="Ogre::RenderSystem::HardwareOcclusionQueryList" ref="b56b367e25b74e95e6ad773a282c494d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classOgre_1_1HardwareOcclusionQuery.html">HardwareOcclusionQuery</a>*&gt; <a class="el" href="classOgre_1_1RenderSystem.html#b56b367e25b74e95e6ad773a282c494d">Ogre::RenderSystem::HardwareOcclusionQueryList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01259">1259</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="3391b683d588628272d8d9de633e472e"></a><!-- doxytag: member="Ogre::RenderSystem::RenderSystem" ref="3391b683d588628272d8d9de633e472e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::RenderSystem::RenderSystem           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="785f83ff8a4ee8fb21a11c9d6fe5c928"></a><!-- doxytag: member="Ogre::RenderSystem::~RenderSystem" ref="785f83ff8a4ee8fb21a11c9d6fe5c928" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::RenderSystem::~RenderSystem           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="19b810b6fe61b526010812e9af80bf63"></a><!-- doxytag: member="Ogre::RenderSystem::getName" ref="19b810b6fe61b526010812e9af80bf63" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::RenderSystem::getName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of the rendering system. 
<p>

</div>
</div><p>
<a class="anchor" name="7a6236866e64cc19c078383b43872aa8"></a><!-- doxytag: member="Ogre::RenderSystem::getConfigOptions" ref="7a6236866e64cc19c078383b43872aa8" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#9f6262ba9e855a064430936555d0ba62">ConfigOptionMap</a>&amp; Ogre::RenderSystem::getConfigOptions           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the details of this API's configuration options. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Each render system must be able to inform the world of what options must/can be specified for it's operation. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>These are passed as strings for portability, but grouped into a structure (<a class="el" href="structOgre_1_1__ConfigOption.html" title="Packages the details of a configuration option.">_ConfigOption</a>) which includes both options and current value. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that the settings returned from this call are affected by the options that have been set so far, since some options are interdependent. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>This routine is called automatically by the default configuration dialogue produced by <a class="el" href="classOgre_1_1Root.html#3fc8aeaf22da1dccc72ad9fc74b5ef14" title="Displays a dialog asking the user to choose system settings.">Root::showConfigDialog</a> or may be used by the caller for custom settings dialogs </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A 'map' of options, i.e. a list of options which is also indexed by option name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="606200a27a8adebfa62b3e388a49cf39"></a><!-- doxytag: member="Ogre::RenderSystem::setConfigOption" ref="606200a27a8adebfa62b3e388a49cf39" args="(const String &amp;name, const String &amp;value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setConfigOption           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets an option for this API. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Used to confirm the settings (normally chosen by the user) in order to make the renderer able to initialise with the settings as required. This may be video mode, D3D driver, full screen / windowed etc. Called automatically by the default configuration dialog, and by the restoration of saved settings. These settings are stored and only activated when RenderSystem::initialise or <a class="el" href="classOgre_1_1RenderSystem.html#32e21b240c7b6c75eab05cbc870f9868" title="Restart the renderer (normally following a change in settings).">RenderSystem::reinitialise</a> are called. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>If using a custom configuration dialog, it is advised that the caller calls <a class="el" href="classOgre_1_1RenderSystem.html#7a6236866e64cc19c078383b43872aa8" title="Returns the details of this API&#39;s configuration options.">RenderSystem::getConfigOptions</a> again, since some options can alter resulting from a selection. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the option to alter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to set the option to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b7725995f951adff614db3874c8566c"></a><!-- doxytag: member="Ogre::RenderSystem::createHardwareOcclusionQuery" ref="2b7725995f951adff614db3874c8566c" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1HardwareOcclusionQuery.html">HardwareOcclusionQuery</a>* Ogre::RenderSystem::createHardwareOcclusionQuery           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an object for performing hardware occlusion queries. 
<p>

</div>
</div><p>
<a class="anchor" name="c4c60bf4c5d4347fd2b9346a90545e2b"></a><!-- doxytag: member="Ogre::RenderSystem::destroyHardwareOcclusionQuery" ref="c4c60bf4c5d4347fd2b9346a90545e2b" args="(HardwareOcclusionQuery *hq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::destroyHardwareOcclusionQuery           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1HardwareOcclusionQuery.html">HardwareOcclusionQuery</a> *&nbsp;</td>
          <td class="paramname"> <em>hq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy a hardware occlusion query object. 
<p>

</div>
</div><p>
<a class="anchor" name="b19828ac45b10a64357d8b9fc0918351"></a><!-- doxytag: member="Ogre::RenderSystem::validateConfigOptions" ref="b19828ac45b10a64357d8b9fc0918351" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::RenderSystem::validateConfigOptions           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Validates the options set for the rendering system, returning a message if there are problems. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the returned string is empty, there are no problems. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ad26b5af908674412c89242003f5991e"></a><!-- doxytag: member="Ogre::RenderSystem::_initialise" ref="ad26b5af908674412c89242003f5991e" args="(bool autoCreateWindow, const String &amp;windowTitle=&quot;OGRE Render Window&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1RenderWindow.html">RenderWindow</a>* Ogre::RenderSystem::_initialise           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoCreateWindow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>windowTitle</em> = <code>&quot;OGRE&nbsp;Render&nbsp;Window&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start up the renderer using the settings selected (Or the defaults if none have been selected). 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Called by <a class="el" href="classOgre_1_1Root.html#f768914a0dd431ee442bf83157daf570" title="Sets the rendering subsystem to be used.">Root::setRenderSystem</a>. Shouldn't really be called directly, although this can be done if the app wants to. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>autoCreateWindow</em>&nbsp;</td><td>If true, creates a render window automatically, based on settings chosen so far. This saves an extra call to _createRenderWindow for the main render window. </td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b></b></dt><dd>If an application has more specific window requirements, however (e.g. a level design app), it should specify false for this parameter and do it manually. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the automatically created window, if requested, otherwise null. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4cd432497387d2c630a95ad9c0cd9772"></a><!-- doxytag: member="Ogre::RenderSystem::createRenderSystemCapabilities" ref="4cd432497387d2c630a95ad9c0cd9772" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a>* Ogre::RenderSystem::createRenderSystemCapabilities           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query the real capabilities of the GPU and driver in the <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="6219a2d1f92be5548983a03de9522365"></a><!-- doxytag: member="Ogre::RenderSystem::useCustomRenderSystemCapabilities" ref="6219a2d1f92be5548983a03de9522365" args="(RenderSystemCapabilities *capabilities)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::useCustomRenderSystemCapabilities           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a> *&nbsp;</td>
          <td class="paramname"> <em>capabilities</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Force the render system to use the special capabilities. 
<p>
Can only be called before the render system has been fully initializer (before createWindow is called) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>capabilities</em>&nbsp;</td><td>has to be a subset of the real capabilities and the caller is responsible for deallocating capabilities. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="32e21b240c7b6c75eab05cbc870f9868"></a><!-- doxytag: member="Ogre::RenderSystem::reinitialise" ref="32e21b240c7b6c75eab05cbc870f9868" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::reinitialise           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restart the renderer (normally following a change in settings). 
<p>

</div>
</div><p>
<a class="anchor" name="987cf400154a21403b4ff5192d423971"></a><!-- doxytag: member="Ogre::RenderSystem::shutdown" ref="987cf400154a21403b4ff5192d423971" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::shutdown           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shutdown the renderer and cleanup resources. 
<p>

</div>
</div><p>
<a class="anchor" name="b11411028dca873b5739bb42460ce47a"></a><!-- doxytag: member="Ogre::RenderSystem::setAmbientLight" ref="b11411028dca873b5739bb42460ce47a" args="(float r, float g, float b)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setAmbientLight           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the colour &amp; strength of the ambient (global directionless) light in the world. 
<p>

</div>
</div><p>
<a class="anchor" name="5f59ae6268d2cdcc664d161db7f57ea5"></a><!-- doxytag: member="Ogre::RenderSystem::setShadingType" ref="5f59ae6268d2cdcc664d161db7f57ea5" args="(ShadeOptions so)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setShadingType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a>&nbsp;</td>
          <td class="paramname"> <em>so</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the type of light shading required (default = Gouraud). 
<p>

</div>
</div><p>
<a class="anchor" name="5a94b198cfcd383839ea54de695d1700"></a><!-- doxytag: member="Ogre::RenderSystem::setLightingEnabled" ref="5a94b198cfcd383839ea54de695d1700" args="(bool enabled)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setLightingEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not dynamic lighting is enabled. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>If true, dynamic lighting is performed on geometry with normals supplied, geometry without normals will not be displayed. If false, no lighting is applied and all geometry will be full brightness. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="01c339f6e89d82b526fb7725424a4263"></a><!-- doxytag: member="Ogre::RenderSystem::setWBufferEnabled" ref="01c339f6e89d82b526fb7725424a4263" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderSystem::setWBufferEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not W-buffers are enabled if they are available for this renderer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>If true and the renderer supports them W-buffers will be used. If false W-buffers will not be used even if available. W-buffers are enabled by default for 16bit depth buffers and disabled for all other depths. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f7260f2196b08677b2a233f9f7ef8e5"></a><!-- doxytag: member="Ogre::RenderSystem::getWBufferEnabled" ref="8f7260f2196b08677b2a233f9f7ef8e5" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderSystem::getWBufferEnabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the renderer will try to use W-buffers when avalible. 
<p>

</div>
</div><p>
<a class="anchor" name="af156b9f935396e6c17f532f6e6c847e"></a><!-- doxytag: member="Ogre::RenderSystem::_createRenderWindow" ref="af156b9f935396e6c17f532f6e6c847e" args="(const String &amp;name, unsigned int width, unsigned int height, bool fullScreen, const NameValuePairList *miscParams=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1RenderWindow.html">RenderWindow</a>* Ogre::RenderSystem::_createRenderWindow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>fullScreen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#0537f38d7a77fcbe9f600f6ed8a926d6">NameValuePairList</a> *&nbsp;</td>
          <td class="paramname"> <em>miscParams</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new rendering window. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method creates a new rendering window as specified by the paramteters. The rendering system could be responible for only a single window (e.g. in the case of a game), or could be in charge of multiple ones (in the case of a level editor). The option to create the window as a child of another is therefore given. This method will create an appropriate subclass of <a class="el" href="classOgre_1_1RenderWindow.html" title="Manages the target rendering window.">RenderWindow</a> depending on the API and platform implementation. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>After creation, this window can be retrieved using <a class="el" href="classOgre_1_1RenderSystem.html#313d7af5018e65802d96aa7124700db7" title="Returns a pointer to the render target with the passed name, or NULL if that render...">getRenderTarget()</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the window. Used in other methods later like setRenderTarget and getRenderWindow. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The width of the new window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>height</em>&nbsp;</td><td>The height of the new window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fullScreen</em>&nbsp;</td><td>Specify true to make the window full screen without borders, title bar or menu bar. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>miscParams</em>&nbsp;</td><td>A NameValuePairList describing the other parameters for the new rendering window. Options are case sensitive. Unrecognised parameters will be ignored silently. These values might be platform dependent, but these are present for all platforms unless indicated otherwise:</td></tr>
  </table>
</dl>
Key: "title" Description: The title of the window that will appear in the title bar Values: string Default: <a class="el" href="classOgre_1_1RenderTarget.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> name<p>
Key: "colourDepth" Description: Colour depth of the resulting rendering window; only applies if fullScreen is set. Values: 16 or 32 Default: desktop depth Notes: [W32 specific]<p>
Key: "left" Description: screen x coordinate from left Values: positive integers Default: 'center window on screen' Notes: Ignored in case of full screen<p>
Key: "top" Description: screen y coordinate from top Values: positive integers Default: 'center window on screen' Notes: Ignored in case of full screen<p>
Key: "depthBuffer" [DX9 specific] Description: Use depth buffer Values: false or true Default: true<p>
Key: "externalWindowHandle" [API specific] Description: External window handle, for embedding the OGRE context Values: positive integer for W32 (HWND handle) poslong:posint:poslong (display*:screen:windowHandle) or poslong:posint:poslong:poslong (display*:screen:windowHandle:XVisualInfo*) for GLX Default: 0 (None)<p>
Key: "externalGLControl" [Win32 OpenGL specific] Description: Let the external window control OpenGL i.e. don't select a pixel format for the window, do not change v-sync and do not swap buffer. When set to true, the calling application is responsible of OpenGL initialization and buffer swapping. It should also create an OpenGL context for its own rendering, <a class="el" href="namespaceOgre.html">Ogre</a> will create one for its use. Then the calling application must also enable <a class="el" href="namespaceOgre.html">Ogre</a> OpenGL context before calling any <a class="el" href="namespaceOgre.html">Ogre</a> function and restore its OpenGL context after these calls. The <a class="el" href="namespaceOgre.html">Ogre</a> OpenGL context can be retrieved after <a class="el" href="namespaceOgre.html">Ogre</a> initialisation by calling wglGetCurrentDC() and wglGetCurrentContext(). It is only used when the externalWindowHandle parameter is used. Values: true, false Default: false<p>
Key: "externalGLContext" [Win32 OpenGL specific] Description: Use an externally created GL context Values: &lt;Context as="" unsigned="" long&gt;=""&gt; Default: 0 (create own context)<p>
Key: "parentWindowHandle" [API specific] Description: Parent window handle, for embedding the OGRE context Values: positive integer for W32 (HWND handle) poslong:posint:poslong for GLX (display*:screen:windowHandle) Default: 0 (None)<p>
Key: "FSAA" Description: Full screen antialiasing factor Values: 0,2,4,6,... Default: 0<p>
Key: "displayFrequency" Description: Display frequency rate, for fullscreen mode Values: 60...? Default: Desktop vsync rate<p>
Key: "vsync" Description: Synchronize buffer swaps to vsync Values: true, false Default: 0<p>
Key: "border" Description: The type of window border (in windowed mode) Values: none, fixed, resize Default: resize<p>
Key: "outerDimensions" Description: Whether the width/height is expressed as the size of the outer window, rather than the content area Values: true, false Default: false<p>
Key: "useNVPerfHUD" [DX9 specific] Description: Enable the use of nVidia NVPerfHUD Values: true, false Default: false<p>
Key: "gamma" Description: Enable hardware conversion from linear colour space to gamma colour space on rendering to the window. Values: true, false Default: false 
</div>
</div><p>
<a class="anchor" name="857191a1acd18fd25498517bf183efe2"></a><!-- doxytag: member="Ogre::RenderSystem::createMultiRenderTarget" ref="857191a1acd18fd25498517bf183efe2" args="(const String &amp;name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MultiRenderTarget.html">MultiRenderTarget</a>* Ogre::RenderSystem::createMultiRenderTarget           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="classOgre_1_1MultiRenderTarget.html" title="This class represents a render target that renders to multiple RenderTextures at...">MultiRenderTarget</a>, which is a render target that renders to multiple RenderTextures at once. 
<p>
Surfaces can be bound and unbound at will. This fails if mCapabilities-&gt;getNumMultiRenderTargets() is smaller than 2. 
</div>
</div><p>
<a class="anchor" name="65ddf1db4aa3f463e0479c240ffc3dc5"></a><!-- doxytag: member="Ogre::RenderSystem::destroyRenderWindow" ref="65ddf1db4aa3f463e0479c240ffc3dc5" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::destroyRenderWindow           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a render window. 
<p>

</div>
</div><p>
<a class="anchor" name="354ceaa02574d1cf68dcb5999b34df50"></a><!-- doxytag: member="Ogre::RenderSystem::destroyRenderTexture" ref="354ceaa02574d1cf68dcb5999b34df50" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::destroyRenderTexture           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a render texture. 
<p>

</div>
</div><p>
<a class="anchor" name="43a03671d1c7efd7e95100d77080eb8c"></a><!-- doxytag: member="Ogre::RenderSystem::destroyRenderTarget" ref="43a03671d1c7efd7e95100d77080eb8c" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::destroyRenderTarget           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a render target of any sort. 
<p>

</div>
</div><p>
<a class="anchor" name="e3aa9e2fd13e2b066f3f2f56018bd4be"></a><!-- doxytag: member="Ogre::RenderSystem::attachRenderTarget" ref="e3aa9e2fd13e2b066f3f2f56018bd4be" args="(RenderTarget &amp;target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::attachRenderTarget           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attaches the passed render target to the render system. 
<p>

</div>
</div><p>
<a class="anchor" name="313d7af5018e65802d96aa7124700db7"></a><!-- doxytag: member="Ogre::RenderSystem::getRenderTarget" ref="313d7af5018e65802d96aa7124700db7" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a>* Ogre::RenderSystem::getRenderTarget           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the render target with the passed name, or NULL if that render target cannot be found. 
<p>

</div>
</div><p>
<a class="anchor" name="38e818fa1817fd1cfec8655b7702e230"></a><!-- doxytag: member="Ogre::RenderSystem::detachRenderTarget" ref="38e818fa1817fd1cfec8655b7702e230" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a>* Ogre::RenderSystem::detachRenderTarget           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detaches the render target with the passed name from the render system and returns a pointer to it. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the render target cannot be found, NULL is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e8f34e7464302fbce845f1d3fd468c8"></a><!-- doxytag: member="Ogre::RenderSystem::getRenderTargetIterator" ref="2e8f34e7464302fbce845f1d3fd468c8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MapIterator.html">RenderTargetIterator</a> Ogre::RenderSystem::getRenderTargetIterator           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a specialised <a class="el" href="classOgre_1_1MapIterator.html" title="Wraps iteration over a map.">MapIterator</a> over all render targets attached to the <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a>. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l00412">412</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="847238effa8920edf9aee7aa5b8cd7be"></a><!-- doxytag: member="Ogre::RenderSystem::getErrorDescription" ref="847238effa8920edf9aee7aa5b8cd7be" args="(long errorNumber) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::RenderSystem::getErrorDescription           </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>errorNumber</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a description of an error code. 
<p>

</div>
</div><p>
<a class="anchor" name="a18ec4f5823ecb28f2cccdee85e5337c"></a><!-- doxytag: member="Ogre::RenderSystem::setWaitForVerticalBlank" ref="a18ec4f5823ecb28f2cccdee85e5337c" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RenderSystem::setWaitForVerticalBlank           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines whether or now fullscreen render windows wait for the vertical blank before flipping buffers. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>By default, all rendering windows wait for a vertical blank (when the CRT beam turns off briefly to move from the bottom right of the screen back to the top left) before flipping the screen buffers. This ensures that the image you see on the screen is steady. However it restricts the frame rate to the refresh rate of the monitor, and can slow the frame rate down. You can speed this up by not waiting for the blank, but this has the downside of introducing 'tearing' artefacts where part of the previous frame is still displayed as the buffers are switched. Speed vs quality, you choose. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Has NO effect on windowed mode render targets. Only affects fullscreen mode. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>If true, the system waits for vertical blanks - quality over speed. If false it doesn't - speed over quality. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="16bc1ae27d9e3cdf9cfffdb4ed4724c6"></a><!-- doxytag: member="Ogre::RenderSystem::getWaitForVerticalBlank" ref="16bc1ae27d9e3cdf9cfffdb4ed4724c6" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderSystem::getWaitForVerticalBlank           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the system is synchronising frames with the monitor vertical blank. 
<p>

</div>
</div><p>
<a class="anchor" name="c8e632a4d601721d18f7a6758c9fc0af"></a><!-- doxytag: member="Ogre::RenderSystem::_useLights" ref="c8e632a4d601721d18f7a6758c9fc0af" args="(const LightList &amp;lights, unsigned short limit)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_useLights           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>lights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>limit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells the rendersystem to use the attached set of lights (and no others) up to the number specified (this allows the same list to be used with different count limits). 
<p>

</div>
</div><p>
<a class="anchor" name="97cfab83fc9bf9e3df7e2d5ea6fae5c5"></a><!-- doxytag: member="Ogre::RenderSystem::_setWorldMatrix" ref="97cfab83fc9bf9e3df7e2d5ea6fae5c5" args="(const Matrix4 &amp;m)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setWorldMatrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the world transform matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="9442fcdf97b2723c588dee0489f2aefc"></a><!-- doxytag: member="Ogre::RenderSystem::_setWorldMatrices" ref="9442fcdf97b2723c588dee0489f2aefc" args="(const Matrix4 *m, unsigned short count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setWorldMatrices           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets multiple world matrices (vertex blending). 
<p>

</div>
</div><p>
<a class="anchor" name="8cdef3669e7f8e87d6fc8db1ad102f1e"></a><!-- doxytag: member="Ogre::RenderSystem::_setViewMatrix" ref="8cdef3669e7f8e87d6fc8db1ad102f1e" args="(const Matrix4 &amp;m)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setViewMatrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the view transform matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="968dffb7114639b2c3aa39f6323fd66e"></a><!-- doxytag: member="Ogre::RenderSystem::_setProjectionMatrix" ref="968dffb7114639b2c3aa39f6323fd66e" args="(const Matrix4 &amp;m)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setProjectionMatrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the projection transform matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="d504623eff0678f9f79b075f32673414"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureUnitSettings" ref="d504623eff0678f9f79b075f32673414" args="(size_t texUnit, TextureUnitState &amp;tl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureUnitSettings           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>texUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1TextureUnitState.html">TextureUnitState</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Utility function for setting all the properties of a texture unit at once. 
<p>
This method is also worth using over the individual texture unit settings because it only sets those settings which are different from the current settings for this unit, thus minimising render state changes. 
</div>
</div><p>
<a class="anchor" name="058d6805142fce7ec095a018447cbe33"></a><!-- doxytag: member="Ogre::RenderSystem::_disableTextureUnit" ref="058d6805142fce7ec095a018447cbe33" args="(size_t texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_disableTextureUnit           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>texUnit</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Turns off a texture unit. 
<p>

</div>
</div><p>
<a class="anchor" name="68e0ecb23c3eba58b5aeb06d646ce4cd"></a><!-- doxytag: member="Ogre::RenderSystem::_disableTextureUnitsFrom" ref="68e0ecb23c3eba58b5aeb06d646ce4cd" args="(size_t texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_disableTextureUnitsFrom           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>texUnit</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disables all texture units from the given unit upwards. 
<p>

</div>
</div><p>
<a class="anchor" name="ca86be508b2afbbe67e2eac635ac640d"></a><!-- doxytag: member="Ogre::RenderSystem::_setSurfaceParams" ref="ca86be508b2afbbe67e2eac635ac640d" args="(const ColourValue &amp;ambient, const ColourValue &amp;diffuse, const ColourValue &amp;specular, const ColourValue &amp;emissive, Real shininess, TrackVertexColourType tracking=TVC_NONE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setSurfaceParams           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ambient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>diffuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>specular</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>emissive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>shininess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#f3fdba7211d7078a43201a1721532f9e">TrackVertexColourType</a>&nbsp;</td>
          <td class="paramname"> <em>tracking</em> = <code>TVC_NONE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the surface properties to be used for future rendering. 
<p>
This method sets the the properties of the surfaces of objects to be rendered after it. In this context these surface properties are the amount of each type of light the object reflects (determining it's colour under different types of light), whether it emits light itself, and how shiny it is. Textures are not dealt with here, see the _setTetxure method for details. This method is used by _setMaterial so does not need to be called direct if that method is being used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ambient</em>&nbsp;</td><td>The amount of ambient (sourceless and directionless) light an object reflects. Affected by the colour/amount of ambient light in the scene. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>diffuse</em>&nbsp;</td><td>The amount of light from directed sources that is reflected (affected by colour/amount of point, directed and spot light sources) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>specular</em>&nbsp;</td><td>The amount of specular light reflected. This is also affected by directed light sources but represents the colour at the highlights of the object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>emissive</em>&nbsp;</td><td>The colour of light emitted from the object. Note that this will make an object seem brighter and not dependent on lights in the scene, but it will not act as a light, so will not illuminate other objects. Use a light attached to the same <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as the object for this purpose. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shininess</em>&nbsp;</td><td>A value which only has an effect on specular highlights (so specular must be non-black). The higher this value, the smaller and crisper the specular highlights will be, imitating a more highly polished surface. This value is not constrained to 0.0-1.0, in fact it is likely to be more (10.0 gives a modest sheen to an object). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tracking</em>&nbsp;</td><td>A bit field that describes which of the ambient, diffuse, specular and emissive colours follow the vertex colour of the primitive. When a bit in this field is set its <a class="el" href="classOgre_1_1ColourValue.html" title="Class representing colour.">ColourValue</a> is ignored. This is a combination of TVC_AMBIENT, TVC_DIFFUSE, TVC_SPECULAR(note that the shininess value is still taken from shininess) and TVC_EMISSIVE. TVC_NONE means that there will be no material property tracking the vertex colours. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7cca254fe5034f59e9d4dc4b9dc95742"></a><!-- doxytag: member="Ogre::RenderSystem::_setPointSpritesEnabled" ref="7cca254fe5034f59e9d4dc4b9dc95742" args="(bool enabled)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setPointSpritesEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not rendering points using OT_POINT_LIST will render point sprites (textured quads) or plain points. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>True enables point sprites, false returns to normal point rendering. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6ca319dee8eb1693186b85bbb423533f"></a><!-- doxytag: member="Ogre::RenderSystem::_setPointParameters" ref="6ca319dee8eb1693186b85bbb423533f" args="(Real size, bool attenuationEnabled, Real constant, Real linear, Real quadratic, Real minSize, Real maxSize)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setPointParameters           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>attenuationEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>linear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>quadratic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>minSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>maxSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the size of points and how they are attenuated with distance. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>When performing point rendering or point sprite rendering, point size can be attenuated with distance. The equation for doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2) . </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>For example, to disable distance attenuation (constant screensize) you would set constant to 1, and linear and quadratic to 0. A standard perspective attenuation would be 0, 1, 0 respectively. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2cb551bfdd04b7426f73a84cbcbc93f7"></a><!-- doxytag: member="Ogre::RenderSystem::_setTexture" ref="2cb551bfdd04b7426f73a84cbcbc93f7" args="(size_t unit, bool enabled, const TexturePtr &amp;texPtr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTexture           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1TexturePtr.html">TexturePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>texPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the texture to bind to a given texture unit. 
<p>
User processes would not normally call this direct unless rendering primitives themselves.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unit</em>&nbsp;</td><td>The index of the texture unit to modify. Multitexturing hardware can support multiple units (see RenderSystemCapabilites::getNumTextureUnits) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>Boolean to turn the unit on/off </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texPtr</em>&nbsp;</td><td>Pointer to the texture to use. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="aa2dacc8b8fc28c649a8a603d1f5909c"></a><!-- doxytag: member="Ogre::RenderSystem::_setTexture" ref="aa2dacc8b8fc28c649a8a603d1f5909c" args="(size_t unit, bool enabled, const String &amp;texname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTexture           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>texname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the texture to bind to a given texture unit. 
<p>
User processes would not normally call this direct unless rendering primitives themselves.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unit</em>&nbsp;</td><td>The index of the texture unit to modify. Multitexturing hardware can support multiple units (see RenderSystemCapabilites::getNumTextureUnits) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>Boolean to turn the unit on/off </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texname</em>&nbsp;</td><td>The name of the texture to use - this should have already been loaded with <a class="el" href="classOgre_1_1TextureManager.html#1db642a9eef36b32dbdea28d19e8ea0d" title="Loads a texture from a file.">TextureManager::load</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f40bfb084b051d8433b0893921613ba7"></a><!-- doxytag: member="Ogre::RenderSystem::_setVertexTexture" ref="f40bfb084b051d8433b0893921613ba7" args="(size_t unit, const TexturePtr &amp;tex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setVertexTexture           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1TexturePtr.html">TexturePtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Binds a texture to a vertex sampler. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Not all rendersystems support separate vertex samplers. For those that do, you can set a texture for them, separate to the regular texture samplers, using this method. For those that don't, you should use the regular texture samplers which are shared between the vertex and fragment units; calling this method will throw an exception. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>RenderSystemCapabilites::getVertexTextureUnitsShared </dd></dl>

</div>
</div><p>
<a class="anchor" name="d8ca02fa31e477271f35054173e1836b"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureCoordSet" ref="d8ca02fa31e477271f35054173e1836b" args="(size_t unit, size_t index)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureCoordSet           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the texture coordinate set to use for a texture unit. 
<p>
Meant for use internally - not generally used directly by apps - the <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> and <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> classes let you manage textures far more easily.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unit</em>&nbsp;</td><td><a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> unit as above </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the texture coordinate set to use. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f37341fd724098023aa0be0850302b0"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureCoordCalculation" ref="8f37341fd724098023aa0be0850302b0" args="(size_t unit, TexCoordCalcMethod m, const Frustum *frustum=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureCoordCalculation           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a9c06899edc6b7aed7bf3b29abe9bb31">TexCoordCalcMethod</a>&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Frustum.html">Frustum</a> *&nbsp;</td>
          <td class="paramname"> <em>frustum</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a method for automatically calculating texture coordinates for a stage. 
<p>
Should not be used by apps - for use by <a class="el" href="namespaceOgre.html">Ogre</a> only. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unit</em>&nbsp;</td><td><a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> unit as above </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>Calculation method to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frustum</em>&nbsp;</td><td>Optional <a class="el" href="classOgre_1_1Frustum.html" title="A frustum represents a pyramid, capped at the near and far end which is used to represent...">Frustum</a> param, only used for projective effects </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="33ce98658bb9f6fdb1aca70c8041ef81"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureBlendMode" ref="33ce98658bb9f6fdb1aca70c8041ef81" args="(size_t unit, const LayerBlendModeEx &amp;bm)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureBlendMode           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1LayerBlendModeEx.html">LayerBlendModeEx</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the texture blend modes from a <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> record. 
<p>
Meant for use internally only - apps should use the <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> and <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> classes. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unit</em>&nbsp;</td><td><a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> unit as above </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bm</em>&nbsp;</td><td>Details of the blending mode </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dbc64c669661f87ee2f8db8dd18a0fe5"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureUnitFiltering" ref="dbc64c669661f87ee2f8db8dd18a0fe5" args="(size_t unit, FilterOptions minFilter, FilterOptions magFilter, FilterOptions mipFilter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureUnitFiltering           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#02306c6246268d35f45ad22278bd5d3d">FilterOptions</a>&nbsp;</td>
          <td class="paramname"> <em>minFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#02306c6246268d35f45ad22278bd5d3d">FilterOptions</a>&nbsp;</td>
          <td class="paramname"> <em>magFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#02306c6246268d35f45ad22278bd5d3d">FilterOptions</a>&nbsp;</td>
          <td class="paramname"> <em>mipFilter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the filtering options for a given texture unit. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unit</em>&nbsp;</td><td>The texture unit to set the filtering options for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minFilter</em>&nbsp;</td><td>The filter used when a texture is reduced in size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>magFilter</em>&nbsp;</td><td>The filter used when a texture is magnified </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mipFilter</em>&nbsp;</td><td>The filter used between mipmap levels, FO_NONE disables mipmapping </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1f0f550def3f4caa1173ed6eb0d09031"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureUnitFiltering" ref="1f0f550def3f4caa1173ed6eb0d09031" args="(size_t unit, FilterType ftype, FilterOptions filter)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureUnitFiltering           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#c1fc36ec2f4df4b2afa9fa39f9c66c06">FilterType</a>&nbsp;</td>
          <td class="paramname"> <em>ftype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#02306c6246268d35f45ad22278bd5d3d">FilterOptions</a>&nbsp;</td>
          <td class="paramname"> <em>filter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a single filter for a given texture unit. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unit</em>&nbsp;</td><td>The texture unit to set the filtering options for </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ftype</em>&nbsp;</td><td>The filter type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filter</em>&nbsp;</td><td>The filter to be used </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ba523c0055a520d25fd7f08683e3c98e"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureLayerAnisotropy" ref="ba523c0055a520d25fd7f08683e3c98e" args="(size_t unit, unsigned int maxAnisotropy)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureLayerAnisotropy           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>maxAnisotropy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximal anisotropy for the specified texture unit. 
<p>

</div>
</div><p>
<a class="anchor" name="67b3f87c6ef12e5b24812eeb61635308"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureAddressingMode" ref="67b3f87c6ef12e5b24812eeb61635308" args="(size_t unit, const TextureUnitState::UVWAddressingMode &amp;uvw)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureAddressingMode           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOgre_1_1TextureUnitState_1_1UVWAddressingMode.html">TextureUnitState::UVWAddressingMode</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>uvw</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the texture addressing mode for a texture unit. 
<p>

</div>
</div><p>
<a class="anchor" name="d771e198662c3316b13b2c86caff6f2e"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureBorderColour" ref="d771e198662c3316b13b2c86caff6f2e" args="(size_t unit, const ColourValue &amp;colour)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureBorderColour           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colour</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the texture border colour for a texture unit. 
<p>

</div>
</div><p>
<a class="anchor" name="99f92ad60c2da38c7dfcf3f429e65572"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureMipmapBias" ref="99f92ad60c2da38c7dfcf3f429e65572" args="(size_t unit, float bias)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureMipmapBias           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>bias</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mipmap bias value for a given texture unit. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This allows you to adjust the mipmap calculation up or down for a given texture unit. Negative values force a larger mipmap to be used, positive values force a smaller mipmap to be used. Units are in numbers of levels, so +1 forces the mipmaps to one smaller level. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Only does something if render system has capability RSC_MIPMAP_LOD_BIAS. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1212c8aa766ec3b309ee2216bec0ef88"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureMatrix" ref="1212c8aa766ec3b309ee2216bec0ef88" args="(size_t unit, const Matrix4 &amp;xform)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureMatrix           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>xform</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the texture coordinate transformation matrix for a texture unit. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unit</em>&nbsp;</td><td><a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> unit to affect </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xform</em>&nbsp;</td><td>The 4x4 matrix </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bf639b982318a0211e98329e0c22fc32"></a><!-- doxytag: member="Ogre::RenderSystem::_setSceneBlending" ref="bf639b982318a0211e98329e0c22fc32" args="(SceneBlendFactor sourceFactor, SceneBlendFactor destFactor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setSceneBlending           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>destFactor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the global blending factors for combining subsequent renders with the existing frame contents. 
<p>
The result of the blending operation is: <p>
final = (texture * sourceFactor) + (pixel * destFactor) Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor enumerated type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceFactor</em>&nbsp;</td><td>The source factor in the above calculation, i.e. multiplied by the texture colour components. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destFactor</em>&nbsp;</td><td>The destination factor in the above calculation, i.e. multiplied by the pixel colour components. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e6357924eafe2464bf665be474a9b4a3"></a><!-- doxytag: member="Ogre::RenderSystem::_setSeparateSceneBlending" ref="e6357924eafe2464bf665be474a9b4a3" args="(SceneBlendFactor sourceFactor, SceneBlendFactor destFactor, SceneBlendFactor sourceFactorAlpha, SceneBlendFactor destFactorAlpha)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setSeparateSceneBlending           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>destFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>sourceFactorAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>destFactorAlpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the global blending factors for combining subsequent renders with the existing frame contents. 
<p>
The result of the blending operation is: <p>
final = (texture * sourceFactor) + (pixel * destFactor) Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor enumerated type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sourceFactor</em>&nbsp;</td><td>The source factor in the above calculation, i.e. multiplied by the texture colour components. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destFactor</em>&nbsp;</td><td>The destination factor in the above calculation, i.e. multiplied by the pixel colour components. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceFactorAlpha</em>&nbsp;</td><td>The source factor in the above calculation for the alpha channel, i.e. multiplied by the texture alpha components. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destFactorAlpha</em>&nbsp;</td><td>The destination factor in the above calculation for the alpha channel, i.e. multiplied by the pixel alpha components. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6a3facdc0f1b8c68af65598fd3fd34aa"></a><!-- doxytag: member="Ogre::RenderSystem::_setAlphaRejectSettings" ref="6a3facdc0f1b8c68af65598fd3fd34aa" args="(CompareFunction func, unsigned char value, bool alphaToCoverage)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setAlphaRejectSettings           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>alphaToCoverage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the global alpha rejection approach for future renders. 
<p>
By default images are rendered regardless of texture alpha. This method lets you change that. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>The comparison function which must pass for a pixel to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>The value to compare each pixels alpha value to (0-255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>alphaToCoverage</em>&nbsp;</td><td>Whether to enable alpha to coverage, if supported </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="91e7ee7dd1f244ffa9a0681efb6fae6c"></a><!-- doxytag: member="Ogre::RenderSystem::_setTextureProjectionRelativeTo" ref="91e7ee7dd1f244ffa9a0681efb6fae6c" args="(bool enabled, const Vector3 &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setTextureProjectionRelativeTo           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notify the rendersystem that it should adjust texture projection to be relative to a different origin. 
<p>

</div>
</div><p>
<a class="anchor" name="80b7ab32b8f82cf340c47d55f6e69881"></a><!-- doxytag: member="Ogre::RenderSystem::_beginFrame" ref="80b7ab32b8f82cf340c47d55f6e69881" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_beginFrame           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signifies the beginning of a frame, i.e. 
<p>
the start of rendering on a single viewport. Will occur several times per complete frame if multiple viewports exist. 
</div>
</div><p>
<a class="anchor" name="ad966c6f361ac75304c1e03f9ec384c4"></a><!-- doxytag: member="Ogre::RenderSystem::_endFrame" ref="ad966c6f361ac75304c1e03f9ec384c4" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_endFrame           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ends rendering of a frame to the current viewport. 
<p>

</div>
</div><p>
<a class="anchor" name="7d7f7d706450808859f338352c5e9cd0"></a><!-- doxytag: member="Ogre::RenderSystem::_setViewport" ref="7d7f7d706450808859f338352c5e9cd0" args="(Viewport *vp)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setViewport           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td>
          <td class="paramname"> <em>vp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the provided viewport as the active one for future rendering operations. 
<p>
This viewport is aware of it's own camera and render target. Must be implemented by subclass.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Pointer to the appropriate viewport. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a0cf9dc2df0748f3076c5f8f1f8064db"></a><!-- doxytag: member="Ogre::RenderSystem::_getViewport" ref="a0cf9dc2df0748f3076c5f8f1f8064db" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Viewport.html">Viewport</a>* Ogre::RenderSystem::_getViewport           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current active viewport for rendering. 
<p>

</div>
</div><p>
<a class="anchor" name="8342819c24002599851457e459744561"></a><!-- doxytag: member="Ogre::RenderSystem::_setCullingMode" ref="8342819c24002599851457e459744561" args="(CullingMode mode)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setCullingMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the culling mode for the render system based on the 'vertex winding'. 
<p>
A typical way for the rendering engine to cull triangles is based on the 'vertex winding' of triangles. Vertex winding refers to the direction in which the vertices are passed or indexed to in the rendering operation as viewed from the camera, and will wither be clockwise or anticlockwise (that's 'counterclockwise' for you Americans out there ;) The default is CULL_CLOCKWISE i.e. that only triangles whose vertices are passed/indexed in anticlockwise order are rendered - this is a common approach and is used in 3D studio models for example. You can alter this culling mode if you wish but it is not advised unless you know what you are doing. You may wish to use the CULL_NONE option for mesh data that you cull yourself where the vertex winding is uncertain. 
</div>
</div><p>
<a class="anchor" name="def5117e5f28fb39e04b59181558a970"></a><!-- doxytag: member="Ogre::RenderSystem::_getCullingMode" ref="def5117e5f28fb39e04b59181558a970" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a> Ogre::RenderSystem::_getCullingMode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="49c162dc3d9b86e37d9085c0ab1e28c6"></a><!-- doxytag: member="Ogre::RenderSystem::_setDepthBufferParams" ref="49c162dc3d9b86e37d9085c0ab1e28c6" args="(bool depthTest=true, bool depthWrite=true, CompareFunction depthFunction=CMPF_LESS_EQUAL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setDepthBufferParams           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>depthTest</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>depthWrite</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a>&nbsp;</td>
          <td class="paramname"> <em>depthFunction</em> = <code>CMPF_LESS_EQUAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mode of operation for depth buffer tests from this point onwards. 
<p>
Sometimes you may wish to alter the behaviour of the depth buffer to achieve special effects. Because it's unlikely that you'll set these options for an entire frame, but rather use them to tweak settings between rendering objects, this is an internal method (indicated by the '_' prefix) which will be used by a <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementation rather than directly from the client application. If this method is never called the settings are automatically the same as the default parameters. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>depthTest</em>&nbsp;</td><td>If true, the depth buffer is tested for each pixel and the frame buffer is only updated if the depth function test succeeds. If false, no test is performed and pixels are always written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depthWrite</em>&nbsp;</td><td>If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds. If false, the depth buffer is left unchanged even if a new pixel is written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depthFunction</em>&nbsp;</td><td>Sets the function required for the depth test. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="20c5b31b647e3cb6acc5742e75c34b22"></a><!-- doxytag: member="Ogre::RenderSystem::_setDepthBufferCheckEnabled" ref="20c5b31b647e3cb6acc5742e75c34b22" args="(bool enabled=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setDepthBufferCheckEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not the depth buffer check is performed before a pixel write. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>If true, the depth buffer is tested for each pixel and the frame buffer is only updated if the depth function test succeeds. If false, no test is performed and pixels are always written. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="00bd48a7ba0a2a919586c3b8548d2433"></a><!-- doxytag: member="Ogre::RenderSystem::_setDepthBufferWriteEnabled" ref="00bd48a7ba0a2a919586c3b8548d2433" args="(bool enabled=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setDepthBufferWriteEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not the depth buffer is updated after a pixel write. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds. If false, the depth buffer is left unchanged even if a new pixel is written. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="577ced6409b614ab393ca377052a385f"></a><!-- doxytag: member="Ogre::RenderSystem::_setDepthBufferFunction" ref="577ced6409b614ab393ca377052a385f" args="(CompareFunction func=CMPF_LESS_EQUAL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setDepthBufferFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a>&nbsp;</td>
          <td class="paramname"> <em>func</em> = <code>CMPF_LESS_EQUAL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the comparison function for the depth buffer check. 
<p>
Advanced use only - allows you to choose the function applied to compare the depth values of new and existing pixels in the depth buffer. Only an issue if the deoth buffer check is enabled (see _setDepthBufferCheckEnabled) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>The comparison between the new depth and the existing depth which must return true for the new pixel to be written. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="14f37eed62a9283df3f83241f7c0991a"></a><!-- doxytag: member="Ogre::RenderSystem::_setColourBufferWriteEnabled" ref="14f37eed62a9283df3f83241f7c0991a" args="(bool red, bool green, bool blue, bool alpha)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setColourBufferWriteEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not colour buffer writing is enabled, and for which channels. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>For some advanced effects, you may wish to turn off the writing of certain colour channels, or even all of the colour channels so that only the depth buffer is updated in a rendering pass. However, the chances are that you really want to use this option through the <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> class. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>red,green,blue,alpha</em>&nbsp;</td><td>Whether writing is enabled for each of the 4 colour channels. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="56beb1cebbf7f1ac372c666657a151cb"></a><!-- doxytag: member="Ogre::RenderSystem::_setDepthBias" ref="56beb1cebbf7f1ac372c666657a151cb" args="(float constantBias, float slopeScaleBias=0.0f)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setDepthBias           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>constantBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>slopeScaleBias</em> = <code>0.0f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the depth bias, NB you should use the <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> version of this. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>When polygons are coplanar, you can get problems with 'depth fighting' where the pixels from the two polys compete for the same screen pixel. This is particularly a problem for decals (polys attached to another surface to represent details such as bulletholes etc.). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>A way to combat this problem is to use a depth bias to adjust the depth buffer value used for the decal such that it is slightly higher than the true value, ensuring that the decal appears on top. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The final bias value is a combination of a constant bias and a bias proportional to the maximum depth slope of the polygon being rendered. The final bias is constantBias + slopeScaleBias * maxslope. Slope scale biasing is generally preferable but is not available on older hardware. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>constantBias</em>&nbsp;</td><td>The constant bias value, expressed as a value in homogeneous depth coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slopeScaleBias</em>&nbsp;</td><td>The bias value which is factored by the maximum slope of the polygon, see the description above. This is not supported by all cards. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="271a8850ebd5072986b15e875a1a4f44"></a><!-- doxytag: member="Ogre::RenderSystem::_setFog" ref="271a8850ebd5072986b15e875a1a4f44" args="(FogMode mode=FOG_NONE, const ColourValue &amp;colour=ColourValue::White, Real expDensity=1.0, Real linearStart=0.0, Real linearEnd=1.0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setFog           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FOG_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colour</em> = <code><a class="el" href="classOgre_1_1ColourValue.html#8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>expDensity</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>linearStart</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>linearEnd</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the fogging mode for future geometry. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colour</em>&nbsp;</td><td>The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expDensity</em>&nbsp;</td><td>The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 1. i.e. completely opaque, lower values can mean that fog never completely obscures the scene. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>linearStart</em>&nbsp;</td><td>Distance at which linear fog starts to encroach. The distance must be passed as a parametric value between 0 and 1, with 0 being the near clipping plane, and 1 being the far clipping plane. Only applicable if mode is FOG_LINEAR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>linearEnd</em>&nbsp;</td><td>Distance at which linear fog becomes completely opaque.The distance must be passed as a parametric value between 0 and 1, with 0 being the near clipping plane, and 1 being the far clipping plane. Only applicable if mode is FOG_LINEAR. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="385581061b5d8d9af914d0439392aa62"></a><!-- doxytag: member="Ogre::RenderSystem::_beginGeometryCount" ref="385581061b5d8d9af914d0439392aa62" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_beginGeometryCount           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> will keep a count of tris rendered, this resets the count. 
<p>

</div>
</div><p>
<a class="anchor" name="4405cc3651219c6422d04c9b3d843d32"></a><!-- doxytag: member="Ogre::RenderSystem::_getFaceCount" ref="4405cc3651219c6422d04c9b3d843d32" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Ogre::RenderSystem::_getFaceCount           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports the number of tris rendered since the last _beginGeometryCount call. 
<p>

</div>
</div><p>
<a class="anchor" name="f7ed3c5ecb53897d3a17fc4d4b92e560"></a><!-- doxytag: member="Ogre::RenderSystem::_getBatchCount" ref="f7ed3c5ecb53897d3a17fc4d4b92e560" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Ogre::RenderSystem::_getBatchCount           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports the number of batches rendered since the last _beginGeometryCount call. 
<p>

</div>
</div><p>
<a class="anchor" name="0e59f9845067742cf26b04037b0ce332"></a><!-- doxytag: member="Ogre::RenderSystem::_getVertexCount" ref="0e59f9845067742cf26b04037b0ce332" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int Ogre::RenderSystem::_getVertexCount           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports the number of vertices passed to the renderer since the last _beginGeometryCount call. 
<p>

</div>
</div><p>
<a class="anchor" name="80d543b61b1152b0dd0049961be4798e"></a><!-- doxytag: member="Ogre::RenderSystem::convertColourValue" ref="80d543b61b1152b0dd0049961be4798e" args="(const ColourValue &amp;colour, uint32 *pDest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::convertColourValue           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>pDest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates a packed data version of the passed in <a class="el" href="classOgre_1_1ColourValue.html" title="Class representing colour.">ColourValue</a> suitable for use as with this <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Since different render systems have different colour data formats (eg RGBA for GL, ARGB for D3D) this method allows you to use 1 method for all. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>colour</em>&nbsp;</td><td>The colour to convert </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDest</em>&nbsp;</td><td>Pointer to location to put the result. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="71bc0ec1bf3837dbcf7f4aa39849bb40"></a><!-- doxytag: member="Ogre::RenderSystem::getColourVertexElementType" ref="71bc0ec1bf3837dbcf7f4aa39849bb40" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#027109503a988ba85f4c63b55082907f">VertexElementType</a> Ogre::RenderSystem::getColourVertexElementType           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the native VertexElementType for a compact 32-bit colour value for this rendersystem. 
<p>

</div>
</div><p>
<a class="anchor" name="dedbeb77d3def3967ee1a55c32d16a2b"></a><!-- doxytag: member="Ogre::RenderSystem::_convertProjectionMatrix" ref="dedbeb77d3def3967ee1a55c32d16a2b" args="(const Matrix4 &amp;matrix, Matrix4 &amp;dest, bool forGpuProgram=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_convertProjectionMatrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forGpuProgram</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a uniform projection matrix to suitable for this render system. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Because different APIs have different requirements (some incompatible) for the projection matrix, this method allows each to implement their own correctly and pass back a generic OGRE matrix for storage in the engine. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d401520ec851d8a1577b97d9ba3924e1"></a><!-- doxytag: member="Ogre::RenderSystem::_makeProjectionMatrix" ref="d401520ec851d8a1577b97d9ba3924e1" args="(const Radian &amp;fovy, Real aspect, Real nearPlane, Real farPlane, Matrix4 &amp;dest, bool forGpuProgram=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_makeProjectionMatrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forGpuProgram</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a perspective projection matrix suitable for this render system. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Because different APIs have different requirements (some incompatible) for the projection matrix, this method allows each to implement their own correctly and pass back a generic OGRE matrix for storage in the engine. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2bd398cb2fef4d6e68c251fab6a80da"></a><!-- doxytag: member="Ogre::RenderSystem::_makeProjectionMatrix" ref="a2bd398cb2fef4d6e68c251fab6a80da" args="(Real left, Real right, Real bottom, Real top, Real nearPlane, Real farPlane, Matrix4 &amp;dest, bool forGpuProgram=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_makeProjectionMatrix           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forGpuProgram</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a perspective projection matrix for the case when frustum is not centered around camera. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="classOgre_1_1Viewport.html" title="An abstraction of a viewport, i.e.">Viewport</a> coordinates are in camera coordinate frame, i.e. camera is at the origin. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a18aad4d16f0448f1fa5a4fcdb224e4a"></a><!-- doxytag: member="Ogre::RenderSystem::_makeOrthoMatrix" ref="a18aad4d16f0448f1fa5a4fcdb224e4a" args="(const Radian &amp;fovy, Real aspect, Real nearPlane, Real farPlane, Matrix4 &amp;dest, bool forGpuProgram=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_makeOrthoMatrix           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Radian.html">Radian</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>nearPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>farPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forGpuProgram</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an orthographic projection matrix suitable for this render system. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Because different APIs have different requirements (some incompatible) for the projection matrix, this method allows each to implement their own correctly and pass back a generic OGRE matrix for storage in the engine. </dd></dl>

</div>
</div><p>
<a class="anchor" name="877089932688a144c6979f648d8768fc"></a><!-- doxytag: member="Ogre::RenderSystem::_applyObliqueDepthProjection" ref="877089932688a144c6979f648d8768fc" args="(Matrix4 &amp;matrix, const Plane &amp;plane, bool forGpuProgram)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_applyObliqueDepthProjection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>forGpuProgram</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update a perspective projection matrix to use 'oblique depth projection'. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method can be used to change the nature of a perspective transform in order to make the near plane not perpendicular to the camera view direction, but to be at some different orientation. This can be useful for performing arbitrary clipping (e.g. to a reflection plane) which could otherwise only be done using user clip planes, which are more expensive, and not necessarily supported on all cards. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The existing projection matrix. Note that this must be a perspective transform (not orthographic), and must not have already been altered by this method. The matrix will be altered in-place. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>The plane which is to be used as the clipping plane. This plane must be in CAMERA (view) space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>forGpuProgram</em>&nbsp;</td><td>Is this for use with a Gpu program or fixed-function </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="175e831e73f7c539f843907971836125"></a><!-- doxytag: member="Ogre::RenderSystem::_setPolygonMode" ref="175e831e73f7c539f843907971836125" args="(PolygonMode level)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_setPolygonMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#68866b02aa7f99e3431337511fbb3345">PolygonMode</a>&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets how to rasterise triangles, as points, wireframe or solid polys. 
<p>

</div>
</div><p>
<a class="anchor" name="4b259bf4d4e5878ae8066e073d859287"></a><!-- doxytag: member="Ogre::RenderSystem::setStencilCheckEnabled" ref="4b259bf4d4e5878ae8066e073d859287" args="(bool enabled)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setStencilCheckEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Turns stencil buffer checking on or off. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Stencilling (masking off areas of the rendering target based on the stencil buffer) can be turned on or off using this method. By default, stencilling is disabled. </dd></dl>

</div>
</div><p>
<a class="anchor" name="86cd01946283fa411208b04197b883a3"></a><!-- doxytag: member="Ogre::RenderSystem::setStencilBufferParams" ref="86cd01946283fa411208b04197b883a3" args="(CompareFunction func=CMPF_ALWAYS_PASS, uint32 refValue=0, uint32 mask=0xFFFFFFFF, StencilOperation stencilFailOp=SOP_KEEP, StencilOperation depthFailOp=SOP_KEEP, StencilOperation passOp=SOP_KEEP, bool twoSidedOperation=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setStencilBufferParams           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a>&nbsp;</td>
          <td class="paramname"> <em>func</em> = <code>CMPF_ALWAYS_PASS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>refValue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>mask</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#e8bb1cb809660de802d1d592ba4adb61">StencilOperation</a>&nbsp;</td>
          <td class="paramname"> <em>stencilFailOp</em> = <code>SOP_KEEP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#e8bb1cb809660de802d1d592ba4adb61">StencilOperation</a>&nbsp;</td>
          <td class="paramname"> <em>depthFailOp</em> = <code>SOP_KEEP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#e8bb1cb809660de802d1d592ba4adb61">StencilOperation</a>&nbsp;</td>
          <td class="paramname"> <em>passOp</em> = <code>SOP_KEEP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>twoSidedOperation</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if this system supports hardware accelerated stencil buffer. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Note that the lack of this function doesn't mean you can't do stencilling, but the stencilling operations will be provided in software, which will NOT be fast. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Generally hardware stencils are only supported in 32-bit colour modes, because the stencil buffer shares the memory of the z-buffer, and in most cards the z-buffer has to be the same depth as the colour buffer. This means that in 32-bit mode, 24 bits of the z-buffer are depth and 8 bits are stencil. In 16-bit mode there is no room for a stencil (although some cards support a 15:1 depth:stencil option, this isn't useful for very much) so 8 bits of stencil are provided in software. This can mean that if you use stencilling, your applications may be faster in 32-but colour than in 16-bit, which may seem odd to some people. This method allows you to set all the stencil buffer parameters in one call. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render. The stencil test is:<pre>
		(Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask)</pre> The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Unlike other render states, stencilling is left for the application to turn on and off when it requires. This is because you are likely to want to change parameters between batches of arbitrary objects and control the ordering yourself. In order to batch things this way, you'll want to use OGRE's separate render queue groups (see <a class="el" href="classOgre_1_1RenderQueue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a>) and register a <a class="el" href="classOgre_1_1RenderQueueListener.html" title="Abstract interface which classes must implement if they wish to receive events from...">RenderQueueListener</a> to get notifications between batches. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>There are individual state change methods for each of the parameters set using this method. Note that the default values in this method represent the defaults at system start up too. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>func</em>&nbsp;</td><td>The comparison function applied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refValue</em>&nbsp;</td><td>The reference value used in the comparison </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The bitmask applied to both the stencil value and the reference value before comparison </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stencilFailOp</em>&nbsp;</td><td>The action to perform when the stencil check fails </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depthFailOp</em>&nbsp;</td><td>The action to perform when the stencil check passes, but the depth buffer check still fails </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>passOp</em>&nbsp;</td><td>The action to take when both the stencil and depth check pass. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>twoSidedOperation</em>&nbsp;</td><td>If set to true, then if you render both back and front faces (you'll have to turn off culling) then these parameters will apply for front faces, and the inverse of them will happen for back faces (keep remains the same). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="873dc2bc43f8a842fd08b6c7b9dfaabe"></a><!-- doxytag: member="Ogre::RenderSystem::setVertexDeclaration" ref="873dc2bc43f8a842fd08b6c7b9dfaabe" args="(VertexDeclaration *decl)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setVertexDeclaration           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1VertexDeclaration.html">VertexDeclaration</a> *&nbsp;</td>
          <td class="paramname"> <em>decl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the current vertex declaration, ie the source of vertex data. 
<p>

</div>
</div><p>
<a class="anchor" name="5f72d5fd9f4af2d29096acb1de95f0e7"></a><!-- doxytag: member="Ogre::RenderSystem::setVertexBufferBinding" ref="5f72d5fd9f4af2d29096acb1de95f0e7" args="(VertexBufferBinding *binding)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setVertexBufferBinding           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1VertexBufferBinding.html">VertexBufferBinding</a> *&nbsp;</td>
          <td class="paramname"> <em>binding</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the current vertex buffer binding state. 
<p>

</div>
</div><p>
<a class="anchor" name="a9ab2a6569fe30ab63a4714ec58933b4"></a><!-- doxytag: member="Ogre::RenderSystem::setNormaliseNormals" ref="a9ab2a6569fe30ab63a4714ec58933b4" args="(bool normalise)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setNormaliseNormals           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>normalise</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not normals are to be automatically normalised. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This is useful when, for example, you are scaling SceneNodes such that normals may not be unit-length anymore. Note though that this has an overhead so should not be turn on unless you really need it. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>You should not normally call this direct unless you are rendering world geometry; set it on the <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> because otherwise it will be overridden by material settings. </dd></dl>

</div>
</div><p>
<a class="anchor" name="64961cc3cdc616beb264c51d532c94c1"></a><!-- doxytag: member="Ogre::RenderSystem::_render" ref="64961cc3cdc616beb264c51d532c94c1" args="(const RenderOperation &amp;op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_render           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1RenderOperation.html">RenderOperation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render something to the active viewport. 
<p>
Low-level rendering interface to perform rendering operations. Unlikely to be used directly by client applications, since the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> and various support classes will be responsible for calling this method. Can only be called between _beginScene and _endScene<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>A rendering operation instance, which contains details of the operation to be performed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1ea7609b7337a8b184c4348b09d5c46a"></a><!-- doxytag: member="Ogre::RenderSystem::getCapabilities" ref="1ea7609b7337a8b184c4348b09d5c46a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a>* Ogre::RenderSystem::getCapabilities           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the capabilities of the render system. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l00965">965</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d9dbbbf4ae4dc539ebb31d99c7e6c724"></a><!-- doxytag: member="Ogre::RenderSystem::getDriverVersion" ref="d9dbbbf4ae4dc539ebb31d99c7e6c724" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structOgre_1_1DriverVersion.html">DriverVersion</a>&amp; Ogre::RenderSystem::getDriverVersion           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the driver version. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l00970">970</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e8144a770f5bbe9390928abf24d37b16"></a><!-- doxytag: member="Ogre::RenderSystem::bindGpuProgram" ref="e8144a770f5bbe9390928abf24d37b16" args="(GpuProgram *prg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::bindGpuProgram           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1GpuProgram.html">GpuProgram</a> *&nbsp;</td>
          <td class="paramname"> <em>prg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Binds a given <a class="el" href="classOgre_1_1GpuProgram.html" title="Defines a program which runs on the GPU such as a vertex or fragment program.">GpuProgram</a> (but not the parameters). 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Only one <a class="el" href="classOgre_1_1GpuProgram.html" title="Defines a program which runs on the GPU such as a vertex or fragment program.">GpuProgram</a> of each type can be bound at once, binding another one will simply replace the existing one. </dd></dl>

</div>
</div><p>
<a class="anchor" name="09ad156f8a00e59fd6528a8f0204900c"></a><!-- doxytag: member="Ogre::RenderSystem::bindGpuProgramParameters" ref="09ad156f8a00e59fd6528a8f0204900c" args="(GpuProgramType gptype, GpuProgramParametersSharedPtr params)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::bindGpuProgramParameters           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#d08e89fa63e81d061ea9e2f37664976e">GpuProgramType</a>&nbsp;</td>
          <td class="paramname"> <em>gptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a>&nbsp;</td>
          <td class="paramname"> <em>params</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind Gpu program parameters. 
<p>

</div>
</div><p>
<a class="anchor" name="e1f7904fe5f6a1d39fe8a0621dab7509"></a><!-- doxytag: member="Ogre::RenderSystem::bindGpuProgramPassIterationParameters" ref="e1f7904fe5f6a1d39fe8a0621dab7509" args="(GpuProgramType gptype)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::bindGpuProgramPassIterationParameters           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#d08e89fa63e81d061ea9e2f37664976e">GpuProgramType</a>&nbsp;</td>
          <td class="paramname"> <em>gptype</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only binds Gpu program parameters used for passes that have more than one iteration rendering. 
<p>

</div>
</div><p>
<a class="anchor" name="045731ce43fe553744e69664d5d648b3"></a><!-- doxytag: member="Ogre::RenderSystem::unbindGpuProgram" ref="045731ce43fe553744e69664d5d648b3" args="(GpuProgramType gptype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::unbindGpuProgram           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#d08e89fa63e81d061ea9e2f37664976e">GpuProgramType</a>&nbsp;</td>
          <td class="paramname"> <em>gptype</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unbinds GpuPrograms of a given GpuProgramType. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This returns the pipeline to fixed-function processing for this type. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ac003196b5b51384f714924a0041081"></a><!-- doxytag: member="Ogre::RenderSystem::isGpuProgramBound" ref="1ac003196b5b51384f714924a0041081" args="(GpuProgramType gptype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::RenderSystem::isGpuProgramBound           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#d08e89fa63e81d061ea9e2f37664976e">GpuProgramType</a>&nbsp;</td>
          <td class="paramname"> <em>gptype</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether or not a Gpu program of the given type is currently bound. 
<p>

</div>
</div><p>
<a class="anchor" name="23cc0a7d87b77ec3d0a34e92335bec1a"></a><!-- doxytag: member="Ogre::RenderSystem::setClipPlanes" ref="23cc0a7d87b77ec3d0a34e92335bec1a" args="(const PlaneList &amp;clipPlanes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setClipPlanes           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>clipPlanes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the user clipping region. 
<p>

</div>
</div><p>
<a class="anchor" name="be0fbe6b4972baf14137235fe3f6c499"></a><!-- doxytag: member="Ogre::RenderSystem::addClipPlane" ref="be0fbe6b4972baf14137235fe3f6c499" args="(const Plane &amp;p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::addClipPlane           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a user clipping plane. 
<p>

</div>
</div><p>
<a class="anchor" name="2eb75175291761881bdc0d73ec379089"></a><!-- doxytag: member="Ogre::RenderSystem::addClipPlane" ref="2eb75175291761881bdc0d73ec379089" args="(Real A, Real B, Real C, Real D)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::addClipPlane           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>D</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a user clipping plane. 
<p>

</div>
</div><p>
<a class="anchor" name="46a9b1385638112a80bf22fa1a5bf531"></a><!-- doxytag: member="Ogre::RenderSystem::resetClipPlanes" ref="46a9b1385638112a80bf22fa1a5bf531" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::resetClipPlanes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the user clipping region. 
<p>

</div>
</div><p>
<a class="anchor" name="83ca87a7c74baff1db1a9ff6ec61ba54"></a><!-- doxytag: member="Ogre::RenderSystem::_initRenderTargets" ref="83ca87a7c74baff1db1a9ff6ec61ba54" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_initRenderTargets           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Utility method for initialising all render targets attached to this rendering system. 
<p>

</div>
</div><p>
<a class="anchor" name="ecceb6f1a7d3113de8676d20e39260dc"></a><!-- doxytag: member="Ogre::RenderSystem::_notifyCameraRemoved" ref="ecceb6f1a7d3113de8676d20e39260dc" args="(const Camera *cam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_notifyCameraRemoved           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Utility method to notify all render targets that a camera has been removed, in case they were referring to it as their viewer. 
<p>

</div>
</div><p>
<a class="anchor" name="8ef6bbe5a63769cfe73319ac418624a8"></a><!-- doxytag: member="Ogre::RenderSystem::_updateAllRenderTargets" ref="8ef6bbe5a63769cfe73319ac418624a8" args="(bool swapBuffers=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_updateAllRenderTargets           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>swapBuffers</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for updating all render targets attached to this rendering system. 
<p>

</div>
</div><p>
<a class="anchor" name="e8365c3a108964861ca4af053e84901f"></a><!-- doxytag: member="Ogre::RenderSystem::_swapAllRenderTargetBuffers" ref="e8365c3a108964861ca4af053e84901f" args="(bool waitForVsync=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::_swapAllRenderTargetBuffers           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>waitForVsync</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for swapping all the buffers on all render targets, if _updateAllRenderTargets was called with a 'false' parameter. 
<p>

</div>
</div><p>
<a class="anchor" name="0a0b42f82a637acb3df7fba70c1291aa"></a><!-- doxytag: member="Ogre::RenderSystem::setInvertVertexWinding" ref="0a0b42f82a637acb3df7fba70c1291aa" args="(bool invert)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setInvertVertexWinding           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>invert</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not vertex windings set should be inverted; this can be important for rendering reflections. 
<p>

</div>
</div><p>
<a class="anchor" name="e0cf822105945ccbdc87a071c220be57"></a><!-- doxytag: member="Ogre::RenderSystem::setScissorTest" ref="e0cf822105945ccbdc87a071c220be57" args="(bool enabled, size_t left=0, size_t top=0, size_t right=800, size_t bottom=600)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setScissorTest           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>top</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>right</em> = <code>800</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bottom</em> = <code>600</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the 'scissor region' ie the region of the target in which rendering can take place. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method allows you to 'mask off' rendering in all but a given rectangular area as identified by the parameters to this method. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not all systems support this method. Check the <a class="el" href="classOgre_1_1RenderSystemCapabilities.html" title="singleton class for storing the capabilities of the graphics card.">RenderSystemCapabilities</a> for the RSC_SCISSOR_TEST capability to see if it is supported. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enabled</em>&nbsp;</td><td>True to enable the scissor test, false to disable it. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left,top,right,bottom</em>&nbsp;</td><td>The location of the corners of the rectangle, expressed in <em>pixels</em>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ae6b073aaf42ecea55bb972fd5166f42"></a><!-- doxytag: member="Ogre::RenderSystem::clearFrameBuffer" ref="ae6b073aaf42ecea55bb972fd5166f42" args="(unsigned int buffers, const ColourValue &amp;colour=ColourValue::Black, Real depth=1.0f, unsigned short stencil=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::clearFrameBuffer           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colour</em> = <code><a class="el" href="classOgre_1_1ColourValue.html#7f8a06f2a9dd645417c36b560f496c1a">ColourValue::Black</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>depth</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>stencil</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears one or more frame buffers on the active render target. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colour</em>&nbsp;</td><td>The colour to clear the colour buffer with, if enabled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>The value to initialise the depth buffer with, if enabled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stencil</em>&nbsp;</td><td>The value to initialise the stencil buffer with, if enabled. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6d706602114e1e4835890cfa4aa6eb2f"></a><!-- doxytag: member="Ogre::RenderSystem::getHorizontalTexelOffset" ref="6d706602114e1e4835890cfa4aa6eb2f" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::RenderSystem::getHorizontalTexelOffset           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the horizontal texel offset value required for mapping texel origins to pixel origins in this rendersystem. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Since rendersystems sometimes disagree on the origin of a texel, mapping from texels to pixels can sometimes be problematic to implement generically. This method allows you to retrieve the offset required to map the origin of a texel to the origin of a pixel in the horizontal direction. </dd></dl>

</div>
</div><p>
<a class="anchor" name="18238c4b41bfaab6ca5f5e19e20d0d55"></a><!-- doxytag: member="Ogre::RenderSystem::getVerticalTexelOffset" ref="18238c4b41bfaab6ca5f5e19e20d0d55" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::RenderSystem::getVerticalTexelOffset           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the vertical texel offset value required for mapping texel origins to pixel origins in this rendersystem. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Since rendersystems sometimes disagree on the origin of a texel, mapping from texels to pixels can sometimes be problematic to implement generically. This method allows you to retrieve the offset required to map the origin of a texel to the origin of a pixel in the vertical direction. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ab53272b5edee4565c05caa605061d3"></a><!-- doxytag: member="Ogre::RenderSystem::getMinimumDepthInputValue" ref="5ab53272b5edee4565c05caa605061d3" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::RenderSystem::getMinimumDepthInputValue           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the minimum (closest) depth value to be used when rendering using identity transforms. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>When using identity transforms you can manually set the depth of a vertex; however the input values required differ per rendersystem. This method lets you retrieve the correct value. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Renderable.html#55df8c0a5347d589ee6ef7beaa38806e" title="Returns whether or not to use an &#39;identity&#39; view.">Renderable::getUseIdentityView</a>, <a class="el" href="classOgre_1_1Renderable.html#2a8f061a5f322e0dae2fd6946fc2966f" title="Returns whether or not to use an &#39;identity&#39; projection.">Renderable::getUseIdentityProjection</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="19ea5b0880338661d1162987a22ab827"></a><!-- doxytag: member="Ogre::RenderSystem::getMaximumDepthInputValue" ref="19ea5b0880338661d1162987a22ab827" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::RenderSystem::getMaximumDepthInputValue           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the maximum (farthest) depth value to be used when rendering using identity transforms. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>When using identity transforms you can manually set the depth of a vertex; however the input values required differ per rendersystem. This method lets you retrieve the correct value. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Renderable.html#55df8c0a5347d589ee6ef7beaa38806e" title="Returns whether or not to use an &#39;identity&#39; view.">Renderable::getUseIdentityView</a>, <a class="el" href="classOgre_1_1Renderable.html#2a8f061a5f322e0dae2fd6946fc2966f" title="Returns whether or not to use an &#39;identity&#39; projection.">Renderable::getUseIdentityProjection</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="207d38c53699525e2e49ee167f9c8eb5"></a><!-- doxytag: member="Ogre::RenderSystem::setCurrentPassIterationCount" ref="207d38c53699525e2e49ee167f9c8eb5" args="(const size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setCurrentPassIterationCount           </td>
          <td>(</td>
          <td class="paramtype">const size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set the current multi pass count value. 
<p>
This must be set prior to calling <a class="el" href="classOgre_1_1RenderSystem.html#64961cc3cdc616beb264c51d532c94c1" title="Render something to the active viewport.">_render()</a> if multiple renderings of the same pass state are required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of times to render the current state. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01091">1091</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="927af19c2746aa2dd37018434bfc09f4"></a><!-- doxytag: member="Ogre::RenderSystem::setDeriveDepthBias" ref="927af19c2746aa2dd37018434bfc09f4" args="(bool derive, float baseValue=0.0f, float multiplier=0.0f, float slopeScale=0.0f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setDeriveDepthBias           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>derive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>baseValue</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>multiplier</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>slopeScale</em> = <code>0.0f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell the render system whether to derive a depth bias on its own based on the values passed to it in setCurrentPassIterationCount. 
<p>
The depth bias set will be baseValue + iteration * multiplier <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>derive</em>&nbsp;</td><td>True to tell the RS to derive this automatically </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseValue</em>&nbsp;</td><td>The base value to which the multiplier should be added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multiplier</em>&nbsp;</td><td>The amount of depth bias to apply per iteration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slopeScale</em>&nbsp;</td><td>The constant slope scale bias for completeness </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01102">1102</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="da5d01c8a4eb8e64140d92fce245800c"></a><!-- doxytag: member="Ogre::RenderSystem::addListener" ref="da5d01c8a4eb8e64140d92fce245800c" args="(Listener *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::addListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderSystem_1_1Listener.html">Listener</a> *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a listener to the custom events that this render system can raise. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Some render systems have quite specific, internally generated events that the application may wish to be notified of. Many applications don't have to worry about these events, and can just trust OGRE to handle them, but if you want to know, you can add a listener here. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Events are raised very generically by string name. Perhaps the most common example of a render system specific event is the loss and restoration of a device in DirectX; which OGRE deals with, but you may wish to know when it happens. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1RenderSystem.html#8f3b7402316e7162fb5778235fc6e2f2" title="Gets a list of the rendersystem specific events that this rendersystem can raise...">RenderSystem::getRenderSystemEvents</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7d9e3b4369f98e46dbea4cb4b9390f9d"></a><!-- doxytag: member="Ogre::RenderSystem::removeListener" ref="7d9e3b4369f98e46dbea4cb4b9390f9d" args="(Listener *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::removeListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderSystem_1_1Listener.html">Listener</a> *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a listener to the custom events that this render system can raise. 
<p>

</div>
</div><p>
<a class="anchor" name="8f3b7402316e7162fb5778235fc6e2f2"></a><!-- doxytag: member="Ogre::RenderSystem::getRenderSystemEvents" ref="8f3b7402316e7162fb5778235fc6e2f2" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceOgre.html#783e5227595f351519627abfb740ec85">StringVector</a>&amp; Ogre::RenderSystem::getRenderSystemEvents           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a list of the rendersystem specific events that this rendersystem can raise. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1RenderSystem.html#da5d01c8a4eb8e64140d92fce245800c" title="Adds a listener to the custom events that this render system can raise.">RenderSystem::addListener</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01151">1151</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="77766da49c29112c390fde51069f543a"></a><!-- doxytag: member="Ogre::RenderSystem::preExtraThreadsStarted" ref="77766da49c29112c390fde51069f543a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::preExtraThreadsStarted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tell the rendersystem to perform any prep tasks it needs to directly before other threads which might access the rendering API are registered. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Call this from your main thread before starting your other threads (which themselves should call <a class="el" href="classOgre_1_1RenderSystem.html#ae6874b97f0b5cb00e0bf32e10652540" title="Register the an additional thread which may make calls to rendersystem-related objects...">registerThread()</a>). Note that if you start your own threads, there is a specific startup sequence which must be respected and requires synchronisation between the threads: <ol>
<li>
[Main thread]Call preExtraThreadsStarted </li>
<li>
[Main thread]Start other thread, wait </li>
<li>
[Other thread]Call registerThread, notify main thread &amp; continue </li>
<li>
[Main thread]Wake up &amp; call postExtraThreadsStarted </li>
</ol>
Once this init sequence is completed the threads are independent but this startup sequence must be respected. </dd></dl>

</div>
</div><p>
<a class="anchor" name="460fb2b67acdea8e3a72933e0348a82d"></a><!-- doxytag: member="Ogre::RenderSystem::postExtraThreadsStarted" ref="460fb2b67acdea8e3a72933e0348a82d" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::postExtraThreadsStarted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ae6874b97f0b5cb00e0bf32e10652540"></a><!-- doxytag: member="Ogre::RenderSystem::registerThread" ref="ae6874b97f0b5cb00e0bf32e10652540" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::registerThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register the an additional thread which may make calls to rendersystem-related objects. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method should only be called by additional threads during their initialisation. If they intend to use hardware rendering system resources they should call this method before doing anything related to the render system. Some rendering APIs require a per-thread setup and this method will sort that out. It is also necessary to call unregisterThread before the thread shuts down. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This method takes no parameters - it must be called from the thread being registered and that context is enough. </dd></dl>

</div>
</div><p>
<a class="anchor" name="64138779fab3c6b157f2de40c3831e10"></a><!-- doxytag: member="Ogre::RenderSystem::unregisterThread" ref="64138779fab3c6b157f2de40c3831e10" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::unregisterThread           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister an additional thread which may make calls to rendersystem-related objects. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1RenderSystem.html#ae6874b97f0b5cb00e0bf32e10652540" title="Register the an additional thread which may make calls to rendersystem-related objects...">RenderSystem::registerThread</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b7b29f3b542c7cbaeb5da0c1269a388"></a><!-- doxytag: member="Ogre::RenderSystem::updatePassIterationRenderState" ref="8b7b29f3b542c7cbaeb5da0c1269a388" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RenderSystem::updatePassIterationRenderState           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
updates pass iteration rendering state including bound gpu program parameter pass iteration auto constant entry 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if more iterations are required </dd></dl>

</div>
</div><p>
<a class="anchor" name="739194f14f07f7860f26af9a07fa1ce2"></a><!-- doxytag: member="Ogre::RenderSystem::fireEvent" ref="739194f14f07f7860f26af9a07fa1ce2" args="(const String &amp;name, const NameValuePairList *params=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::fireEvent           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#0537f38d7a77fcbe9f600f6ed8a926d6">NameValuePairList</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for firing a rendersystem event. 
<p>

</div>
</div><p>
<a class="anchor" name="a5aa48b693e91657888fbb66d069b6f0"></a><!-- doxytag: member="Ogre::RenderSystem::setClipPlanesImpl" ref="a5aa48b693e91657888fbb66d069b6f0" args="(const PlaneList &amp;clipPlanes)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::setClipPlanesImpl           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>clipPlanes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method used to set the underlying clip planes when needed. 
<p>

</div>
</div><p>
<a class="anchor" name="9e90c93fe313f39ee979bdf1179b4538"></a><!-- doxytag: member="Ogre::RenderSystem::initialiseFromRenderSystemCapabilities" ref="9e90c93fe313f39ee979bdf1179b4538" args="(RenderSystemCapabilities *caps, RenderTarget *primary)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::RenderSystem::initialiseFromRenderSystemCapabilities           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a> *&nbsp;</td>
          <td class="paramname"> <em>caps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a> *&nbsp;</td>
          <td class="paramname"> <em>primary</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the render system from the capabilities. 
<p>

</div>
</div><p>
<a class="anchor" name="421b197ca3a38da17e2eb1531a645fa2"></a><!-- doxytag: member="Ogre::RenderSystem::operator new" ref="421b197ca3a38da17e2eb1531a645fa2" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
operator new, with debug line info 
<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00062">62</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4bdf968b7b9af8a5239a27da73d5711"></a><!-- doxytag: member="Ogre::RenderSystem::operator new" ref="c4bdf968b7b9af8a5239a27da73d5711" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00067">67</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b78a921e54419be677839cdf15d1f0b8"></a><!-- doxytag: member="Ogre::RenderSystem::operator new" ref="b78a921e54419be677839cdf15d1f0b8" args="(size_t sz, void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
placement operator new 
<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00073">73</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4be37baef81876985aa1071ad5acc6dd"></a><!-- doxytag: member="Ogre::RenderSystem::operator new[]" ref="4be37baef81876985aa1071ad5acc6dd" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
array operator new, with debug line info 
<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00079">79</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="fa2943846ba6a2b5824a12857139cf5e"></a><!-- doxytag: member="Ogre::RenderSystem::operator new[]" ref="fa2943846ba6a2b5824a12857139cf5e" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00084">84</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8357fe4fb4849772b94baa4bf47c7ded"></a><!-- doxytag: member="Ogre::RenderSystem::operator delete" ref="8357fe4fb4849772b94baa4bf47c7ded" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00089">89</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c727e879a260c37b00ce5505fe8e144"></a><!-- doxytag: member="Ogre::RenderSystem::operator delete" ref="1c727e879a260c37b00ce5505fe8e144" args="(void *ptr, void *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00095">95</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cb46d4b0a597156d9ba5abc39d127792"></a><!-- doxytag: member="Ogre::RenderSystem::operator delete" ref="cb46d4b0a597156d9ba5abc39d127792" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00101">101</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="93e6a86dde5483c053ca0f2a85bbfd6c"></a><!-- doxytag: member="Ogre::RenderSystem::operator delete[]" ref="93e6a86dde5483c053ca0f2a85bbfd6c" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[]           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00106">106</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="595ea4c05da8aa987d3800e65d23355d"></a><!-- doxytag: member="Ogre::RenderSystem::operator delete[]" ref="595ea4c05da8aa987d3800e65d23355d" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[]           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00112">112</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="5ea599be4da15690178a9aca2261e992"></a><!-- doxytag: member="Ogre::RenderSystem::mRenderTargets" ref="5ea599be4da15690178a9aca2261e992" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#2551e2d3573c437f3beccf7d3ac7a45e">RenderTargetMap</a> <a class="el" href="classOgre_1_1RenderSystem.html#5ea599be4da15690178a9aca2261e992">Ogre::RenderSystem::mRenderTargets</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The render targets. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01199">1199</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="69c3a5daa75ce78fd56226941f1c8126"></a><!-- doxytag: member="Ogre::RenderSystem::mPrioritisedRenderTargets" ref="69c3a5daa75ce78fd56226941f1c8126" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#eacbf68563f1c1e5660c4399d398608c">RenderTargetPriorityMap</a> <a class="el" href="classOgre_1_1RenderSystem.html#69c3a5daa75ce78fd56226941f1c8126">Ogre::RenderSystem::mPrioritisedRenderTargets</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The render targets, ordered by priority. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01201">1201</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="398254faea8f9fe6454abb38eee5b3f4"></a><!-- doxytag: member="Ogre::RenderSystem::mActiveRenderTarget" ref="398254faea8f9fe6454abb38eee5b3f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderTarget.html">RenderTarget</a>* <a class="el" href="classOgre_1_1RenderSystem.html#398254faea8f9fe6454abb38eee5b3f4">Ogre::RenderSystem::mActiveRenderTarget</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The Active render target. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01203">1203</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e98e8807b322bccf0eb160afdb54537e"></a><!-- doxytag: member="Ogre::RenderSystem::mActiveVertexGpuProgramParameters" ref="e98e8807b322bccf0eb160afdb54537e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a> <a class="el" href="classOgre_1_1RenderSystem.html#e98e8807b322bccf0eb160afdb54537e">Ogre::RenderSystem::mActiveVertexGpuProgramParameters</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The Active GPU programs and gpu program parameters. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01205">1205</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2d602052ff01a8fd78455916c57a4cef"></a><!-- doxytag: member="Ogre::RenderSystem::mActiveGeometryGpuProgramParameters" ref="2d602052ff01a8fd78455916c57a4cef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a> <a class="el" href="classOgre_1_1RenderSystem.html#2d602052ff01a8fd78455916c57a4cef">Ogre::RenderSystem::mActiveGeometryGpuProgramParameters</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01206">1206</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5b9972dd9bb47c45732ad1c82c55817d"></a><!-- doxytag: member="Ogre::RenderSystem::mActiveFragmentGpuProgramParameters" ref="5b9972dd9bb47c45732ad1c82c55817d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a> <a class="el" href="classOgre_1_1RenderSystem.html#5b9972dd9bb47c45732ad1c82c55817d">Ogre::RenderSystem::mActiveFragmentGpuProgramParameters</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01207">1207</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="80f14e152184bddc68f8ae05bcefb3be"></a><!-- doxytag: member="Ogre::RenderSystem::mTextureManager" ref="80f14e152184bddc68f8ae05bcefb3be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1TextureManager.html">TextureManager</a>* <a class="el" href="classOgre_1_1RenderSystem.html#80f14e152184bddc68f8ae05bcefb3be">Ogre::RenderSystem::mTextureManager</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01213">1213</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="122f2e8cbddd313582f05677f5a26b1c"></a><!-- doxytag: member="Ogre::RenderSystem::mActiveViewport" ref="122f2e8cbddd313582f05677f5a26b1c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a>* <a class="el" href="classOgre_1_1RenderSystem.html#122f2e8cbddd313582f05677f5a26b1c">Ogre::RenderSystem::mActiveViewport</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01216">1216</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="60ce74b29c3e1c9e11041029117a85ad"></a><!-- doxytag: member="Ogre::RenderSystem::mCullingMode" ref="60ce74b29c3e1c9e11041029117a85ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a> <a class="el" href="classOgre_1_1RenderSystem.html#60ce74b29c3e1c9e11041029117a85ad">Ogre::RenderSystem::mCullingMode</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01218">1218</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c0df5de57fa3480f74c98c65a7211a30"></a><!-- doxytag: member="Ogre::RenderSystem::mVSync" ref="c0df5de57fa3480f74c98c65a7211a30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#c0df5de57fa3480f74c98c65a7211a30">Ogre::RenderSystem::mVSync</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01220">1220</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7c4ad7937f023a43ee43473750d2bfe9"></a><!-- doxytag: member="Ogre::RenderSystem::mWBuffer" ref="7c4ad7937f023a43ee43473750d2bfe9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#7c4ad7937f023a43ee43473750d2bfe9">Ogre::RenderSystem::mWBuffer</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01221">1221</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="039fe39c5374812e776c677404f00898"></a><!-- doxytag: member="Ogre::RenderSystem::mBatchCount" ref="039fe39c5374812e776c677404f00898" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classOgre_1_1RenderSystem.html#039fe39c5374812e776c677404f00898">Ogre::RenderSystem::mBatchCount</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01223">1223</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a735bd71b568209de09adfa86b737737"></a><!-- doxytag: member="Ogre::RenderSystem::mFaceCount" ref="a735bd71b568209de09adfa86b737737" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classOgre_1_1RenderSystem.html#a735bd71b568209de09adfa86b737737">Ogre::RenderSystem::mFaceCount</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01224">1224</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0716f3fd1349f7c4399d805d03e4c394"></a><!-- doxytag: member="Ogre::RenderSystem::mVertexCount" ref="0716f3fd1349f7c4399d805d03e4c394" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classOgre_1_1RenderSystem.html#0716f3fd1349f7c4399d805d03e4c394">Ogre::RenderSystem::mVertexCount</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01225">1225</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a40237e355676bb7024fccd8699eee96"></a><!-- doxytag: member="Ogre::RenderSystem::mManualBlendColours" ref="a40237e355676bb7024fccd8699eee96" args="[OGRE_MAX_TEXTURE_LAYERS][2]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> <a class="el" href="classOgre_1_1RenderSystem.html#a40237e355676bb7024fccd8699eee96">Ogre::RenderSystem::mManualBlendColours</a>[OGRE_MAX_TEXTURE_LAYERS][2]<code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saved manual colour blends. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01228">1228</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="df3d0f2e777d97e2032ef01cb1b3ecee"></a><!-- doxytag: member="Ogre::RenderSystem::mInvertVertexWinding" ref="df3d0f2e777d97e2032ef01cb1b3ecee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#df3d0f2e777d97e2032ef01cb1b3ecee">Ogre::RenderSystem::mInvertVertexWinding</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01230">1230</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9a071dab9e9b40bfde6d2e85cb363274"></a><!-- doxytag: member="Ogre::RenderSystem::mDisabledTexUnitsFrom" ref="9a071dab9e9b40bfde6d2e85cb363274" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classOgre_1_1RenderSystem.html#9a071dab9e9b40bfde6d2e85cb363274">Ogre::RenderSystem::mDisabledTexUnitsFrom</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> units from this upwards are disabled. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01233">1233</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="179ea5dd6f5b8f1430ebc10dd582fdb8"></a><!-- doxytag: member="Ogre::RenderSystem::mCurrentPassIterationCount" ref="179ea5dd6f5b8f1430ebc10dd582fdb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classOgre_1_1RenderSystem.html#179ea5dd6f5b8f1430ebc10dd582fdb8">Ogre::RenderSystem::mCurrentPassIterationCount</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
number of times to render the current state 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01236">1236</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="633705eb827ce4ad1a0d65761d31335c"></a><!-- doxytag: member="Ogre::RenderSystem::mCurrentPassIterationNum" ref="633705eb827ce4ad1a0d65761d31335c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classOgre_1_1RenderSystem.html#633705eb827ce4ad1a0d65761d31335c">Ogre::RenderSystem::mCurrentPassIterationNum</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01237">1237</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d3c918fb9e33cd75b9a802d48acc800d"></a><!-- doxytag: member="Ogre::RenderSystem::mDerivedDepthBias" ref="d3c918fb9e33cd75b9a802d48acc800d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#d3c918fb9e33cd75b9a802d48acc800d">Ogre::RenderSystem::mDerivedDepthBias</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether to update the depth bias per render call. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01239">1239</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b852c2a4d985484527f4a701dad60981"></a><!-- doxytag: member="Ogre::RenderSystem::mDerivedDepthBiasBase" ref="b852c2a4d985484527f4a701dad60981" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classOgre_1_1RenderSystem.html#b852c2a4d985484527f4a701dad60981">Ogre::RenderSystem::mDerivedDepthBiasBase</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01240">1240</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="55404396ef70888e6d7bf0e1d4177c8b"></a><!-- doxytag: member="Ogre::RenderSystem::mDerivedDepthBiasMultiplier" ref="55404396ef70888e6d7bf0e1d4177c8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classOgre_1_1RenderSystem.html#55404396ef70888e6d7bf0e1d4177c8b">Ogre::RenderSystem::mDerivedDepthBiasMultiplier</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01241">1241</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="671636ab611261911a21f52d7cc1c97a"></a><!-- doxytag: member="Ogre::RenderSystem::mDerivedDepthBiasSlopeScale" ref="671636ab611261911a21f52d7cc1c97a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classOgre_1_1RenderSystem.html#671636ab611261911a21f52d7cc1c97a">Ogre::RenderSystem::mDerivedDepthBiasSlopeScale</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01242">1242</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b213f4023f49f961377aa52c8c11acc3"></a><!-- doxytag: member="Ogre::RenderSystem::mEventNames" ref="b213f4023f49f961377aa52c8c11acc3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#783e5227595f351519627abfb740ec85">StringVector</a> <a class="el" href="classOgre_1_1RenderSystem.html#b213f4023f49f961377aa52c8c11acc3">Ogre::RenderSystem::mEventNames</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of names of events this rendersystem may raise. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01251">1251</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d0cf554e93303c9305d3446eb2efb411"></a><!-- doxytag: member="Ogre::RenderSystem::mEventListeners" ref="d0cf554e93303c9305d3446eb2efb411" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderSystem.html#a1072468272ad965dbc651aa8fc09031">ListenerList</a> <a class="el" href="classOgre_1_1RenderSystem.html#d0cf554e93303c9305d3446eb2efb411">Ogre::RenderSystem::mEventListeners</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01257">1257</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7bb1437e3f40cda2bb1495b51ba88791"></a><!-- doxytag: member="Ogre::RenderSystem::mHwOcclusionQueries" ref="7bb1437e3f40cda2bb1495b51ba88791" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderSystem.html#b56b367e25b74e95e6ad773a282c494d">HardwareOcclusionQueryList</a> <a class="el" href="classOgre_1_1RenderSystem.html#7bb1437e3f40cda2bb1495b51ba88791">Ogre::RenderSystem::mHwOcclusionQueries</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01260">1260</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="69173bf6d120d39f702c5de9e0815218"></a><!-- doxytag: member="Ogre::RenderSystem::mVertexProgramBound" ref="69173bf6d120d39f702c5de9e0815218" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#69173bf6d120d39f702c5de9e0815218">Ogre::RenderSystem::mVertexProgramBound</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01262">1262</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="989d395609174738d5571fb6892262de"></a><!-- doxytag: member="Ogre::RenderSystem::mGeometryProgramBound" ref="989d395609174738d5571fb6892262de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#989d395609174738d5571fb6892262de">Ogre::RenderSystem::mGeometryProgramBound</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01263">1263</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="79ba9d85873031a65a9548e65e50109d"></a><!-- doxytag: member="Ogre::RenderSystem::mFragmentProgramBound" ref="79ba9d85873031a65a9548e65e50109d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#79ba9d85873031a65a9548e65e50109d">Ogre::RenderSystem::mFragmentProgramBound</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01264">1264</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="07c97ddc40ee60325e0bc21930ac5c79"></a><!-- doxytag: member="Ogre::RenderSystem::mClipPlanes" ref="07c97ddc40ee60325e0bc21930ac5c79" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a> <a class="el" href="classOgre_1_1RenderSystem.html#07c97ddc40ee60325e0bc21930ac5c79">Ogre::RenderSystem::mClipPlanes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01267">1267</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3d14dfbb2f08906b57df424f9cd96bed"></a><!-- doxytag: member="Ogre::RenderSystem::mClipPlanesDirty" ref="3d14dfbb2f08906b57df424f9cd96bed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#3d14dfbb2f08906b57df424f9cd96bed">Ogre::RenderSystem::mClipPlanesDirty</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01269">1269</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a4c73904a4dc7b0c097d21acac1ec52f"></a><!-- doxytag: member="Ogre::RenderSystem::mRealCapabilities" ref="a4c73904a4dc7b0c097d21acac1ec52f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a>* <a class="el" href="classOgre_1_1RenderSystem.html#a4c73904a4dc7b0c097d21acac1ec52f">Ogre::RenderSystem::mRealCapabilities</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to store the capabilities of the graphics card. 
<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01272">1272</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="748f3ed723a45617a5adfd6c8d4decf2"></a><!-- doxytag: member="Ogre::RenderSystem::mCurrentCapabilities" ref="748f3ed723a45617a5adfd6c8d4decf2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderSystemCapabilities.html">RenderSystemCapabilities</a>* <a class="el" href="classOgre_1_1RenderSystem.html#748f3ed723a45617a5adfd6c8d4decf2">Ogre::RenderSystem::mCurrentCapabilities</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01273">1273</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b68aeffbe5cb555e1057c0ac3afcee54"></a><!-- doxytag: member="Ogre::RenderSystem::mUseCustomCapabilities" ref="b68aeffbe5cb555e1057c0ac3afcee54" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#b68aeffbe5cb555e1057c0ac3afcee54">Ogre::RenderSystem::mUseCustomCapabilities</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01274">1274</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2a2b64fcb748ff0bd21231c23ad3fe98"></a><!-- doxytag: member="Ogre::RenderSystem::mDriverVersion" ref="2a2b64fcb748ff0bd21231c23ad3fe98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOgre_1_1DriverVersion.html">DriverVersion</a> <a class="el" href="classOgre_1_1RenderSystem.html#2a2b64fcb748ff0bd21231c23ad3fe98">Ogre::RenderSystem::mDriverVersion</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01283">1283</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7d062673a4505cc47867677fdb83e455"></a><!-- doxytag: member="Ogre::RenderSystem::mTexProjRelative" ref="7d062673a4505cc47867677fdb83e455" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1RenderSystem.html#7d062673a4505cc47867677fdb83e455">Ogre::RenderSystem::mTexProjRelative</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01285">1285</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8b5ae0207f8d1faf47169be4a2ee2714"></a><!-- doxytag: member="Ogre::RenderSystem::mTexProjRelativeOrigin" ref="8b5ae0207f8d1faf47169be4a2ee2714" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1RenderSystem.html#8b5ae0207f8d1faf47169be4a2ee2714">Ogre::RenderSystem::mTexProjRelativeOrigin</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreRenderSystem_8h-source.html#l01286">1286</a> of file <a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="OgreRenderSystem_8h-source.html">OgreRenderSystem.h</a></ul>
<hr>
<p>
Copyright &copy; 2008 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Thu Jan 22 21:26:57 2009
</p>
</body>
</html>
