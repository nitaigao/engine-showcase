<html>
<head>
<title>OGRE: Ogre::SceneManager Class Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespaceOgre.html">Ogre</a>::<a class="el" href="classOgre_1_1SceneManager.html">SceneManager</a></div>
<h1>Ogre::SceneManager Class Reference</h1><!-- doxytag: class="Ogre::SceneManager" --><!-- doxytag: inherits="Ogre::AllocatedObject" -->Manages the organisation and rendering of a 'scene' i.e.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Ogre::SceneManager:</div>
<div class="dynsection">
<p><center><img src="classOgre_1_1SceneManager__inherit__graph.gif" border="0" usemap="#Ogre_1_1SceneManager__inherit__map" alt="Inheritance graph"></center>
<map name="Ogre_1_1SceneManager__inherit__map">
<area shape="rect" href="classOgre_1_1DefaultSceneManager.html" title="Default scene manager." alt="" coords="5,155,200,182"><area shape="rect" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new..." alt="" coords="47,6,159,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classOgre_1_1SceneManager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#51db39cc4fa15b28086a1793d42fc827">IlluminationRenderStage</a> { <a class="el" href="classOgre_1_1SceneManager.html#51db39cc4fa15b28086a1793d42fc8278fd3e7fb8fab382a9d29e6e081ae556a">IRS_NONE</a>, 
<a class="el" href="classOgre_1_1SceneManager.html#51db39cc4fa15b28086a1793d42fc8278f99da7404ae8c16199dde8d34367b1a">IRS_RENDER_TO_TEXTURE</a>, 
<a class="el" href="classOgre_1_1SceneManager.html#51db39cc4fa15b28086a1793d42fc8270e1792a8ff0d3d19f121818e7028e846">IRS_RENDER_RECEIVER_PASS</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes the stage of rendering when performing complex illumination.  <a href="classOgre_1_1SceneManager.html#51db39cc4fa15b28086a1793d42fc827">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6">SpecialCaseRenderQueueMode</a> { <a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c64f5291417680ce7d1715b7aef50869a7">SCRQM_INCLUDE</a>, 
<a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6cc6b7e38cc21cf87a29e17177dc1a0b3">SCRQM_EXCLUDE</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration of the possible modes allowed for processing the special case render queue list.  <a href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b4c2ff4f6c76f7fe0a8eae76f2a84cbf">PrefabType</a> { <a class="el" href="classOgre_1_1SceneManager.html#b4c2ff4f6c76f7fe0a8eae76f2a84cbff0fb654fb98508a564c17d3d5b2feee3">PT_PLANE</a>, 
<a class="el" href="classOgre_1_1SceneManager.html#b4c2ff4f6c76f7fe0a8eae76f2a84cbf25b0181d24b783ab75da2520305d292a">PT_CUBE</a>, 
<a class="el" href="classOgre_1_1SceneManager.html#b4c2ff4f6c76f7fe0a8eae76f2a84cbf0f94148c2cfe190f3ea04374af220eba">PT_SPHERE</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefab shapes available without loading a model.  <a href="classOgre_1_1SceneManager.html#b4c2ff4f6c76f7fe0a8eae76f2a84cbf">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a><br>
&lt; <a class="el" href="classOgre_1_1SceneManager.html#361c61a0f17ac50c8fd49bc0dd3ff622">CameraList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#22fcb8a9ddb7efe79d053a975a685111">CameraIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a><br>
&lt; <a class="el" href="classOgre_1_1SceneManager.html#260738557c9a32aed8d5ca14c28d300f">AnimationList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3a720414f68274bb9c5026911e27135d">AnimationIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a><br>
&lt; <a class="el" href="classOgre_1_1SceneManager.html#317d0ca0b29d739ed54b4422f850b629">MovableObjectMap</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#4249682ae2a69255ed225383d930aec1">MovableObjectIterator</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#09e76a674bc69c610fb49acd3da76cf1">SceneManager</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;instanceName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#09e76a674bc69c610fb49acd3da76cf1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6c8b9108b44339a321bc69b25a0c0a1a">~SceneManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default destructor.  <a href="#6c8b9108b44339a321bc69b25a0c0a1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#92cef591d74630c19c534709dce030f8">getName</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex to protect the scene graph from simultaneous access from multiple threads.  <a href="#92cef591d74630c19c534709dce030f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#46690a40b65fd0e7e89752e1e36be727">getTypeName</a> (void) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the type name of this scene manager.  <a href="#46690a40b65fd0e7e89752e1e36be727"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a camera to be managed by this scene manager.  <a href="#62ca781b4c6d23dc3aab1f3a45d61843"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#4dbe2eeec924f88c30010e9fd4d9da0e">getCamera</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to the named camera.  <a href="#4dbe2eeec924f88c30010e9fd4d9da0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c4af585550a9ed44ead58855419d5f84">hasCamera</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a camera with the given name exists.  <a href="#c4af585550a9ed44ead58855419d5f84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#cac58e45f8b6b6826c81933f02a45046">destroyCamera</a> (<a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a camera from the scene.  <a href="#cac58e45f8b6b6826c81933f02a45046"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#41b9358cdad6fd7113b2a0cad8112f67">destroyCamera</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a camera from the scene.  <a href="#41b9358cdad6fd7113b2a0cad8112f67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9cb93862284e7443b94eaabdef21564a">destroyAllCameras</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes (and destroys) all cameras from the scene.  <a href="#9cb93862284e7443b94eaabdef21564a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b127d52207729591dd51cb12a5b2ed2c">createLight</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a light for use in the scene.  <a href="#b127d52207729591dd51cb12a5b2ed2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f128cc414af001b325d40745b745b79c">getLight</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the named <a class="el" href="classOgre_1_1Light.html" title="Representation of a dynamic light source in the scene.">Light</a> which has previously been added to the scene.  <a href="#f128cc414af001b325d40745b745b79c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#032173d58a1465af8550a394a9c5b870">hasLight</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a light with the given name exists.  <a href="#032173d58a1465af8550a394a9c5b870"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#bd89ebb9c348ed8230ad300ef7501948">getLightClippingPlanes</a> (<a class="el" href="classOgre_1_1Light.html">Light</a> *l)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a set of clipping planes for a given light.  <a href="#bd89ebb9c348ed8230ad300ef7501948"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="structOgre_1_1TRect.html">RealRect</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#384b7ee3a28ba87866c68d689571aa8f">getLightScissorRect</a> (<a class="el" href="classOgre_1_1Light.html">Light</a> *l, const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a scissor rectangle for a given light and camera.  <a href="#384b7ee3a28ba87866c68d689571aa8f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ef6d26cb64e7a1984ebff9b56c45c6e5">destroyLight</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the named light from the scene and destroys it.  <a href="#ef6d26cb64e7a1984ebff9b56c45c6e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#cce173aa89e849bda564f4e6e3be6402">destroyLight</a> (<a class="el" href="classOgre_1_1Light.html">Light</a> *light)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the light from the scene and destroys it based on a pointer.  <a href="#cce173aa89e849bda564f4e6e3be6402"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#723da9119c26f5022e3a2818611e9aa0">destroyAllLights</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and destroys all lights in the scene.  <a href="#723da9119c26f5022e3a2818611e9aa0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ebfa8b61550010c86fc3b605e2cda669">_notifyLightsDirty</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advance method to increase the lights dirty counter due lights changed.  <a href="#ebfa8b61550010c86fc3b605e2cda669"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#4304981347643708ee9a7ba8884e5758">ulong</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#4e9e8558a06d7bf26eadf349731f1cb3">_getLightsDirtyCounter</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advance method to gets the lights dirty counter.  <a href="#4e9e8558a06d7bf26eadf349731f1cb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#62876dcdf7cb0f7923de88e62cf077ac">_getLightsAffectingFrustum</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of lights which could be affecting the frustum.  <a href="#62876dcdf7cb0f7923de88e62cf077ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#028809d14d6efc7b1cf7d678d3e78605">_populateLightList</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;position, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> radius, <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> &amp;destList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Populate a light list with an ordered set of the lights which are closest to the position specified.  <a href="#028809d14d6efc7b1cf7d678d3e78605"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b31f9c018b801240c238c7a048439150">createSceneNode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an instance of a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>.  <a href="#b31f9c018b801240c238c7a048439150"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#73c42645ea3b064ca6e0822a8f702cd4">createSceneNode</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an instance of a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> with a given name.  <a href="#73c42645ea3b064ca6e0822a8f702cd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#813346e505716ae5d24f714cfc4a5069">destroySceneNode</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> with a given name.  <a href="#813346e505716ae5d24f714cfc4a5069"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a613e5ffb08b95a90644a61ac10c9b5c">destroySceneNode</a> (<a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *sn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>.  <a href="#a613e5ffb08b95a90644a61ac10c9b5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1ef8edf722bd8436ad414967bc2e8c51">getRootSceneNode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> at the root of the scene hierarchy.  <a href="#1ef8edf722bd8436ad414967bc2e8c51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8c3389aea8f436037850ddc64f6d1d7d">getSceneNode</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a named <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> from the scene graph.  <a href="#8c3389aea8f436037850ddc64f6d1d7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6389657d1838dcc93adc8b7e473e4c0a">hasSceneNode</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a scene node with the given name exists.  <a href="#6389657d1838dcc93adc8b7e473e4c0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Entity.html">Entity</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0aa3c748f97b760919741043348ef1d2">createEntity</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;entityName, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;meshName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> (instance of a discrete mesh).  <a href="#0aa3c748f97b760919741043348ef1d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Entity.html">Entity</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9d9c135f1e3fe85db6e1976f1df3fb35">createEntity</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;entityName, <a class="el" href="classOgre_1_1SceneManager.html#b4c2ff4f6c76f7fe0a8eae76f2a84cbf">PrefabType</a> ptype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> (instance of a discrete mesh) from a range of prefab shapes.  <a href="#9d9c135f1e3fe85db6e1976f1df3fb35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Entity.html">Entity</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0d7e8374bd4774284ec6adfbd286ddbc">getEntity</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to the named <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a>.  <a href="#0d7e8374bd4774284ec6adfbd286ddbc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1e6c904789a2393264e278c05e9c5395">hasEntity</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether an entity with the given name exists.  <a href="#1e6c904789a2393264e278c05e9c5395"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#aec976bb28961a149c71a5eba62f40e4">destroyEntity</a> (<a class="el" href="classOgre_1_1Entity.html">Entity</a> *ent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys an <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#aec976bb28961a149c71a5eba62f40e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3e19d4a7d848a745a59e63fca36fa79c">destroyEntity</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys an <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> by name.  <a href="#3e19d4a7d848a745a59e63fca36fa79c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1a77be68ccbfc90e2e1aed04340db4dc">destroyAllEntities</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys all Entities.  <a href="#1a77be68ccbfc90e2e1aed04340db4dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1ManualObject.html">ManualObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#680ab7ccb241680100bfeea73681cce6">createManualObject</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classOgre_1_1ManualObject.html" title="Class providing a much simplified interface to generating manual objects with custom...">ManualObject</a>, an object which you populate with geometry manually through a GL immediate-mode style interface.  <a href="#680ab7ccb241680100bfeea73681cce6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1ManualObject.html">ManualObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3c5eb0c8dd2cedf713d7309d74daf83a">getManualObject</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to the named <a class="el" href="classOgre_1_1ManualObject.html" title="Class providing a much simplified interface to generating manual objects with custom...">ManualObject</a>.  <a href="#3c5eb0c8dd2cedf713d7309d74daf83a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2f6e3800eacb8a5bb39fd5c7e94e2c82">hasManualObject</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a manual object with the given name exists.  <a href="#2f6e3800eacb8a5bb39fd5c7e94e2c82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#75d15c3ac882f78f0001d9d007f403be">destroyManualObject</a> (<a class="el" href="classOgre_1_1ManualObject.html">ManualObject</a> *obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="classOgre_1_1ManualObject.html" title="Class providing a much simplified interface to generating manual objects with custom...">ManualObject</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#75d15c3ac882f78f0001d9d007f403be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d42dfd20473e780251db4e939d7668d0">destroyManualObject</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="classOgre_1_1ManualObject.html" title="Class providing a much simplified interface to generating manual objects with custom...">ManualObject</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#d42dfd20473e780251db4e939d7668d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b3e151b6d94feb6648b8c817ba485238">destroyAllManualObjects</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys all ManualObjects from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#b3e151b6d94feb6648b8c817ba485238"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1BillboardChain.html">BillboardChain</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d0380187a8c572e303c93a64b3355062">createBillboardChain</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a>, an object which you can use to render a linked chain of billboards.  <a href="#d0380187a8c572e303c93a64b3355062"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1BillboardChain.html">BillboardChain</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0667cd1101c4d3e56302b8f82132986b">getBillboardChain</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to the named <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a>.  <a href="#0667cd1101c4d3e56302b8f82132986b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#496f747b6482bc8170495815859c921e">hasBillboardChain</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a billboard chain with the given name exists.  <a href="#496f747b6482bc8170495815859c921e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#98bc20d44752f40fd588f0ba91e4a904">destroyBillboardChain</a> (<a class="el" href="classOgre_1_1BillboardChain.html">BillboardChain</a> *obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#98bc20d44752f40fd588f0ba91e4a904"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#149fafd649d4b9ebb34fa7467314640f">destroyBillboardChain</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#149fafd649d4b9ebb34fa7467314640f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2c01b8c2d82759fb875089c93df491a4">destroyAllBillboardChains</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys all BillboardChains from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#2c01b8c2d82759fb875089c93df491a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1RibbonTrail.html">RibbonTrail</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c4edb21cec1bb77f7a003c506f344652">createRibbonTrail</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classOgre_1_1RibbonTrail.html" title="Subclass of BillboardChain which automatically leaves a trail behind one or more...">RibbonTrail</a>, an object which you can use to render a linked chain of billboards which follows one or more nodes.  <a href="#c4edb21cec1bb77f7a003c506f344652"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1RibbonTrail.html">RibbonTrail</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#fe38a813501eb293c9695c2db68c59b5">getRibbonTrail</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to the named <a class="el" href="classOgre_1_1RibbonTrail.html" title="Subclass of BillboardChain which automatically leaves a trail behind one or more...">RibbonTrail</a>.  <a href="#fe38a813501eb293c9695c2db68c59b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d0d074b988d997b4b9fe461c26ffbab0">hasRibbonTrail</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a ribbon trail with the given name exists.  <a href="#d0d074b988d997b4b9fe461c26ffbab0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f9c802d5f62e0c7b807dad407e47b97e">destroyRibbonTrail</a> (<a class="el" href="classOgre_1_1RibbonTrail.html">RibbonTrail</a> *obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="classOgre_1_1RibbonTrail.html" title="Subclass of BillboardChain which automatically leaves a trail behind one or more...">RibbonTrail</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#f9c802d5f62e0c7b807dad407e47b97e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6e86cea62012449c98c7afa14c241d78">destroyRibbonTrail</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="classOgre_1_1RibbonTrail.html" title="Subclass of BillboardChain which automatically leaves a trail behind one or more...">RibbonTrail</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#6e86cea62012449c98c7afa14c241d78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#12e41109a26094ffe128beb5b6898f95">destroyAllRibbonTrails</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys all RibbonTrails from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#12e41109a26094ffe128beb5b6898f95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1ParticleSystem.html">ParticleSystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1ccfcf067b098ce531f16998e1bbe275">createParticleSystem</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;templateName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a particle system based on a template.  <a href="#1ccfcf067b098ce531f16998e1bbe275"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1ParticleSystem.html">ParticleSystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#62589dc6a7f70e5efdbf5ebd7a282ea9">createParticleSystem</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, size_t quota=500, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;resourceGroup=<a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a blank particle system.  <a href="#62589dc6a7f70e5efdbf5ebd7a282ea9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1ParticleSystem.html">ParticleSystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#499cc0669395a5a11aea7d19979765b7">getParticleSystem</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to the named <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a>.  <a href="#499cc0669395a5a11aea7d19979765b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3dc7da5d60915c3667a531d2f053e34a">hasParticleSystem</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a particle system with the given name exists.  <a href="#3dc7da5d60915c3667a531d2f053e34a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#bde401fcf3796e3e2beb8c7603648f07">destroyParticleSystem</a> (<a class="el" href="classOgre_1_1ParticleSystem.html">ParticleSystem</a> *obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#bde401fcf3796e3e2beb8c7603648f07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#bb127ba7b98f3892426d4f55abd2a953">destroyParticleSystem</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys a <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#bb127ba7b98f3892426d4f55abd2a953"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#98dbd81cd9867b1032e02e1780b6eb49">destroyAllParticleSystems</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys all ParticleSystems from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#98dbd81cd9867b1032e02e1780b6eb49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a5b2047b5740b691b0e636d57f2dba7e">clearScene</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc.  <a href="#a5b2047b5740b691b0e636d57f2dba7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;colour)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the ambient light level to be used for the scene.  <a href="#7c26cdbb5703cf10a99add1f6a930ca2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d4b5b77723e26e8ceb995f84b7fcade5">getAmbientLight</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the ambient light level to be used for the scene.  <a href="#d4b5b77723e26e8ceb995f84b7fcade5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#5ceb87944e7ba077e4c6ed8db8acf4cc">prepareWorldGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the source of the 'world' geometry, i.e.  <a href="#5ceb87944e7ba077e4c6ed8db8acf4cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#5a237a294eb4ebebee35da1825f71f06">prepareWorldGeometry</a> (<a class="el" href="classOgre_1_1SharedPtr.html">DataStreamPtr</a> &amp;stream, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName=<a class="el" href="classOgre_1_1StringUtil.html#d2ead745c8c6f4f7056270e22f29e4da">StringUtil::BLANK</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the source of the 'world' geometry, i.e.  <a href="#5a237a294eb4ebebee35da1825f71f06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ccb0fdfbd1f61aa4d3d6e1f4625e1f9c">setWorldGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the source of the 'world' geometry, i.e.  <a href="#ccb0fdfbd1f61aa4d3d6e1f4625e1f9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#000a7ece2364c8da5e9f4b5d6aac6730">setWorldGeometry</a> (<a class="el" href="classOgre_1_1SharedPtr.html">DataStreamPtr</a> &amp;stream, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName=<a class="el" href="classOgre_1_1StringUtil.html#d2ead745c8c6f4f7056270e22f29e4da">StringUtil::BLANK</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the source of the 'world' geometry, i.e.  <a href="#000a7ece2364c8da5e9f4b5d6aac6730"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1257fd328d54908eeb45398b3191f92b">estimateWorldGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimate the number of loading stages required to load the named world geometry.  <a href="#1257fd328d54908eeb45398b3191f92b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#eeea65a3bf511e82a9b59ba31b96e98f">estimateWorldGeometry</a> (<a class="el" href="classOgre_1_1SharedPtr.html">DataStreamPtr</a> &amp;stream, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName=<a class="el" href="classOgre_1_1StringUtil.html#d2ead745c8c6f4f7056270e22f29e4da">StringUtil::BLANK</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimate the number of loading stages required to load the named world geometry.  <a href="#eeea65a3bf511e82a9b59ba31b96e98f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structOgre_1_1ViewPoint.html">ViewPoint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#dd6fe27d7a9500aafbe9325c21985801">getSuggestedViewpoint</a> (bool random=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asks the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> to provide a suggested viewpoint from which the scene should be viewed.  <a href="#dd6fe27d7a9500aafbe9325c21985801"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#34f3ddda75dcf75d5c5176446b3316a8">setOption</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;strKey, const void *pValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method for setting a specific option of the Scene Manager.  <a href="#34f3ddda75dcf75d5c5176446b3316a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2ea53a860f373185f5a46239f579a361">getOption</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;strKey, void *pDestValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method for getting the value of an implementation-specific Scene Manager option.  <a href="#2ea53a860f373185f5a46239f579a361"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#31da84037d0cca0008e9e894e8ddb569">hasOption</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;strKey) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method for verifying wether the scene manager has an implementation-specific option.  <a href="#31da84037d0cca0008e9e894e8ddb569"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e291393bc0c5bd48a8c6e79742180c93">getOptionValues</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;strKey, <a class="el" href="namespaceOgre.html#783e5227595f351519627abfb740ec85">StringVector</a> &amp;refValueList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method for getting all possible values for a specific option.  <a href="#e291393bc0c5bd48a8c6e79742180c93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7c8ff6b5c19eb9eeef9d5a6c9fca9fe8">getOptionKeys</a> (<a class="el" href="namespaceOgre.html#783e5227595f351519627abfb740ec85">StringVector</a> &amp;refKeys)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method for getting all the implementation-specific options of the scene manager.  <a href="#7c8ff6b5c19eb9eeef9d5a6c9fca9fe8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#24ad98304368771d852a5ef62eb8d277">_updateSceneGraph</a> (<a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for updating the scene graph ie the tree of <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> instances managed by this class.  <a href="#24ad98304368771d852a5ef62eb8d277"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#bd51f4629d00ff23f5064c0d2ab37647">_findVisibleObjects</a> (<a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam, <a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> *visibleBounds, bool onlyShadowCasters)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method which parses the scene to find visible objects to render.  <a href="#bd51f4629d00ff23f5064c0d2ab37647"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#58019e4c5104af4fe19d483fb1deec91">_applySceneAnimations</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for applying animations to scene nodes.  <a href="#58019e4c5104af4fe19d483fb1deec91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a4714d027f9718bce87783bcca19f595">_renderVisibleObjects</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends visible objects found in _findVisibleObjects to the rendering engine.  <a href="#a4714d027f9718bce87783bcca19f595"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#29ba8a2cad151d307d04781f749e7e84">_renderScene</a> (<a class="el" href="classOgre_1_1Camera.html">Camera</a> *camera, <a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *vp, bool includeOverlays)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prompts the class to send its contents to the renderer.  <a href="#29ba8a2cad151d307d04781f749e7e84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#85f817bd7ceae5bb1601b9b838eaff80">_queueSkiesForRendering</a> (<a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for queueing the sky objects with the params as previously set through setSkyBox, setSkyPlane and setSkyDome.  <a href="#85f817bd7ceae5bb1601b9b838eaff80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b20c0ee49a853145d3350e6e32c59f32">_setDestinationRenderSystem</a> (<a class="el" href="classOgre_1_1RenderSystem.html">RenderSystem</a> *sys)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notifies the scene manager of its destination render system.  <a href="#b20c0ee49a853145d3350e6e32c59f32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7f9395e50574b0d0c343036cf816c2bf">setSkyPlane</a> (bool enable, const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;plane, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale=1000, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tiling=10, bool drawFirst=true, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> bow=0, int xsegments=1, int ysegments=1, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables / disables a 'sky plane' i.e.  <a href="#7f9395e50574b0d0c343036cf816c2bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1791ac4fbc202fbea7247f236b363fa4">_setSkyPlane</a> (bool enable, const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;plane, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale=1000, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tiling=10, <a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> renderQueue=RENDER_QUEUE_SKIES_EARLY, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> bow=0, int xsegments=1, int ysegments=1, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables / disables a 'sky plane' i.e.  <a href="#1791ac4fbc202fbea7247f236b363fa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9d22e78d5f0059aeb0f822064af6ed5b">isSkyPlaneEnabled</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether a key plane is enabled.  <a href="#9d22e78d5f0059aeb0f822064af6ed5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f4199356f06cd6fd64c1257806e5e94f">getSkyPlaneNode</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the sky plane node, if enabled.  <a href="#f4199356f06cd6fd64c1257806e5e94f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="structOgre_1_1SceneManager_1_1SkyPlaneGenParameters.html">SkyPlaneGenParameters</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#68bd19b47ed424ebda3a7987a6d1c289">getSkyPlaneGenParameters</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parameters used to construct the SkyPlane, if any.  <a href="#68bd19b47ed424ebda3a7987a6d1c289"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f419fca38294bef65224162b3ad4af36">setSkyBox</a> (bool enable, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance=5000, bool drawFirst=true, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;orientation=<a class="el" href="classOgre_1_1Quaternion.html#441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables / disables a 'sky box' i.e.  <a href="#f419fca38294bef65224162b3ad4af36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1dd29bf89d777d7c2b032ebffca7e8d5">_setSkyBox</a> (bool enable, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance=5000, <a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> renderQueue=RENDER_QUEUE_SKIES_EARLY, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;orientation=<a class="el" href="classOgre_1_1Quaternion.html#441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables / disables a 'sky box' i.e.  <a href="#1dd29bf89d777d7c2b032ebffca7e8d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1209e1308df35bae42460f8aece7549b">isSkyBoxEnabled</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether a skybox is enabled.  <a href="#1209e1308df35bae42460f8aece7549b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3092d641b3b6697fa12517898463c49b">getSkyBoxNode</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the skybox node, if enabled.  <a href="#3092d641b3b6697fa12517898463c49b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="structOgre_1_1SceneManager_1_1SkyBoxGenParameters.html">SkyBoxGenParameters</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ca48eb6f90fcd5f169c94ad3d1a27ef6">getSkyBoxGenParameters</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parameters used to generate the current SkyBox, if any.  <a href="#ca48eb6f90fcd5f169c94ad3d1a27ef6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#dd758e3fa5df1291df9ff98b2594d35b">setSkyDome</a> (bool enable, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> curvature=10, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tiling=8, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance=4000, bool drawFirst=true, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;orientation=<a class="el" href="classOgre_1_1Quaternion.html#441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>, int xsegments=16, int ysegments=16, int ysegments_keep=-1, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables / disables a 'sky dome' i.e.  <a href="#dd758e3fa5df1291df9ff98b2594d35b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a6eea5fcfe5a6210a5db044e14a525f8">_setSkyDome</a> (bool enable, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> curvature=10, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tiling=8, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance=4000, <a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> renderQueue=RENDER_QUEUE_SKIES_EARLY, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;orientation=<a class="el" href="classOgre_1_1Quaternion.html#441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>, int xsegments=16, int ysegments=16, int ysegments_keep=-1, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables / disables a 'sky dome' i.e.  <a href="#a6eea5fcfe5a6210a5db044e14a525f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#418e075ad2d68dec59105f743fccdae8">isSkyDomeEnabled</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether a skydome is enabled.  <a href="#418e075ad2d68dec59105f743fccdae8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b48d1e49e2b176863c72af383b86120e">getSkyDomeNode</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the sky dome node, if enabled.  <a href="#b48d1e49e2b176863c72af383b86120e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="structOgre_1_1SceneManager_1_1SkyDomeGenParameters.html">SkyDomeGenParameters</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6af078e9234b8d90812ca46a7dd7151b">getSkyDomeGenParameters</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the parameters used to generate the current SkyDome, if any.  <a href="#6af078e9234b8d90812ca46a7dd7151b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b804195c05873da617dcd16198a63d1c">setFog</a> (<a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> mode=FOG_NONE, const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;colour=<a class="el" href="classOgre_1_1ColourValue.html#8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a>, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> expDensity=0.001, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearStart=0.0, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearEnd=1.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the fogging mode applied to the scene.  <a href="#b804195c05873da617dcd16198a63d1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#361b6c81efb56c75fd70b5c6e357c3b3">getFogMode</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the fog mode for the scene.  <a href="#361b6c81efb56c75fd70b5c6e357c3b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#306704e4889173ad708e1d0f5d7e3930">getFogColour</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the fog colour for the scene.  <a href="#306704e4889173ad708e1d0f5d7e3930"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b1a6c6d9e62244cf7b179920241d1f60">getFogStart</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the fog start distance for the scene.  <a href="#b1a6c6d9e62244cf7b179920241d1f60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#685fdcd7904870ecff70e6cf7e962ca4">getFogEnd</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the fog end distance for the scene.  <a href="#685fdcd7904870ecff70e6cf7e962ca4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#251033c27ac5d12c4f9bb2eee43b4d6a">getFogDensity</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the fog density for the scene.  <a href="#251033c27ac5d12c4f9bb2eee43b4d6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1BillboardSet.html">BillboardSet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e4d6f699a273cf16a8ce09757ebf8baf">createBillboardSet</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, unsigned int poolSize=20)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> for use with this scene manager.  <a href="#e4d6f699a273cf16a8ce09757ebf8baf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1BillboardSet.html">BillboardSet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f244f7e07456f6ababa2fa97399627fd">getBillboardSet</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a pointer to the named <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a>.  <a href="#f244f7e07456f6ababa2fa97399627fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8227de25c67053821c2bfbdf9b27504b">hasBillboardSet</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a billboardset with the given name exists.  <a href="#8227de25c67053821c2bfbdf9b27504b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#86252d84802cb54bba22bd8ed87d84f0">destroyBillboardSet</a> (<a class="el" href="classOgre_1_1BillboardSet.html">BillboardSet</a> *set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys an <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#86252d84802cb54bba22bd8ed87d84f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#56ecce16952d08b045e500d28981d307">destroyBillboardSet</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys an <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> by name.  <a href="#56ecce16952d08b045e500d28981d307"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#62742f3922523e75b72f6e8303fea251">destroyAllBillboardSets</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes &amp; destroys all BillboardSets.  <a href="#62742f3922523e75b72f6e8303fea251"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#46c5cbc33b0f498ed01670289e87584c">setDisplaySceneNodes</a> (bool display)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> whether it should render the SceneNodes which make up the scene as well as the objects in the scene.  <a href="#46c5cbc33b0f498ed01670289e87584c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#abe2da637fd725bf8326c662a019f4d3">getDisplaySceneNodes</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if all scene nodes axis are to be displayed.  <a href="#abe2da637fd725bf8326c662a019f4d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Animation.html">Animation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8ffb7989a0db906222663ff2d34317ea">createAnimation</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an animation which can be used to animate scene nodes.  <a href="#8ffb7989a0db906222663ff2d34317ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1Animation.html">Animation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7ba18a3e34e9ee8c286b6b4dfff42011">getAnimation</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up an <a class="el" href="classOgre_1_1Animation.html" title="An animation sequence.">Animation</a> object previously created with createAnimation.  <a href="#7ba18a3e34e9ee8c286b6b4dfff42011"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a88f44e5200e790105cb18814bdee7e5">hasAnimation</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether an animation with the given name exists.  <a href="#a88f44e5200e790105cb18814bdee7e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7ac4e76d36c8f059d7389bf1233563b5">destroyAnimation</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys an <a class="el" href="classOgre_1_1Animation.html" title="An animation sequence.">Animation</a>.  <a href="#7ac4e76d36c8f059d7389bf1233563b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#019a31618f2285f79be2b414488c04c3">destroyAllAnimations</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all animations created using this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#019a31618f2285f79be2b414488c04c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1AnimationState.html">AnimationState</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3e060f962b38c9e9f43f8618ff652ea3">createAnimationState</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;animName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an <a class="el" href="classOgre_1_1AnimationState.html" title="Represents the state of an animation and the weight of it&#39;s influence.">AnimationState</a> object for managing application of animations.  <a href="#3e060f962b38c9e9f43f8618ff652ea3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1AnimationState.html">AnimationState</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e4d6cc4ff860b1e8f73ec9d3a9a960a9">getAnimationState</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;animName) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves animation state as previously created using createAnimationState.  <a href="#e4d6cc4ff860b1e8f73ec9d3a9a960a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#08510a6f311d26de3a385b809bb51c32">hasAnimationState</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether an animation state with the given name exists.  <a href="#08510a6f311d26de3a385b809bb51c32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#22a3f58bff113aaac870c18741f7cd76">destroyAnimationState</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys an <a class="el" href="classOgre_1_1AnimationState.html" title="Represents the state of an animation and the weight of it&#39;s influence.">AnimationState</a>.  <a href="#22a3f58bff113aaac870c18741f7cd76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a60a84672be1f532323cdb5dbfdc2c66">destroyAllAnimationStates</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all animation states created using this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#a60a84672be1f532323cdb5dbfdc2c66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#16f971d1a34ce55b83c16634a56e2b6a">manualRender</a> (<a class="el" href="classOgre_1_1RenderOperation.html">RenderOperation</a> *rend, <a class="el" href="classOgre_1_1Pass.html">Pass</a> *pass, <a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *vp, const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;worldMatrix, const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;viewMatrix, const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;projMatrix, bool doBeginEndFrame=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manual rendering method, for advanced users only.  <a href="#16f971d1a34ce55b83c16634a56e2b6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8accbffd3a95901ac09bc32784b2e27d">getRenderQueue</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the internal render queue, for advanced users only.  <a href="#8accbffd3a95901ac09bc32784b2e27d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e60242c5d130f884cd605d3393186df6">addRenderQueueListener</a> (<a class="el" href="classOgre_1_1RenderQueueListener.html">RenderQueueListener</a> *newListener)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a new <a class="el" href="classOgre_1_1RenderQueueListener.html" title="Abstract interface which classes must implement if they wish to receive events from...">RenderQueueListener</a> which will be notified when render queues are processed.  <a href="#e60242c5d130f884cd605d3393186df6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#190471ba7a61111d576a1e8ca9862706">removeRenderQueueListener</a> (<a class="el" href="classOgre_1_1RenderQueueListener.html">RenderQueueListener</a> *delListener)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a listener previously added with addRenderQueueListener.  <a href="#190471ba7a61111d576a1e8ca9862706"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#80869e48b56b0c02a52e9027cad26fa7">addSpecialCaseRenderQueue</a> (<a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> qid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an item to the 'special case' render queue list.  <a href="#80869e48b56b0c02a52e9027cad26fa7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#5683d75af7c73bfdd9db2b9185b99a53">removeSpecialCaseRenderQueue</a> (<a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> qid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an item to the 'special case' render queue list.  <a href="#5683d75af7c73bfdd9db2b9185b99a53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#cfc2cc0a7f105a068603955c4dbbe3c4">clearSpecialCaseRenderQueues</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the 'special case' render queue list.  <a href="#cfc2cc0a7f105a068603955c4dbbe3c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#10753c0e57be813e135395e3a882777a">setSpecialCaseRenderQueueMode</a> (<a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6">SpecialCaseRenderQueueMode</a> mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the way the special case render queue list is processed.  <a href="#10753c0e57be813e135395e3a882777a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6">SpecialCaseRenderQueueMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ed183c1907c928f384cd087b40a3f685">getSpecialCaseRenderQueueMode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the way the special case render queue list is processed.  <a href="#ed183c1907c928f384cd087b40a3f685"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#bdf79b63bce9f65571359c96a585eb9f">isRenderQueueToBeProcessed</a> (<a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> qid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether or not the named queue will be rendered based on the current 'special case' render queue list and mode.  <a href="#bdf79b63bce9f65571359c96a585eb9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3c0437a615af536aaf69ba267f2f15d2">setWorldGeometryRenderQueue</a> (<a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> qid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the render queue that the world geometry (if any) this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> renders will be associated with.  <a href="#3c0437a615af536aaf69ba267f2f15d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f036aed42b3e7480915704f29865c788">getWorldGeometryRenderQueue</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the render queue that the world geometry (if any) this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> renders will be associated with.  <a href="#f036aed42b3e7480915704f29865c788"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#487859007d68fe9f261aea1645252563">showBoundingBoxes</a> (bool bShow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows all bounding boxes of scene nodes to be displayed.  <a href="#487859007d68fe9f261aea1645252563"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a22b0b7e88539bb34a5c9c309c87bd34">getShowBoundingBoxes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns if all bounding boxes of scene nodes are to be displayed.  <a href="#a22b0b7e88539bb34a5c9c309c87bd34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ae9af47cfe8ae3184744e9d19d73341f">_notifyAutotrackingSceneNode</a> (<a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *node, bool autoTrack)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for notifying the manager that a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> is autotracking.  <a href="#ae9af47cfe8ae3184744e9d19d73341f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1AxisAlignedBoxSceneQuery.html">AxisAlignedBoxSceneQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#acbb49cc9b31adb40d3bbddc8f51d89a">createAABBQuery</a> (const <a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a> &amp;box, unsigned long mask=0xFFFFFFFF)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="classOgre_1_1AxisAlignedBoxSceneQuery.html" title="Specialises the SceneQuery class for querying within an axis aligned box.">AxisAlignedBoxSceneQuery</a> for this scene manager.  <a href="#acbb49cc9b31adb40d3bbddc8f51d89a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1SphereSceneQuery.html">SphereSceneQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#40730811207d2a7ef8f8fc0c3fda8b91">createSphereQuery</a> (const <a class="el" href="classOgre_1_1Sphere.html">Sphere</a> &amp;sphere, unsigned long mask=0xFFFFFFFF)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classOgre_1_1SphereSceneQuery.html" title="Specialises the SceneQuery class for querying within a sphere.">SphereSceneQuery</a> for this scene manager.  <a href="#40730811207d2a7ef8f8fc0c3fda8b91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1PlaneBoundedVolumeListSceneQuery.html">PlaneBoundedVolumeListSceneQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#cc61e987518b30805120ac4009b5dd33">createPlaneBoundedVolumeQuery</a> (const <a class="el" href="namespaceOgre.html#f6bda7879d1ac92561a02cbd1833e1b1">PlaneBoundedVolumeList</a> &amp;volumes, unsigned long mask=0xFFFFFFFF)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classOgre_1_1PlaneBoundedVolumeListSceneQuery.html" title="Specialises the SceneQuery class for querying within a plane-bounded volume.">PlaneBoundedVolumeListSceneQuery</a> for this scene manager.  <a href="#cc61e987518b30805120ac4009b5dd33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1RaySceneQuery.html">RaySceneQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#95a6c54fd3bf3e9a3c4d16cc7dc67d5c">createRayQuery</a> (const <a class="el" href="classOgre_1_1Ray.html">Ray</a> &amp;ray, unsigned long mask=0xFFFFFFFF)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classOgre_1_1RaySceneQuery.html" title="Specialises the SceneQuery class for querying along a ray.">RaySceneQuery</a> for this scene manager.  <a href="#95a6c54fd3bf3e9a3c4d16cc7dc67d5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1IntersectionSceneQuery.html">IntersectionSceneQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#82b0c69188695880a693df4e6392ebba">createIntersectionQuery</a> (unsigned long mask=0xFFFFFFFF)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="classOgre_1_1IntersectionSceneQuery.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting...">IntersectionSceneQuery</a> for this scene manager.  <a href="#82b0c69188695880a693df4e6392ebba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#08f7adf5f342c6808481fa922c8c62a0">destroyQuery</a> (<a class="el" href="classOgre_1_1SceneQuery.html">SceneQuery</a> *query)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a scene query of any type.  <a href="#08f7adf5f342c6808481fa922c8c62a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1MapIterator.html">CameraIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#02d7d29cc4bc8ee4cbe40d16a984291c">getCameraIterator</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a specialised <a class="el" href="classOgre_1_1MapIterator.html" title="Wraps iteration over a map.">MapIterator</a> over all cameras in the scene.  <a href="#02d7d29cc4bc8ee4cbe40d16a984291c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1MapIterator.html">AnimationIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b28450738168fe330709ad0d090df6b5">getAnimationIterator</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a specialised <a class="el" href="classOgre_1_1MapIterator.html" title="Wraps iteration over a map.">MapIterator</a> over all animations in the scene.  <a href="#b28450738168fe330709ad0d090df6b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1MapIterator.html">AnimationStateIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#39bf64e686d94b6856d3ff06d627b61c">getAnimationStateIterator</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a specialised <a class="el" href="classOgre_1_1MapIterator.html" title="Wraps iteration over a map.">MapIterator</a> over all animation states in the scene.  <a href="#39bf64e686d94b6856d3ff06d627b61c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0f8f32d176059a385527cf9970ddc892">setShadowTechnique</a> (<a class="el" href="namespaceOgre.html#79dcd426d291c31072c1ad6f183715d6">ShadowTechnique</a> technique)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the general shadow technique to be used in this scene.  <a href="#0f8f32d176059a385527cf9970ddc892"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#79dcd426d291c31072c1ad6f183715d6">ShadowTechnique</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2b2a69e400687b335c414a6053de2b34">getShadowTechnique</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current shadow technique.  <a href="#2b2a69e400687b335c414a6053de2b34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e2b74088a5229f3bbb09da8589968d9b">setShowDebugShadows</a> (bool debug)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables / disables the rendering of debug information for shadows.  <a href="#e2b74088a5229f3bbb09da8589968d9b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d6d310a8836f8c08b4f4f189f855d510">getShowDebugShadows</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are debug shadows shown?  <a href="#d6d310a8836f8c08b4f4f189f855d510"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d8ab6139696f9ef50d8abea0528e85b4">setShadowColour</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;colour)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the colour used to modulate areas in shadow.  <a href="#d8ab6139696f9ef50d8abea0528e85b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c3b3146c419a2d272b14c5dc50b024c3">getShadowColour</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the colour used to modulate areas in shadow.  <a href="#c3b3146c419a2d272b14c5dc50b024c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9d220fa31bf0d95ad65558936c71a194">setShadowDirectionalLightExtrusionDistance</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> dist)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the distance a shadow volume is extruded for a directional light.  <a href="#9d220fa31bf0d95ad65558936c71a194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#73a0ca638976062f80ebd967a638be22">getShadowDirectionalLightExtrusionDistance</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the distance a shadow volume is extruded for a directional light.  <a href="#73a0ca638976062f80ebd967a638be22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0e593d05e2f892b8fc3bfca917a75fef">setShadowFarDistance</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the default maximum distance away from the camera that shadows will be visible.  <a href="#0e593d05e2f892b8fc3bfca917a75fef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8f9420b7a640d29475bc09a83f4e2458">getShadowFarDistance</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the default maximum distance away from the camera that shadows will be visible.  <a href="#8f9420b7a640d29475bc09a83f4e2458"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2d50ad888092c98a14139ce03a904388">getShadowFarDistanceSquared</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3364ae687de3cbf3bd5e87ffd52877e5">setShadowIndexBufferSize</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum size of the index buffer used to render shadow primitives.  <a href="#3364ae687de3cbf3bd5e87ffd52877e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ce6c0cf42787f6c51e4df2e13d3482a0">getShadowIndexBufferSize</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the shadow index buffer.  <a href="#ce6c0cf42787f6c51e4df2e13d3482a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c594a29110119bed71f1c0c61265394b">setShadowTextureSize</a> (unsigned short size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the size of the texture used for all texture-based shadows.  <a href="#c594a29110119bed71f1c0c61265394b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3e8c1da7e6770a80383e9079484fbd94">setShadowTextureConfig</a> (size_t shadowIndex, unsigned short width, unsigned short height, <a class="el" href="namespaceOgre.html#7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> format)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the detailed configuration for a shadow texture.  <a href="#3e8c1da7e6770a80383e9079484fbd94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0ff40f3cef8dd775ee782bbae15d436b">setShadowTextureConfig</a> (size_t shadowIndex, const <a class="el" href="structOgre_1_1ShadowTextureConfig.html">ShadowTextureConfig</a> &amp;config)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the detailed configuration for a shadow texture.  <a href="#0ff40f3cef8dd775ee782bbae15d436b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstShadowTextureConfigIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1bb99c11f9213def3e23784ccff6435f">getShadowTextureConfigIterator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the current shadow texture settings.  <a href="#1bb99c11f9213def3e23784ccff6435f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#87fac14153b877effba7196f116cbdc6">setShadowTexturePixelFormat</a> (<a class="el" href="namespaceOgre.html#7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> fmt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the pixel format of the textures used for texture-based shadows.  <a href="#87fac14153b877effba7196f116cbdc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7b960b480425cecbe39573215fb5e48c">setShadowTextureCount</a> (size_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of textures allocated for texture-based shadows.  <a href="#7b960b480425cecbe39573215fb5e48c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7806a68edbfbbeac721dee76de6f869e">getShadowTextureCount</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of the textures allocated for texture based shadows.  <a href="#7806a68edbfbbeac721dee76de6f869e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#70f8eddf9b8617783fb7d0995b985a9a">setShadowTextureCountPerLightType</a> (<a class="el" href="classOgre_1_1Light.html#4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a> type, size_t count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of shadow textures a light type uses.  <a href="#70f8eddf9b8617783fb7d0995b985a9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#04405da47f025ac1e628ee25f1b85fc4">getShadowTextureCountPerLightType</a> (<a class="el" href="classOgre_1_1Light.html#4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a> type) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of shadow textures is assigned for the given light type.  <a href="#04405da47f025ac1e628ee25f1b85fc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#371e8c69a14e788d8983955c6f5d86f9">setShadowTextureSettings</a> (unsigned short size, unsigned short count, <a class="el" href="namespaceOgre.html#7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a> fmt=PF_X8R8G8B8)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size and count of textures used in texture-based shadows.  <a href="#371e8c69a14e788d8983955c6f5d86f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="classOgre_1_1TexturePtr.html">TexturePtr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#bf504cf97c1723f6fab069335ecee9a0">getShadowTexture</a> (size_t shadowIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the shadow texture currently in use at the given index.  <a href="#bf504cf97c1723f6fab069335ecee9a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#893663f55c2b4a29467cff25b9b1b3f4">setShadowDirLightTextureOffset</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space.  <a href="#893663f55c2b4a29467cff25b9b1b3f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#74ce4995eac32da6d1c2d2cef58c7019">getShadowDirLightTextureOffset</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space.  <a href="#74ce4995eac32da6d1c2d2cef58c7019"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#72fa019aa4efbc6943842efcf5f38078">setShadowTextureFadeStart</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fadeStart)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the proportional distance at which texture shadows begin to fade out.  <a href="#72fa019aa4efbc6943842efcf5f38078"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#237a09e65919b808473c543fb886723f">setShadowTextureFadeEnd</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> fadeEnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the proportional distance at which texture shadows finish to fading out.  <a href="#237a09e65919b808473c543fb886723f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8de7e38165fe9b0aa4baddf95ef006e7">setShadowTextureSelfShadow</a> (bool selfShadow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not texture shadows should attempt to self-shadow.  <a href="#8de7e38165fe9b0aa4baddf95ef006e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a5062fe502bf8cd49b974a5ca8052468">getShadowTextureSelfShadow</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether or not texture shadows attempt to self-shadow.  <a href="#a5062fe502bf8cd49b974a5ca8052468"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9f0cde141313583e65561abdfae6a0ec">setShadowTextureCasterMaterial</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the default material to use for rendering shadow casters.  <a href="#9f0cde141313583e65561abdfae6a0ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e0d524bf189e08fdab005ca2b5560190">setShadowTextureReceiverMaterial</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the default material to use for rendering shadow receivers.  <a href="#e0d524bf189e08fdab005ca2b5560190"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#af865048d62de79942fea2758c33ee3e">setShadowCasterRenderBackFaces</a> (bool bf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces.  <a href="#af865048d62de79942fea2758c33ee3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#99b0932e1331a4e07e0db0301172da20">getShadowCasterRenderBackFaces</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces.  <a href="#99b0932e1331a4e07e0db0301172da20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#dbe1da236689cdd20690d5da950dce33">setShadowCameraSetup</a> (const <a class="el" href="classOgre_1_1SharedPtr.html">ShadowCameraSetupPtr</a> &amp;shadowSetup)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the shadow camera setup to use for all lights which don't have their own shadow camera setup.  <a href="#dbe1da236689cdd20690d5da950dce33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="classOgre_1_1SharedPtr.html">ShadowCameraSetupPtr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ae7259371b79bafd3f164daaf34a919c">getShadowCameraSetup</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the shadow camera setup in use for all lights which don't have their own shadow camera setup.  <a href="#ae7259371b79bafd3f164daaf34a919c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a40a406b22c8d5dd282523f8dcd09e34">setShadowUseInfiniteFarPlane</a> (bool enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether we should use an inifinite camera far plane when rendering stencil shadows.  <a href="#a40a406b22c8d5dd282523f8dcd09e34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#bcd82e9adadad77f0935b5cdb7182ec6">isShadowTechniqueStencilBased</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is there a stencil shadow based shadowing technique in use?  <a href="#bcd82e9adadad77f0935b5cdb7182ec6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#194ea7ba828e1f713226f16eec8cd8b5">isShadowTechniqueTextureBased</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is there a texture shadow based shadowing technique in use?  <a href="#194ea7ba828e1f713226f16eec8cd8b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0d931a137e72d11bdaeb200fa0a8ffb8">isShadowTechniqueModulative</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is there a modulative shadowing technique in use?  <a href="#0d931a137e72d11bdaeb200fa0a8ffb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6c46ea94370e147deb8c49823db0ed7d">isShadowTechniqueAdditive</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is there an additive shadowing technique in use?  <a href="#6c46ea94370e147deb8c49823db0ed7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7145a399f90a25b120bd9802d24448a7">isShadowTechniqueIntegrated</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is the shadow technique integrated into primary materials?  <a href="#7145a399f90a25b120bd9802d24448a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6dfdf56d941a145875d81c4c763f9391">isShadowTechniqueInUse</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is there any shadowing technique in use?  <a href="#6dfdf56d941a145875d81c4c763f9391"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#83a8347369ffc819ea8c85e4d416fb9c">setShadowUseLightClipPlanes</a> (bool enabled)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering.  <a href="#83a8347369ffc819ea8c85e4d416fb9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#50faf3e81e28c16fefea6937d4b6a611">getShadowUseLightClipPlanes</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering.  <a href="#50faf3e81e28c16fefea6937d4b6a611"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6b54e34b6a8e72d4c1456bda016731ad">addListener</a> (<a class="el" href="classOgre_1_1SceneManager_1_1Listener.html">Listener</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a listener which will get called back on scene manager events.  <a href="#6b54e34b6a8e72d4c1456bda016731ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#4437b11b78eae8f5db205aa89c0235ee">removeListener</a> (<a class="el" href="classOgre_1_1SceneManager_1_1Listener.html">Listener</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a listener.  <a href="#4437b11b78eae8f5db205aa89c0235ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1StaticGeometry.html">StaticGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#552d1695774ca8f8da355ef0f11be86c">createStaticGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instance suitable for use with this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#552d1695774ca8f8da355ef0f11be86c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1StaticGeometry.html">StaticGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3193bc1a8bc05df184234b59a7701a2f">getStaticGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a previously created <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instance.  <a href="#3193bc1a8bc05df184234b59a7701a2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#cbaddd36a321a7c00085f654df71991d">hasStaticGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a static geometry instance with the given name exists.  <a href="#cbaddd36a321a7c00085f654df71991d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#54d553be3f6098ce229e6db53ec15227">destroyStaticGeometry</a> (<a class="el" href="classOgre_1_1StaticGeometry.html">StaticGeometry</a> *geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove &amp; destroy a <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instance.  <a href="#54d553be3f6098ce229e6db53ec15227"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e4f180b40f4bf55669f9842fe922a003">destroyStaticGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove &amp; destroy a <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instance.  <a href="#e4f180b40f4bf55669f9842fe922a003"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#64f54ea048af80532212c8f60bea95d6">destroyAllStaticGeometry</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove &amp; destroy all <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instances.  <a href="#64f54ea048af80532212c8f60bea95d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1InstancedGeometry.html">InstancedGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#af98f349389bbdd1c3fb25c418e56887">createInstancedGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instance suitable for use with this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>.  <a href="#af98f349389bbdd1c3fb25c418e56887"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1InstancedGeometry.html">InstancedGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2b2a069b6fd8b7e49f70d7384f96a7f4">getInstancedGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a previously created <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instance.  <a href="#2b2a069b6fd8b7e49f70d7384f96a7f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#18bca397484fe3ba8ae396a959043e00">destroyInstancedGeometry</a> (<a class="el" href="classOgre_1_1InstancedGeometry.html">InstancedGeometry</a> *geom)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove &amp; destroy a <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instance.  <a href="#18bca397484fe3ba8ae396a959043e00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#54a8d0104ab73e3421e16dc316ea15fc">destroyInstancedGeometry</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove &amp; destroy a <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instance.  <a href="#54a8d0104ab73e3421e16dc316ea15fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#be13b71355bfe6d93303bdb73b458007">destroyAllInstancedGeometry</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove &amp; destroy all <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instances.  <a href="#be13b71355bfe6d93303bdb73b458007"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#edbccf093ce9ee7c4db9d59d9344bc94">createMovableObject</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName, const <a class="el" href="namespaceOgre.html#0537f38d7a77fcbe9f600f6ed8a926d6">NameValuePairList</a> *params=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a movable object of the type specified.  <a href="#edbccf093ce9ee7c4db9d59d9344bc94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#cac42f73eb41692a098bf31f1401d7e7">destroyMovableObject</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> with the name specified, of the type specified.  <a href="#cac42f73eb41692a098bf31f1401d7e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#32a135e382bac33ecd42f946713e2f38">destroyMovableObject</a> (<a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>.  <a href="#32a135e382bac33ecd42f946713e2f38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8aca5477f30dd55321a101f25c6a5ee2">destroyAllMovableObjectsByType</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy all MovableObjects of a given type.  <a href="#8aca5477f30dd55321a101f25c6a5ee2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f985062a80dbc20d8fe523be166ecca6">destroyAllMovableObjects</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy all MovableObjects.  <a href="#f985062a80dbc20d8fe523be166ecca6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f30f35e9d9630ae360fbf5a9de136452">getMovableObject</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to a previously created <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>.  <a href="#f30f35e9d9630ae360fbf5a9de136452"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#af8016cc1956244c4dd6844b030e06b9">hasMovableObject</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a movable object instance with the given name exists.  <a href="#af8016cc1956244c4dd6844b030e06b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1MapIterator.html">MovableObjectIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f19c32fbc0adc0fa28d8e6c26d9800cb">getMovableObjectIterator</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over all MovableObect instances of a given type.  <a href="#f19c32fbc0adc0fa28d8e6c26d9800cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f13eb691a7bdd67e17a402dee98c4b5f">injectMovableObject</a> (<a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inject a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> instance created externally.  <a href="#f13eb691a7bdd67e17a402dee98c4b5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6d14c16852b08107db556a180e61d7a1">extractMovableObject</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a previously injected <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>.  <a href="#6d14c16852b08107db556a180e61d7a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#874431ce04c34fa6dcbdb2ed1420b168">extractMovableObject</a> (<a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a previously injected <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>.  <a href="#874431ce04c34fa6dcbdb2ed1420b168"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1c55f5e97c66261de71c979db64f6355">extractAllMovableObjectsByType</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract all injected MovableObjects of a given type.  <a href="#1c55f5e97c66261de71c979db64f6355"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ef478368ad95d09c9df5ed114ba47c36">setVisibilityMask</a> (<a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> vmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible.  <a href="#ef478368ad95d09c9df5ed114ba47c36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#bd074aaefc7c579a0c6d09593bb7d3e6">getVisibilityMask</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible.  <a href="#bd074aaefc7c579a0c6d09593bb7d3e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#4ac70da4acb59963d90d58b0b76814e1">_getCombinedVisibilityMask</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for getting the combination between the global visibility mask and the per-viewport visibility mask.  <a href="#4ac70da4acb59963d90d58b0b76814e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#04c8414da02aec3e3f98acd013917ed2">setFindVisibleObjects</a> (bool find)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> should search for visible objects, or whether they are being manually handled.  <a href="#04c8414da02aec3e3f98acd013917ed2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3d7d7f344e528eea2e99481247de72c7">getFindVisibleObjects</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets whether the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> should search for visible objects, or whether they are being manually handled.  <a href="#3d7d7f344e528eea2e99481247de72c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#4fa4a94b8687098a6751be1ed36e20f7">setNormaliseNormalsOnScale</a> (bool n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to automatically normalise normals on objects whenever they are scaled.  <a href="#4fa4a94b8687098a6751be1ed36e20f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0fdae2f94c44e3f1be79c8c27f965ec2">getNormaliseNormalsOnScale</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get whether to automatically normalise normals on objects whenever they are scaled.  <a href="#0fdae2f94c44e3f1be79c8c27f965ec2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2a4d997503b651187f2e129cd5eeb7ad">setFlipCullingOnNegativeScale</a> (bool n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to automatically flip the culling mode on objects whenever they are negatively scaled.  <a href="#2a4d997503b651187f2e129cd5eeb7ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#bf5b90fccee3356293e5335265a2ea29">getFlipCullingOnNegativeScale</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get whether to automatically flip the culling mode on objects whenever they are negatively scaled.  <a href="#bf5b90fccee3356293e5335265a2ea29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3ef597efaec718cbe41c1244df9a0adf">_injectRenderWithPass</a> (<a class="el" href="classOgre_1_1Pass.html">Pass</a> *pass, <a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *rend, bool shadowDerivation=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render something as if it came from the current queue.  <a href="#3ef597efaec718cbe41c1244df9a0adf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6753ea2b52715774b7fdd59da232917a">_suppressRenderStateChanges</a> (bool suppress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates to the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> whether it should suppress changing the <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> states when rendering objects.  <a href="#6753ea2b52715774b7fdd59da232917a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f94f21965555436d24e715d2408fbb06">_areRenderStateChangesSuppressed</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are render state changes suppressed?  <a href="#f94f21965555436d24e715d2408fbb06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#90c2bebde23c88f9946e80627724ca44">_setPass</a> (const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *pass, bool evenIfSuppressed=false, bool shadowDerivation=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for setting up the renderstate for a rendering pass.  <a href="#90c2bebde23c88f9946e80627724ca44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#63644515ee55a20f31979e94eb227a1c">_suppressShadows</a> (bool suppress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates to the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> whether it should suppress the active shadow rendering technique until told otherwise.  <a href="#63644515ee55a20f31979e94eb227a1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#832e91f368f91e727dd2386cc00e7485">_areShadowsSuppressed</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are shadows suppressed?  <a href="#832e91f368f91e727dd2386cc00e7485"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e738d9a6259878ba16d0153539d3f7f8">_renderQueueGroupObjects</a> (<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *group, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render the objects in a given queue group.  <a href="#e738d9a6259878ba16d0153539d3f7f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f55b7d8cf3daf68db0266139faf73492">setQueuedRenderableVisitor</a> (<a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a> *visitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advanced method for supplying an alternative visitor, used for parsing the render queues and sending the results to the renderer.  <a href="#f55b7d8cf3daf68db0266139faf73492"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#fe6dac1f080afffd346271af26c464d7">getQueuedRenderableVisitor</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current visitor object which processes queued renderables.  <a href="#fe6dac1f080afffd346271af26c464d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1RenderSystem.html">RenderSystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a5ed3c081ae69e90569fd0c2727a34df">getDestinationRenderSystem</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the rendersystem subclass to which the output of this Scene Manager gets sent.  <a href="#a5ed3c081ae69e90569fd0c2727a34df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6e2c9ea54992be4b4729ab6243ed3e3a">getCurrentViewport</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current viewport being rendered (advanced use only, only valid during viewport update.  <a href="#6e2c9ea54992be4b4729ab6243ed3e3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <br>
<a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a724f4e6c46ceaa95a13d60a7d504db0">getVisibleObjectsBoundsInfo</a> (const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a visibility boundary box for a specific camera.  <a href="#a724f4e6c46ceaa95a13d60a7d504db0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <br>
<a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#63b60c5540665c878d5f15138c4cfa21">getShadowCasterBoundsInfo</a> (const <a class="el" href="classOgre_1_1Light.html">Light</a> *light, size_t iteration=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the shadow caster AAB for a specific light-camera combination.  <a href="#63b60c5540665c878d5f15138c4cfa21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#52de83e40cb386682bf3d148affd192b">setCameraRelativeRendering</a> (bool rel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it.  <a href="#52de83e40cb386682bf3d148affd192b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8aaf50983e9000284a8eed93a51353bc">getCameraRelativeRendering</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it.  <a href="#8aaf50983e9000284a8eed93a51353bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">operator new, with debug line info  <a href="#421b197ca3a38da17e2eb1531a645fa2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#c4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#b78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">placement operator new  <a href="#b78a921e54419be677839cdf15d1f0b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">array operator new, with debug line info  <a href="#4be37baef81876985aa1071ad5acc6dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#fa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#cb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#da8f4ecc06b8ffe99834d8e1db66c123">WORLD_GEOMETRY_TYPE_MASK</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query type mask which will be used for world geometry.  <a href="#da8f4ecc06b8ffe99834d8e1db66c123"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#43d0ee887419ee93d24975b906eb2783">ENTITY_TYPE_MASK</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query type mask which will be used for entities.  <a href="#43d0ee887419ee93d24975b906eb2783"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c036d861c2df264375b88e9f3a407b1e">FX_TYPE_MASK</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query type mask which will be used for effects like billboardsets / particle systems.  <a href="#c036d861c2df264375b88e9f3a407b1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#369ad7a1b8e0455052ea0bca0383942e">STATICGEOMETRY_TYPE_MASK</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query type mask which will be used for <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a>.  <a href="#369ad7a1b8e0455052ea0bca0383942e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#eb00e5cde673e9bcf74ec69027cf8039">LIGHT_TYPE_MASK</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query type mask which will be used for lights.  <a href="#eb00e5cde673e9bcf74ec69027cf8039"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e0f8858848acb8c595f495db753facb9">FRUSTUM_TYPE_MASK</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query type mask which will be used for frusta and cameras.  <a href="#e0f8858848acb8c595f495db753facb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#01d4bf3c6e81fddcfc96ec3f2714c8ac">USER_TYPE_MASK_LIMIT</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User type mask limit.  <a href="#01d4bf3c6e81fddcfc96ec3f2714c8ac"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d397960">BoxPlane</a> { <br>
&nbsp;&nbsp;<a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d397960ad0dc80ea2675cc30bca626042fa78c4">BP_FRONT</a> =  0, 
<a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d397960cfc07f1de74ca1a396f1d82a2d1c9c5e">BP_BACK</a> =  1, 
<a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d39796009545bd5ad791db9589669756be1a280">BP_LEFT</a> =  2, 
<a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d39796061400b6126b1da4e3ceaade1f1db7b56">BP_RIGHT</a> =  3, 
<br>
&nbsp;&nbsp;<a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d3979604547263fba7fb6507a3ea251f72d8f14">BP_UP</a> =  4, 
<a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d39796070e022fc77f94d5144db297d00effd67">BP_DOWN</a> =  5
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1Camera.html">Camera</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#361c61a0f17ac50c8fd49bc0dd3ff622">CameraList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>,<br>
 <a class="el" href="classOgre_1_1StaticGeometry.html">StaticGeometry</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f9c15d5bd04bde23d9a6f1de191623b4">StaticGeometryList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>,<br>
 <a class="el" href="classOgre_1_1InstancedGeometry.html">InstancedGeometry</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2228301bdefd1eb05500e140d212771d">InstancedGeometryList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f50133e2bd9b7629687560f221289559">SceneNodeList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::set<br>
&lt; <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#14f8ae72e357eb840b335c67fd991087">AutoTrackingSceneNodes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Autotracking scene nodes.  <a href="#14f8ae72e357eb840b335c67fd991087"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::set&lt; <a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8864f70edf5d284c2be437d4d586e505">SpecialCaseRenderQueueList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *,<br>
 <a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#99e7aa7b0f6f45e6cc750668cebf53e3">CamVisibleObjectsMap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visible objects bounding box list.  <a href="#99e7aa7b0f6f45e6cc750668cebf53e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *,<br>
 const <a class="el" href="classOgre_1_1Light.html">Light</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6ce1f7a7cc475c7cf797eb3867a4a01c">ShadowCamLightMapping</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ShadowCamera to light mapping.  <a href="#6ce1f7a7cc475c7cf797eb3867a4a01c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br>
&lt; <a class="el" href="structOgre_1_1SceneManager_1_1LightInfo.html">LightInfo</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#05443775a1f947308c5d90a24d45ed6f">LightInfoList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>,<br>
 <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#317d0ca0b29d739ed54b4422f850b629">MovableObjectMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>,<br>
 <a class="el" href="structOgre_1_1SceneManager_1_1MovableObjectCollection.html">MovableObjectCollection</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#5bdfdd7b221b17f4901a1c53d4011e80">MovableObjectCollectionMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1Animation.html">Animation</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#260738557c9a32aed8d5ca14c28d300f">AnimationList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Storage of animations, lookup by name.  <a href="#260738557c9a32aed8d5ca14c28d300f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br>
&lt; <a class="el" href="classOgre_1_1RenderQueueListener.html">RenderQueueListener</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b55740025112ba1139656d035f27bb45">RenderQueueListenerList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br>
&lt; <a class="el" href="classOgre_1_1SceneManager_1_1Listener.html">Listener</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9e4af19ff8fe945ba6e50dc1b71918da">ListenerList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br>
&lt; <a class="el" href="classOgre_1_1Camera.html">Camera</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#19a90448272159c7f2e2c7573b181151">ShadowTextureCameraList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map<br>
&lt; <a class="el" href="classOgre_1_1Light.html">Light</a> *,<br>
 <a class="el" href="structOgre_1_1SceneManager_1_1LightClippingInfo.html">LightClippingInfo</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c2e1d3390dfc6b3d58fdb934d75ce760">LightClippingInfoMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br>
&lt; <a class="el" href="classOgre_1_1ShadowCaster.html">ShadowCaster</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#25fa6eff947e61a00179e65b7a466100">ShadowCasterList</a></td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#905eb9adbd3854d84a50c08fc4937e12">createSceneNodeImpl</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclasses can override this to ensure their specialised <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> is used.  <a href="#905eb9adbd3854d84a50c08fc4937e12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f645abf4f922c75b0fd33fe2ddf784d5">createSceneNodeImpl</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclasses can override this to ensure their specialised <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> is used.  <a href="#f645abf4f922c75b0fd33fe2ddf784d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structOgre_1_1SceneManager_1_1MovableObjectCollection.html">MovableObjectCollection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0828a3d2858e75cc6dfe10ff793595a0">getMovableObjectCollection</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the movable object collection for the given type name.  <a href="#0828a3d2858e75cc6dfe10ff793595a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <br>
<a class="el" href="structOgre_1_1SceneManager_1_1MovableObjectCollection.html">MovableObjectCollection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d4983c85839779400c8ac52cb3ef724c">getMovableObjectCollection</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;typeName) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the movable object collection for the given type name.  <a href="#d4983c85839779400c8ac52cb3ef724c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#73505bfc8792209bfc3b16042d17635d">initRenderQueue</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex over the collection of <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> types.  <a href="#73505bfc8792209bfc3b16042d17635d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#29de6edd7b7dc562ad54c167c1a8d5af">deriveShadowCasterPass</a> (const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *pass)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for turning a regular pass into a shadow caster pass.  <a href="#29de6edd7b7dc562ad54c167c1a8d5af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#90a6c5e9740c233a2c32443eb4bf1345">deriveShadowReceiverPass</a> (const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *pass)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for turning a regular pass into a shadow receiver pass.  <a href="#90a6c5e9740c233a2c32443eb4bf1345"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#651906559ecf9995cd318a8855b9c228">validatePassForRendering</a> (const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *pass)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method to validate whether a <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> should be allowed to render.  <a href="#651906559ecf9995cd318a8855b9c228"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#822454b676e71d630ca2bcd19b0950d1">validateRenderableForRendering</a> (const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *pass, const <a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *rend)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method to validate whether a <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> should be allowed to render.  <a href="#822454b676e71d630ca2bcd19b0950d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1MeshPtr.html">MeshPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8b94645301bb83f4738c67407bcd9ec3">createSkyboxPlane</a> (<a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d397960">BoxPlane</a> bp, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;orientation, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classOgre_1_1MeshPtr.html">MeshPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#65f806d3666e63f14e996e3d79e508a8">createSkydomePlane</a> (<a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d397960">BoxPlane</a> bp, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> curvature, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> tiling, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> distance, const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;orientation, int xsegments, int ysegments, int ySegmentsToKeep, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0876bb333239e903dadfa46ec3f494bf">useRenderableViewProjMode</a> (const <a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *pRend)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method used by _renderSingleObject to deal with renderables which override the camera's own view / projection materices.  <a href="#0876bb333239e903dadfa46ec3f494bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a3aa4dcb44572fa36c4d20e41751cc05">resetViewProjMode</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method used by _renderSingleObject to deal with renderables which override the camera's own view / projection matrices.  <a href="#a3aa4dcb44572fa36c4d20e41751cc05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#4e8e0def255fee437b420774354f1371">fireRenderQueueStarted</a> (<a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> id, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;invocation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for firing the queue start event, returns true if queue is to be skipped.  <a href="#4e8e0def255fee437b420774354f1371"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#48c65f5fdd8d9d631889585d82fe8ab9">fireRenderQueueEnded</a> (<a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> id, const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;invocation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for firing the queue end event, returns true if queue is to be repeated.  <a href="#48c65f5fdd8d9d631889585d82fe8ab9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d5f565ed419ccb8ab372a0f708e32f68">fireShadowTexturesUpdated</a> (size_t numberOfShadowTextures)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for firing the texture shadows updated event.  <a href="#d5f565ed419ccb8ab372a0f708e32f68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d338a97ae6e0079466dcd3a94e0193bd">fireShadowTexturesPreCaster</a> (<a class="el" href="classOgre_1_1Light.html">Light</a> *light, <a class="el" href="classOgre_1_1Camera.html">Camera</a> *camera, size_t iteration)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for firing the pre caster texture shadows event.  <a href="#d338a97ae6e0079466dcd3a94e0193bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#387b7d13cc8d2cb01f70066d6f10b359">fireShadowTexturesPreReceiver</a> (<a class="el" href="classOgre_1_1Light.html">Light</a> *light, <a class="el" href="classOgre_1_1Frustum.html">Frustum</a> *f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for firing the pre receiver texture shadows event.  <a href="#387b7d13cc8d2cb01f70066d6f10b359"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#63d643fd58fb678a1eebdd1545056b6f">firePreFindVisibleObjects</a> (<a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for firing find visible objects event.  <a href="#63d643fd58fb678a1eebdd1545056b6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#71e96e9151e3d83f39917ecb1592ab8c">firePostFindVisibleObjects</a> (<a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for firing find visible objects event.  <a href="#71e96e9151e3d83f39917ecb1592ab8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#4dfb70c49bd65354acf13491890abe5e">setViewport</a> (<a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *vp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for setting the destination viewport for the next render.  <a href="#4dfb70c49bd65354acf13491890abe5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0185f535c0b92eda29fa741f533d1424">renderVisibleObjectsDefaultSequence</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for rendering all objects using the default queue sequence.  <a href="#0185f535c0b92eda29fa741f533d1424"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#5d330306c0f22caf946d1ddbf0cc2474">renderVisibleObjectsCustomSequence</a> (<a class="el" href="classOgre_1_1RenderQueueInvocationSequence.html">RenderQueueInvocationSequence</a> *s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for rendering all objects using a custom queue sequence.  <a href="#5d330306c0f22caf946d1ddbf0cc2474"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0878fb11733d9a265adc56805f6acccc">prepareRenderQueue</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for preparing the render queue for use with each render.  <a href="#0878fb11733d9a265adc56805f6acccc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#505ac650e6f3d1f025a3a4ca87bacf0a">renderSingleObject</a> (<a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *rend, const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *pass, bool lightScissoringClipping, bool doLightIteration, const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> *manualLightList=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal utility method for rendering a single object.  <a href="#505ac650e6f3d1f025a3a4ca87bacf0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classOgre_1_1AutoParamDataSource.html">AutoParamDataSource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f9654870f0601526d98af8642546b1a0">createAutoParamDataSource</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for creating the <a class="el" href="classOgre_1_1AutoParamDataSource.html" title="This utility class is used to hold the information used to generate the matrices...">AutoParamDataSource</a> instance.  <a href="#f9654870f0601526d98af8642546b1a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9b47cb96d4c8daf13ad13f2cefdfb84f">findLightsAffectingFrustum</a> (const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *camera)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for locating a list of lights which could be affecting the frustum.  <a href="#9b47cb96d4c8daf13ad13f2cefdfb84f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0127361e6d7549373cf7cb991792d45b">initShadowVolumeMaterials</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for setting up materials for shadows.  <a href="#0127361e6d7549373cf7cb991792d45b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#901dc44fa7930877825f7be4b43006cd">ensureShadowTexturesCreated</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for creating shadow textures (texture-based shadows).  <a href="#901dc44fa7930877825f7be4b43006cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ee58adae03ba713cc72c4ec59d8b1333">destroyShadowTextures</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for destroying shadow textures (texture-based shadows).  <a href="#ee58adae03ba713cc72c4ec59d8b1333"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e36765b6712df95d54fe0cc07de1a951">prepareShadowTextures</a> (<a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam, <a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *vp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for preparing shadow textures ready for use in a regular render.  <a href="#e36765b6712df95d54fe0cc07de1a951"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6b262351699ce4a35f93faa05612fb35">renderShadowVolumesToStencil</a> (const <a class="el" href="classOgre_1_1Light.html">Light</a> *light, const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam, bool calcScissor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for rendering all the objects for a given light into the stencil buffer.  <a href="#6b262351699ce4a35f93faa05612fb35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#77a1e643384ab5a2d191642a052914c8">setShadowVolumeStencilState</a> (bool secondpass, bool zfail, bool twosided)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal utility method for setting stencil state for rendering shadow volumes.  <a href="#77a1e643384ab5a2d191642a052914c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ac6e885d46b59352faf85df49e0c9973">renderShadowVolumeObjects</a> (<a class="el" href="classOgre_1_1VectorIterator.html">ShadowCaster::ShadowRenderableListIterator</a> iShadowRenderables, <a class="el" href="classOgre_1_1Pass.html">Pass</a> *pass, const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> *manualLightList, unsigned long flags, bool secondpass, bool zfail, bool twosided)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a set of shadow renderables.  <a href="#ac6e885d46b59352faf85df49e0c9973"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <br>
<a class="el" href="classOgre_1_1SceneManager.html#25fa6eff947e61a00179e65b7a466100">ShadowCasterList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#79519a81dcd7a50402859133216f00f2">findShadowCastersForLight</a> (const <a class="el" href="classOgre_1_1Light.html">Light</a> *light, const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *camera)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for locating a list of shadow casters which could be affecting the frustum for a given light.  <a href="#79519a81dcd7a50402859133216f00f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#79019a1aaa0d930b1adfe4adb491654f">renderBasicQueueGroupObjects</a> (<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *pGroup, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a group in the ordinary way.  <a href="#79019a1aaa0d930b1adfe4adb491654f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7b0f910145e18b403ffda692dc56de0a">renderAdditiveStencilShadowedQueueGroupObjects</a> (<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *group, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a group with the added complexity of additive stencil shadows.  <a href="#7b0f910145e18b403ffda692dc56de0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9347a2cc68ffb1f0f30b2c3648a9f1ab">renderModulativeStencilShadowedQueueGroupObjects</a> (<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *group, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a group with the added complexity of modulative stencil shadows.  <a href="#9347a2cc68ffb1f0f30b2c3648a9f1ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#066a00620486e3bda9a256103c08cd55">renderTextureShadowCasterQueueGroupObjects</a> (<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *group, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a group rendering only shadow casters.  <a href="#066a00620486e3bda9a256103c08cd55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2fdad5a80651ae791c322546316bdac7">renderTextureShadowReceiverQueueGroupObjects</a> (<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *group, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a group rendering only shadow receivers.  <a href="#2fdad5a80651ae791c322546316bdac7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6821367bfafa83a3c5d0ed8f0dea17f9">renderModulativeTextureShadowedQueueGroupObjects</a> (<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *group, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a group with the added complexity of modulative texture shadows.  <a href="#6821367bfafa83a3c5d0ed8f0dea17f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#900c414251c050209e24781067052ad3">renderAdditiveTextureShadowedQueueGroupObjects</a> (<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *group, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a group with additive texture shadows.  <a href="#900c414251c050209e24781067052ad3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e9e2a6c19e5d5e11951dc0cd5c158fe8">renderObjects</a> (const <a class="el" href="classOgre_1_1QueuedRenderableCollection.html">QueuedRenderableCollection</a> &amp;objs, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om, bool lightScissoringClipping, bool doLightIteration, const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> *manualLightList=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render a set of objects, see renderSingleObject for param definitions.  <a href="#e9e2a6c19e5d5e11951dc0cd5c158fe8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e588d960549fd37f66881da0c100265b">renderTransparentShadowCasterObjects</a> (const <a class="el" href="classOgre_1_1QueuedRenderableCollection.html">QueuedRenderableCollection</a> &amp;objs, <a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a> om, bool lightScissoringClipping, bool doLightIteration, const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> *manualLightList=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Render those objects in the transparent pass list which have shadow casting forced on.  <a href="#e588d960549fd37f66881da0c100265b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7a2a90e25975a2f734657cda4f8544f0">updateRenderQueueSplitOptions</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the state of the global render queue splitting based on a shadow option change.  <a href="#7a2a90e25975a2f734657cda4f8544f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b5c96c7dc84fa2292c7e5062ad123c0c">updateRenderQueueGroupSplitOptions</a> (<a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *group, bool suppressShadows, bool suppressRenderState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the state of the render queue group splitting based on a shadow option change.  <a href="#b5c96c7dc84fa2292c7e5062ad123c0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#4acd510f26a9a302753cf95b35096527">ClipResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b83baf07ebcc68e41b403f2126105f69">buildAndSetScissor</a> (const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> &amp;ll, const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up a scissor rectangle from a group of lights.  <a href="#b83baf07ebcc68e41b403f2126105f69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#03ab7a77952100672c2191f74b898f72">buildScissor</a> (const <a class="el" href="classOgre_1_1Light.html">Light</a> *l, const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *cam, <a class="el" href="structOgre_1_1TRect.html">RealRect</a> &amp;rect)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update a scissor rectangle from a single light.  <a href="#03ab7a77952100672c2191f74b898f72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e79444a2f5305caeab80b01f8d1275a3">resetScissor</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceOgre.html#4acd510f26a9a302753cf95b35096527">ClipResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#386586877ecf98bd688954e18b2a47e8">buildAndSetLightClip</a> (const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> &amp;ll)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a set of user clip planes from a single non-directional light.  <a href="#386586877ecf98bd688954e18b2a47e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b951496f7dff614730c5b59a8e9bae91">buildLightClip</a> (const <a class="el" href="classOgre_1_1Light.html">Light</a> *l, <a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a> &amp;planes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c79994f9a877fc1cd988b581cc1368f6">resetLightClip</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2ce3efd7c504bcf7c1f0699e069118c2">checkCachedLightClippingInfo</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0ff0b1a5241287f4ce969e9755079fb2">mName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instance name.  <a href="#0ff0b1a5241287f4ce969e9755079fb2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#5411ad8b9ea980057db76161e58bb3d3">mRenderQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue of objects for rendering.  <a href="#5411ad8b9ea980057db76161e58bb3d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#63e5b71e4fe7e66e1e22ef900bc04912">mLastRenderQueueInvocationCustom</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1046dbbb22cc771860703cfca3a9d06a">mAmbientLight</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current ambient light, cached for <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a>.  <a href="#1046dbbb22cc771860703cfca3a9d06a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1RenderSystem.html">RenderSystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8264f0c4e49a76667f3977acb955c7b1">mDestRenderSystem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rendering system to send the scene to.  <a href="#8264f0c4e49a76667f3977acb955c7b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#361c61a0f17ac50c8fd49bc0dd3ff622">CameraList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a7fc776f4946fdcf92c696524a4c2d4d">mCameras</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Central list of cameras - for easy memory management and lookup.  <a href="#a7fc776f4946fdcf92c696524a4c2d4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#f9c15d5bd04bde23d9a6f1de191623b4">StaticGeometryList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0973d08b56629d0116237af5b948f771">mStaticGeometryList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#2228301bdefd1eb05500e140d212771d">InstancedGeometryList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#5aa17d2f39c5e8769f0e444db659fa91">mInstancedGeometryList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#f50133e2bd9b7629687560f221289559">SceneNodeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a63f58cfe1efa7a19a2ae2227d58cabc">mSceneNodes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Central list of SceneNodes - for easy memory management.  <a href="#a63f58cfe1efa7a19a2ae2227d58cabc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9a2f86d3b64b1a0a5f722fa4e18a0207">mCameraInProgress</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOgre_1_1Camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> in progress.  <a href="#9a2f86d3b64b1a0a5f722fa4e18a0207"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d341e52c96894a27d6bcc83760386e85">mCurrentViewport</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current <a class="el" href="classOgre_1_1Viewport.html" title="An abstraction of a viewport, i.e.">Viewport</a>.  <a href="#d341e52c96894a27d6bcc83760386e85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#47dc6b93ef3b1462268e4878bd8118e6">mSceneRoot</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classOgre_1_1Root.html" title="The root class of the Ogre system.">Root</a> scene node.  <a href="#47dc6b93ef3b1462268e4878bd8118e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#14f8ae72e357eb840b335c67fd991087">AutoTrackingSceneNodes</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2496f428b7e345aeee68319ebf3848ea">mAutoTrackingSceneNodes</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Entity.html">Entity</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1b356cfd900fc11d9aab12384db846f2">mSkyPlaneEntity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Entity.html">Entity</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d119673b6459a4417ccd6b9132f6949e">mSkyDomeEntity</a> [5]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1ManualObject.html">ManualObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1632eb9454092102844767bce15d1f22">mSkyBoxObj</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a22625c805a1f0f666323afb95eae01c">mSkyPlaneNode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#21476fa21be2e1fa6e822fa173ee4031">mSkyDomeNode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9a97c216a74023a495dd4a913163c0ec">mSkyBoxNode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#743ba63a3432f88ffae6d01c7887b754">mSkyPlaneEnabled</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#856c7625cb2589f10b57ea25c25d4ff6">mSkyPlaneRenderQueue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Plane.html">Plane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#cc6d350acb01f02cbf50090451610e38">mSkyPlane</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structOgre_1_1SceneManager_1_1SkyPlaneGenParameters.html">SkyPlaneGenParameters</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6c4e525a3069ba18e984aafd7bb4166f">mSkyPlaneGenParameters</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#870b9f0b19b51dd4de3450a7b8f1dada">mSkyBoxEnabled</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c1c486c6f054ee0ad11a546787dd3c92">mSkyBoxRenderQueue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9a0a6799f6c031e3ba5e19e52e224be1">mSkyBoxOrientation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structOgre_1_1SceneManager_1_1SkyBoxGenParameters.html">SkyBoxGenParameters</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#fc3531fffee2ca7a25951a0a0a59af50">mSkyBoxGenParameters</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#6be93df7298573396205fcad20e51d80">mSkyDomeEnabled</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c5ec31ff245698c0ca5d5cb86e14b40c">mSkyDomeRenderQueue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#332c8e9c42e45503ceb067b3ebb7f469">mSkyDomeOrientation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structOgre_1_1SceneManager_1_1SkyDomeGenParameters.html">SkyDomeGenParameters</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#68bc63ccd0178ee6812cd792ac25ff1e">mSkyDomeGenParameters</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#17ed14a33b5393704f343d2c90568588">mFogMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#77a36143ecafeea94fc7a0656ffaf112">mFogColour</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d697a57bccc4fc33010c2f8151330605">mFogStart</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3af93cd3e5f38b3554d3328ceb0df312">mFogEnd</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#08ed5443cb044a3f6fb749cb90454b49">mFogDensity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#8864f70edf5d284c2be437d4d586e505">SpecialCaseRenderQueueList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#4d8e465d0733b5a86dc1935efcdc3af4">mSpecialCaseQueueList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6">SpecialCaseRenderQueueMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c23b56bba91b3582f8af00dbf8050dd5">mSpecialCaseQueueMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#eb54113eccb7f6f55e70f9319932373a">mWorldGeometryRenderQueue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a3a4b9ce9a0f555e8e52de3a8bbdf5c0">mLastFrameNumber</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#784d6dc8b5c3336f34fd78cea0d718d4">mTempXform</a> [256]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1c35d16e51f409760b8dd2766b63d647">mResetIdentityView</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#000946f678ee7508dfbc31268c5d966e">mResetIdentityProj</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d86119ced614f90d301930b1b0f19588">mNormaliseNormalsOnScale</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#fc663fea2a213f5c0800259604c84df5">mFlipCullingOnNegativeScale</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3797a6b398dda83a98ff62d9883aac9c">mPassCullingMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#99e7aa7b0f6f45e6cc750668cebf53e3">CamVisibleObjectsMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ba61fc3252c41dca8fb9a161fee093e0">mCamVisibleObjectsMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#6ce1f7a7cc475c7cf797eb3867a4a01c">ShadowCamLightMapping</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#604f8366d8b27064a4a20f48cc37dac4">mShadowCamLightMapping</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ca3a6092095443e4a5a7fb8169bcf83e">mShadowTextureCountPerType</a> [3]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array defining shadow count per light type.  <a href="#ca3a6092095443e4a5a7fb8169bcf83e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::vector&lt; size_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8f714dccdf13fcf8d9ad2d80ab55933a">mShadowTextureIndexLightList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array defining shadow texture index in light list.  <a href="#8f714dccdf13fcf8d9ad2d80ab55933a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#64adaac04645e2f83bf04862a20c5d45">mLightsAffectingFrustum</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#05443775a1f947308c5d90a24d45ed6f">LightInfoList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#da2783d02c2dcd52fb91e0409ab5ec20">mCachedLightInfos</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#05443775a1f947308c5d90a24d45ed6f">LightInfoList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#72f4d87312aee00bd2236e4ae1331b35">mTestLightInfos</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#4304981347643708ee9a7ba8884e5758">ulong</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#cd54728be554ef19ce5cdf207de09959">mLightsDirtyCounter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#5bdfdd7b221b17f4901a1c53d4011e80">MovableObjectCollectionMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8a3af0a8a5116a4a02dd3d8420078658">mMovableObjectCollectionMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#adaa9d36a795c8dad209fb4740015a30">mShadowCasterPlainBlackPass</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pass designed to let us render shadow colour on white for texture shadows.  <a href="#adaa9d36a795c8dad209fb4740015a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#593f82c978aa7ab17043dead7a24d29f">mShadowReceiverPass</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pass designed to let us render shadow receivers for texture shadows.  <a href="#593f82c978aa7ab17043dead7a24d29f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#070effc83d84478c31dc811dc92703c7">mDisplayNodes</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#260738557c9a32aed8d5ca14c28d300f">AnimationList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7c96613569926a2bbe5a359644157482">mAnimationsList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1AnimationStateSet.html">AnimationStateSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#20a4a6f6531d749b1436be1184264c0b">mAnimationStates</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#b55740025112ba1139656d035f27bb45">RenderQueueListenerList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d0c4537d20d352ad2818ec7cabcb7e7b">mRenderQueueListeners</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#9e4af19ff8fe945ba6e50dc1b71918da">ListenerList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#077722cc09750f78a8769b0ed5e5bf72">mListeners</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ecf3af703dea330078f41ab6ed016c7e">mShowBoundingBoxes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag that indicates if all of the scene node's bounding boxes should be shown as a wireframe.  <a href="#ecf3af703dea330078f41ab6ed016c7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1AutoParamDataSource.html">AutoParamDataSource</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#63d007556fe8e97a917d952494c8e3a5">mAutoParamDataSource</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class for calculating automatic parameters for gpu programs.  <a href="#63d007556fe8e97a917d952494c8e3a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#79dcd426d291c31072c1ad6f183715d6">ShadowTechnique</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7adaeed1d654ab66a2c7fff4c03a431e">mShadowTechnique</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#54cbafb5e6dcc0e9f324d3898cead7ef">mDebugShadows</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f888882852ac5512310c18017e7921e5">mShadowColour</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9276e06185787c851f1ff54a152f28ad">mShadowDebugPass</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#97eb70f23035e4cf0f75aadd11850b57">mShadowStencilPass</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a14524c82d79c3e76942b0fd6dac3ac3">mShadowModulativePass</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#63c239863d9a55286a5cb7a024793659">mShadowMaterialInitDone</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1HardwareIndexBufferSharedPtr.html">HardwareIndexBufferSharedPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#63697c1137a52b5e02035b66b6de9874">mShadowIndexBuffer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#7475f0391505adff66471a7d8b0a4da8">mShadowIndexBufferSize</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Rectangle2D.html">Rectangle2D</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#dd5db2bd810b8c5565afa345de0e0dfb">mFullScreenQuad</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#45946d6a943570d2d7ac0a803a75c77e">mShadowDirLightExtrudeDist</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#51db39cc4fa15b28086a1793d42fc827">IlluminationRenderStage</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#fcdad5f25f6c3956c11a824fba5d68ec">mIlluminationStage</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#498ca415d30ec282949ce7dce9d1db69">ShadowTextureConfigList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#76f9b63473b07dd34092f46f79f88e54">mShadowTextureConfigList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a893151c589403e0c043d8edf6d67448">mShadowTextureConfigDirty</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#b5efceec9e1a6e88e156564c15e86f6a">ShadowTextureList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#eee75145f20f44d4bcdeba9d1884a13b">mShadowTextures</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1TexturePtr.html">TexturePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#67ade0caa6fe5a91ad14e2d79c294bb8">mNullShadowTexture</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#19a90448272159c7f2e2c7573b181151">ShadowTextureCameraList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#5a89503b16636ebf9a99605b707b2d9d">mShadowTextureCameras</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Texture.html">Texture</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a14bcf591faa2d30fefc0fcb7c5857c4">mCurrentShadowTexture</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e71bff7c7babb2f8a92346427d8c5fa1">mShadowUseInfiniteFarPlane</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#3159f28f48646517418ce319b9b7dec8">mShadowCasterRenderBackFaces</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#933194ab15d699b1be5142ae705a010e">mShadowAdditiveLightClip</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#c2e1d3390dfc6b3d58fdb934d75ce760">LightClippingInfoMap</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#9c12c8a290ce0ea51efef380760f27c8">mLightClippingInfoMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#c7fe720c6553bf245b058b9f5281b220">mLightClippingInfoMapFrameNumber</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SharedPtr.html">ShadowCameraSetupPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ed1f03f6ccf8735715458aae3cd720ec">mDefaultShadowCameraSetup</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default shadow camera setup  <a href="#ed1f03f6ccf8735715458aae3cd720ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager.html#25fa6eff947e61a00179e65b7a466100">ShadowCasterList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e6d775195f3f8831650e4baaebf89433">mShadowCasterList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SphereSceneQuery.html">SphereSceneQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f0e984eaa8115c9753bcd84b4bd3cc11">mShadowCasterSphereQuery</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1AxisAlignedBoxSceneQuery.html">AxisAlignedBoxSceneQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#1c6f6e1290244f6d0dd1347d8ce3453b">mShadowCasterAABBQuery</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#155f9c139734d33fc7d9f03c6364cc4c">mDefaultShadowFarDist</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#fd8165b0623ae10088f400f8a9d5b592">mDefaultShadowFarDistSquared</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0fd0fee334159816771d34a2a03e1abe">mShadowTextureOffset</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2f270a0f22844b6690c835c80ab51145">mShadowTextureFadeStart</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8fc134ed20d116daefa494b06554b7c8">mShadowTextureFadeEnd</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2d366a01e2b7fea9e7eae781a25268a6">mShadowTextureSelfShadow</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0ea1617bdda02c23a72330a647ea09a0">mShadowTextureCustomCasterPass</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#8ea12599e955972ac959ef94c52e35af">mShadowTextureCustomReceiverPass</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#12145dec119385784c27245b380ddc5a">mShadowTextureCustomCasterVertexProgram</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#cc8a7c17bedf51c442ed02ed23ef30e3">mShadowTextureCustomReceiverVertexProgram</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b6c7dec2b7a7d8122ae3784e56e59918">mShadowTextureCustomReceiverFragmentProgram</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#dcadb2b43a58490f9975ac44b553eedd">mShadowTextureCustomCasterVPParams</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#e12d0d35465b9395c984263db68ab752">mShadowTextureCustomReceiverVPParams</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#67563d09f914c80b7c007f08433b9e23">mShadowTextureCustomReceiverFPParams</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#f330714bd5a60cf8fcdcb8998ae88fc3">mVisibilityMask</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visibility mask used to show / hide objects.  <a href="#f330714bd5a60cf8fcdcb8998ae88fc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#d2a6d7cc9535ac69dc7e445b1cead58e">mFindVisibleObjects</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#2f08653c064e776174c4881148f6e1ec">mSuppressRenderStateChanges</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suppress render state changes?  <a href="#2f08653c064e776174c4881148f6e1ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#0220be54b3b9c8be805be65e60f136d0">mSuppressShadows</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suppress shadows?  <a href="#0220be54b3b9c8be805be65e60f136d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#a1886fd36b6128c7714ec1508f45821f">mInfiniteExtrusionParams</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#b90bf0fcf5aa2c3597a811863ed0d274">mFiniteExtrusionParams</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager_1_1ShadowCasterSceneQueryListener.html">ShadowCasterSceneQueryListener</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#35ebd62722964590cef05e5d0eb236f2">mShadowCasterQueryListener</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#585632a1f5cff9ab48205a7503ff1e69">mActiveQueuedRenderableVisitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The active renderable visitor class - subclasses could override this.  <a href="#585632a1f5cff9ab48205a7503ff1e69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#ed9fbb65aff18fd3b1659f68c32bcef4">mDefaultQueuedRenderableVisitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Storage for default renderable visitor.  <a href="#ed9fbb65aff18fd3b1659f68c32bcef4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#dc88adbe55e6569c9b4d6b0e249a28df">mCameraRelativeRendering</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether to use camera-relative rendering.  <a href="#dc88adbe55e6569c9b4d6b0e249a28df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#44e222e6fe97d76b98f031b72c9c2d7a">mCachedViewMatrix</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#54d12f1b064fdf8bf735f5fcfc95134a">mCameraRelativePosition</a></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager.html#25811fa0c23672b27dccfffd48bec43a">SceneMgrQueuedRenderableVisitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow visitor helper to access protected methods.  <a href="#25811fa0c23672b27dccfffd48bec43a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1SceneManager_1_1LightClippingInfo.html">LightClippingInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct for cacheing light clipping information for re-use in a frame.  <a href="structOgre_1_1SceneManager_1_1LightClippingInfo.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1SceneManager_1_1LightInfo.html">LightInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cached light information, used to tracking light's changes.  <a href="structOgre_1_1SceneManager_1_1LightInfo.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1SceneManager_1_1lightLess.html">lightLess</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparator for sorting lights relative to a point.  <a href="structOgre_1_1SceneManager_1_1lightLess.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1SceneManager_1_1lightsForShadowTextureLess.html">lightsForShadowTextureLess</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default sorting routine which sorts lights which cast shadows to the front of a list, sub-sorting by distance.  <a href="structOgre_1_1SceneManager_1_1lightsForShadowTextureLess.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager_1_1Listener.html">Listener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that allows listening in on the various stages of <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> processing, so that custom behaviour can be implemented from outside.  <a href="classOgre_1_1SceneManager_1_1Listener.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1SceneManager_1_1materialLess.html">materialLess</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparator for material map, for sorting materials into render order (e.g.  <a href="structOgre_1_1SceneManager_1_1materialLess.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1SceneManager_1_1MovableObjectCollection.html">MovableObjectCollection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple structure to hold <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> map and a mutex to go with it.  <a href="structOgre_1_1SceneManager_1_1MovableObjectCollection.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inner helper class to implement the visitor pattern for rendering objects in a queue.  <a href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1SceneManager_1_1ShadowCasterSceneQueryListener.html">ShadowCasterSceneQueryListener</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inner class to use as callback for shadow caster scene query.  <a href="classOgre_1_1SceneManager_1_1ShadowCasterSceneQueryListener.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1SceneManager_1_1SkyBoxGenParameters.html">SkyBoxGenParameters</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1SceneManager_1_1SkyDomeGenParameters.html">SkyDomeGenParameters</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1SceneManager_1_1SkyPlaneGenParameters.html">SkyPlaneGenParameters</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Manages the organisation and rendering of a 'scene' i.e. 
<p>
a collection of objects and potentially world geometry. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This class defines the interface and the basic behaviour of a 'Scene Manager'. A <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> organises the culling and rendering of the scene, in conjunction with the <a class="el" href="classOgre_1_1RenderQueue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a>. This class is designed to be extended through subclassing in order to provide more specialised scene organisation structures for particular needs. The default <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> culls based on a hierarchy of node bounding boxes, other implementations can use an octree (</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>OctreeSceneManager), a BSP tree (<p>
BspSceneManager), and many other options. New <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementations can be added at runtime by plugins, see <a class="el" href="classOgre_1_1SceneManagerEnumerator.html" title="Enumerates the SceneManager classes available to applications.">SceneManagerEnumerator</a> for the interfaces for adding new <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> types. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>There is a distinction between 'objects' (which subclass <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>, and are movable, discrete objects in the world), and 'world geometry', which is large, generally static geometry. World geometry tends to influence the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> organisational structure (e.g. lots of indoor static geometry might result in a spatial tree structure) and as such world geometry is generally tied to a given <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> implementation, whilst <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> instances can be used with any <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. Subclasses are free to define world geometry however they please. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Multiple <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> instances can exist at one time, each one with a distinct scene. Which <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> is used to render a scene is dependent on the <a class="el" href="classOgre_1_1Camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a>, which will always call back the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> which created it to render the scene. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00141">141</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="361c61a0f17ac50c8fd49bc0dd3ff622"></a><!-- doxytag: member="Ogre::SceneManager::CameraList" ref="361c61a0f17ac50c8fd49bc0dd3ff622" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1Camera.html">Camera</a>* &gt; <a class="el" href="classOgre_1_1SceneManager.html#361c61a0f17ac50c8fd49bc0dd3ff622">Ogre::SceneManager::CameraList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00345">345</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f9c15d5bd04bde23d9a6f1de191623b4"></a><!-- doxytag: member="Ogre::SceneManager::StaticGeometryList" ref="f9c15d5bd04bde23d9a6f1de191623b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1StaticGeometry.html">StaticGeometry</a>* &gt; <a class="el" href="classOgre_1_1SceneManager.html#f9c15d5bd04bde23d9a6f1de191623b4">Ogre::SceneManager::StaticGeometryList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00351">351</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2228301bdefd1eb05500e140d212771d"></a><!-- doxytag: member="Ogre::SceneManager::InstancedGeometryList" ref="2228301bdefd1eb05500e140d212771d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1InstancedGeometry.html">InstancedGeometry</a>* &gt; <a class="el" href="classOgre_1_1SceneManager.html#2228301bdefd1eb05500e140d212771d">Ogre::SceneManager::InstancedGeometryList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00353">353</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f50133e2bd9b7629687560f221289559"></a><!-- doxytag: member="Ogre::SceneManager::SceneNodeList" ref="f50133e2bd9b7629687560f221289559" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>*&gt; <a class="el" href="classOgre_1_1SceneManager.html#f50133e2bd9b7629687560f221289559">Ogre::SceneManager::SceneNodeList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00356">356</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="14f8ae72e357eb840b335c67fd991087"></a><!-- doxytag: member="Ogre::SceneManager::AutoTrackingSceneNodes" ref="14f8ae72e357eb840b335c67fd991087" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>*&gt; <a class="el" href="classOgre_1_1SceneManager.html#14f8ae72e357eb840b335c67fd991087">Ogre::SceneManager::AutoTrackingSceneNodes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Autotracking scene nodes. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00375">375</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8864f70edf5d284c2be437d4d586e505"></a><!-- doxytag: member="Ogre::SceneManager::SpecialCaseRenderQueueList" ref="8864f70edf5d284c2be437d4d586e505" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&gt; <a class="el" href="classOgre_1_1SceneManager.html#8864f70edf5d284c2be437d4d586e505">Ogre::SceneManager::SpecialCaseRenderQueueList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00411">411</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="99e7aa7b0f6f45e6cc750668cebf53e3"></a><!-- doxytag: member="Ogre::SceneManager::CamVisibleObjectsMap" ref="99e7aa7b0f6f45e6cc750668cebf53e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt; const <a class="el" href="classOgre_1_1Camera.html">Camera</a>*, <a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a>&gt; <a class="el" href="classOgre_1_1SceneManager.html#99e7aa7b0f6f45e6cc750668cebf53e3">Ogre::SceneManager::CamVisibleObjectsMap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Visible objects bounding box list. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Holds an ABB for each camera that contains the physical extends of the visible scene elements by each camera. The map is crucial for shadow algorithms which have a focus step to limit the shadow sample distribution to only valid visible scene elements. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00434">434</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6ce1f7a7cc475c7cf797eb3867a4a01c"></a><!-- doxytag: member="Ogre::SceneManager::ShadowCamLightMapping" ref="6ce1f7a7cc475c7cf797eb3867a4a01c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt; const <a class="el" href="classOgre_1_1Camera.html">Camera</a>*, const <a class="el" href="classOgre_1_1Light.html">Light</a>* &gt; <a class="el" href="classOgre_1_1SceneManager.html#6ce1f7a7cc475c7cf797eb3867a4a01c">Ogre::SceneManager::ShadowCamLightMapping</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ShadowCamera to light mapping. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00438">438</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="05443775a1f947308c5d90a24d45ed6f"></a><!-- doxytag: member="Ogre::SceneManager::LightInfoList" ref="05443775a1f947308c5d90a24d45ed6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structOgre_1_1SceneManager_1_1LightInfo.html">LightInfo</a>&gt; <a class="el" href="classOgre_1_1SceneManager.html#05443775a1f947308c5d90a24d45ed6f">Ogre::SceneManager::LightInfoList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00467">467</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="317d0ca0b29d739ed54b4422f850b629"></a><!-- doxytag: member="Ogre::SceneManager::MovableObjectMap" ref="317d0ca0b29d739ed54b4422f850b629" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>*&gt; <a class="el" href="classOgre_1_1SceneManager.html#317d0ca0b29d739ed54b4422f850b629">Ogre::SceneManager::MovableObjectMap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00474">474</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5bdfdd7b221b17f4901a1c53d4011e80"></a><!-- doxytag: member="Ogre::SceneManager::MovableObjectCollectionMap" ref="5bdfdd7b221b17f4901a1c53d4011e80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="structOgre_1_1SceneManager_1_1MovableObjectCollection.html">MovableObjectCollection</a>*&gt; <a class="el" href="classOgre_1_1SceneManager.html#5bdfdd7b221b17f4901a1c53d4011e80">Ogre::SceneManager::MovableObjectCollectionMap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00481">481</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="260738557c9a32aed8d5ca14c28d300f"></a><!-- doxytag: member="Ogre::SceneManager::AnimationList" ref="260738557c9a32aed8d5ca14c28d300f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>, <a class="el" href="classOgre_1_1Animation.html">Animation</a>*&gt; <a class="el" href="classOgre_1_1SceneManager.html#260738557c9a32aed8d5ca14c28d300f">Ogre::SceneManager::AnimationList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Storage of animations, lookup by name. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00572">572</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b55740025112ba1139656d035f27bb45"></a><!-- doxytag: member="Ogre::SceneManager::RenderQueueListenerList" ref="b55740025112ba1139656d035f27bb45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classOgre_1_1RenderQueueListener.html">RenderQueueListener</a>*&gt; <a class="el" href="classOgre_1_1SceneManager.html#b55740025112ba1139656d035f27bb45">Ogre::SceneManager::RenderQueueListenerList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00586">586</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9e4af19ff8fe945ba6e50dc1b71918da"></a><!-- doxytag: member="Ogre::SceneManager::ListenerList" ref="9e4af19ff8fe945ba6e50dc1b71918da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classOgre_1_1SceneManager_1_1Listener.html">Listener</a>*&gt; <a class="el" href="classOgre_1_1SceneManager.html#9e4af19ff8fe945ba6e50dc1b71918da">Ogre::SceneManager::ListenerList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00589">589</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="19a90448272159c7f2e2c7573b181151"></a><!-- doxytag: member="Ogre::SceneManager::ShadowTextureCameraList" ref="19a90448272159c7f2e2c7573b181151" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classOgre_1_1Camera.html">Camera</a>*&gt; <a class="el" href="classOgre_1_1SceneManager.html#19a90448272159c7f2e2c7573b181151">Ogre::SceneManager::ShadowTextureCameraList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00663">663</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c2e1d3390dfc6b3d58fdb934d75ce760"></a><!-- doxytag: member="Ogre::SceneManager::LightClippingInfoMap" ref="c2e1d3390dfc6b3d58fdb934d75ce760" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="classOgre_1_1Light.html">Light</a>*, <a class="el" href="structOgre_1_1SceneManager_1_1LightClippingInfo.html">LightClippingInfo</a>&gt; <a class="el" href="classOgre_1_1SceneManager.html#c2e1d3390dfc6b3d58fdb934d75ce760">Ogre::SceneManager::LightClippingInfoMap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00679">679</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="25fa6eff947e61a00179e65b7a466100"></a><!-- doxytag: member="Ogre::SceneManager::ShadowCasterList" ref="25fa6eff947e61a00179e65b7a466100" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classOgre_1_1ShadowCaster.html">ShadowCaster</a>*&gt; <a class="el" href="classOgre_1_1SceneManager.html#25fa6eff947e61a00179e65b7a466100">Ogre::SceneManager::ShadowCasterList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00735">735</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="22fcb8a9ddb7efe79d053a975a685111"></a><!-- doxytag: member="Ogre::SceneManager::CameraIterator" ref="22fcb8a9ddb7efe79d053a975a685111" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt;<a class="el" href="classOgre_1_1SceneManager.html#361c61a0f17ac50c8fd49bc0dd3ff622">CameraList</a>&gt; <a class="el" href="classOgre_1_1MapIterator.html">Ogre::SceneManager::CameraIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02379">2379</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3a720414f68274bb9c5026911e27135d"></a><!-- doxytag: member="Ogre::SceneManager::AnimationIterator" ref="3a720414f68274bb9c5026911e27135d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt;<a class="el" href="classOgre_1_1SceneManager.html#260738557c9a32aed8d5ca14c28d300f">AnimationList</a>&gt; <a class="el" href="classOgre_1_1MapIterator.html">Ogre::SceneManager::AnimationIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02380">2380</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4249682ae2a69255ed225383d930aec1"></a><!-- doxytag: member="Ogre::SceneManager::MovableObjectIterator" ref="4249682ae2a69255ed225383d930aec1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1MapIterator.html">MapIterator</a>&lt;<a class="el" href="classOgre_1_1SceneManager.html#317d0ca0b29d739ed54b4422f850b629">MovableObjectMap</a>&gt; <a class="el" href="classOgre_1_1MapIterator.html">Ogre::SceneManager::MovableObjectIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02885">2885</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="51db39cc4fa15b28086a1793d42fc827"></a><!-- doxytag: member="Ogre::SceneManager::IlluminationRenderStage" ref="51db39cc4fa15b28086a1793d42fc827" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOgre_1_1SceneManager.html#51db39cc4fa15b28086a1793d42fc827">Ogre::SceneManager::IlluminationRenderStage</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Describes the stage of rendering when performing complex illumination. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="51db39cc4fa15b28086a1793d42fc8278fd3e7fb8fab382a9d29e6e081ae556a"></a><!-- doxytag: member="IRS_NONE" ref="51db39cc4fa15b28086a1793d42fc8278fd3e7fb8fab382a9d29e6e081ae556a" args="" -->IRS_NONE</em>&nbsp;</td><td>
No special illumination stage. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="51db39cc4fa15b28086a1793d42fc8278f99da7404ae8c16199dde8d34367b1a"></a><!-- doxytag: member="IRS_RENDER_TO_TEXTURE" ref="51db39cc4fa15b28086a1793d42fc8278f99da7404ae8c16199dde8d34367b1a" args="" -->IRS_RENDER_TO_TEXTURE</em>&nbsp;</td><td>
Render to texture stage, used for texture based shadows. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="51db39cc4fa15b28086a1793d42fc8270e1792a8ff0d3d19f121818e7028e846"></a><!-- doxytag: member="IRS_RENDER_RECEIVER_PASS" ref="51db39cc4fa15b28086a1793d42fc8270e1792a8ff0d3d19f121818e7028e846" args="" -->IRS_RENDER_RECEIVER_PASS</em>&nbsp;</td><td>
Render from shadow texture to receivers stage. </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00171">171</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6aa3039230bf91b09b8587dba0c482c6"></a><!-- doxytag: member="Ogre::SceneManager::SpecialCaseRenderQueueMode" ref="6aa3039230bf91b09b8587dba0c482c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6">Ogre::SceneManager::SpecialCaseRenderQueueMode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration of the possible modes allowed for processing the special case render queue list. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#10753c0e57be813e135395e3a882777a" title="Sets the way the special case render queue list is processed.">SceneManager::setSpecialCaseRenderQueueMode</a> </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="6aa3039230bf91b09b8587dba0c482c64f5291417680ce7d1715b7aef50869a7"></a><!-- doxytag: member="SCRQM_INCLUDE" ref="6aa3039230bf91b09b8587dba0c482c64f5291417680ce7d1715b7aef50869a7" args="" -->SCRQM_INCLUDE</em>&nbsp;</td><td>
Render only the queues in the special case list. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="6aa3039230bf91b09b8587dba0c482c6cc6b7e38cc21cf87a29e17177dc1a0b3"></a><!-- doxytag: member="SCRQM_EXCLUDE" ref="6aa3039230bf91b09b8587dba0c482c6cc6b7e38cc21cf87a29e17177dc1a0b3" args="" -->SCRQM_EXCLUDE</em>&nbsp;</td><td>
Render all except the queues in the special case list. </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00185">185</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5ff1f0a66a642f96927361029d397960"></a><!-- doxytag: member="Ogre::SceneManager::BoxPlane" ref="5ff1f0a66a642f96927361029d397960" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d397960">Ogre::SceneManager::BoxPlane</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="5ff1f0a66a642f96927361029d397960ad0dc80ea2675cc30bca626042fa78c4"></a><!-- doxytag: member="BP_FRONT" ref="5ff1f0a66a642f96927361029d397960ad0dc80ea2675cc30bca626042fa78c4" args="" -->BP_FRONT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="5ff1f0a66a642f96927361029d397960cfc07f1de74ca1a396f1d82a2d1c9c5e"></a><!-- doxytag: member="BP_BACK" ref="5ff1f0a66a642f96927361029d397960cfc07f1de74ca1a396f1d82a2d1c9c5e" args="" -->BP_BACK</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="5ff1f0a66a642f96927361029d39796009545bd5ad791db9589669756be1a280"></a><!-- doxytag: member="BP_LEFT" ref="5ff1f0a66a642f96927361029d39796009545bd5ad791db9589669756be1a280" args="" -->BP_LEFT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="5ff1f0a66a642f96927361029d39796061400b6126b1da4e3ceaade1f1db7b56"></a><!-- doxytag: member="BP_RIGHT" ref="5ff1f0a66a642f96927361029d39796061400b6126b1da4e3ceaade1f1db7b56" args="" -->BP_RIGHT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="5ff1f0a66a642f96927361029d3979604547263fba7fb6507a3ea251f72d8f14"></a><!-- doxytag: member="BP_UP" ref="5ff1f0a66a642f96927361029d3979604547263fba7fb6507a3ea251f72d8f14" args="" -->BP_UP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="5ff1f0a66a642f96927361029d39796070e022fc77f94d5144db297d00effd67"></a><!-- doxytag: member="BP_DOWN" ref="5ff1f0a66a642f96927361029d39796070e022fc77f94d5144db297d00effd67" args="" -->BP_DOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00541">541</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b4c2ff4f6c76f7fe0a8eae76f2a84cbf"></a><!-- doxytag: member="Ogre::SceneManager::PrefabType" ref="b4c2ff4f6c76f7fe0a8eae76f2a84cbf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOgre_1_1SceneManager.html#b4c2ff4f6c76f7fe0a8eae76f2a84cbf">Ogre::SceneManager::PrefabType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prefab shapes available without loading a model. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Minimal implementation at present. </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="b4c2ff4f6c76f7fe0a8eae76f2a84cbff0fb654fb98508a564c17d3d5b2feee3"></a><!-- doxytag: member="PT_PLANE" ref="b4c2ff4f6c76f7fe0a8eae76f2a84cbff0fb654fb98508a564c17d3d5b2feee3" args="" -->PT_PLANE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="b4c2ff4f6c76f7fe0a8eae76f2a84cbf25b0181d24b783ab75da2520305d292a"></a><!-- doxytag: member="PT_CUBE" ref="b4c2ff4f6c76f7fe0a8eae76f2a84cbf25b0181d24b783ab75da2520305d292a" args="" -->PT_CUBE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="b4c2ff4f6c76f7fe0a8eae76f2a84cbf0f94148c2cfe190f3ea04374af220eba"></a><!-- doxytag: member="PT_SPHERE" ref="b4c2ff4f6c76f7fe0a8eae76f2a84cbf0f94148c2cfe190f3ea04374af220eba" args="" -->PT_SPHERE</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01193">1193</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="09e76a674bc69c610fb49acd3da76cf1"></a><!-- doxytag: member="Ogre::SceneManager::SceneManager" ref="09e76a674bc69c610fb49acd3da76cf1" args="(const String &amp;instanceName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::SceneManager::SceneManager           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>instanceName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="6c8b9108b44339a321bc69b25a0c0a1a"></a><!-- doxytag: member="Ogre::SceneManager::~SceneManager" ref="6c8b9108b44339a321bc69b25a0c0a1a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::SceneManager::~SceneManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default destructor. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="905eb9adbd3854d84a50c08fc4937e12"></a><!-- doxytag: member="Ogre::SceneManager::createSceneNodeImpl" ref="905eb9adbd3854d84a50c08fc4937e12" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneManager::createSceneNodeImpl           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subclasses can override this to ensure their specialised <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> is used. 
<p>

</div>
</div><p>
<a class="anchor" name="f645abf4f922c75b0fd33fe2ddf784d5"></a><!-- doxytag: member="Ogre::SceneManager::createSceneNodeImpl" ref="f645abf4f922c75b0fd33fe2ddf784d5" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneManager::createSceneNodeImpl           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Subclasses can override this to ensure their specialised <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> is used. 
<p>

</div>
</div><p>
<a class="anchor" name="0828a3d2858e75cc6dfe10ff793595a0"></a><!-- doxytag: member="Ogre::SceneManager::getMovableObjectCollection" ref="0828a3d2858e75cc6dfe10ff793595a0" args="(const String &amp;typeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOgre_1_1SceneManager_1_1MovableObjectCollection.html">MovableObjectCollection</a>* Ogre::SceneManager::getMovableObjectCollection           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the movable object collection for the given type name. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method create new collection if the collection does not exist. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4983c85839779400c8ac52cb3ef724c"></a><!-- doxytag: member="Ogre::SceneManager::getMovableObjectCollection" ref="d4983c85839779400c8ac52cb3ef724c" args="(const String &amp;typeName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structOgre_1_1SceneManager_1_1MovableObjectCollection.html">MovableObjectCollection</a>* Ogre::SceneManager::getMovableObjectCollection           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the movable object collection for the given type name. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method throw exception if the collection does not exist. </dd></dl>

</div>
</div><p>
<a class="anchor" name="73505bfc8792209bfc3b16042d17635d"></a><!-- doxytag: member="Ogre::SceneManager::initRenderQueue" ref="73505bfc8792209bfc3b16042d17635d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::initRenderQueue           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mutex over the collection of <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> types. 
<p>
Internal method for initialising the render queue. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Subclasses can use this to install their own <a class="el" href="classOgre_1_1RenderQueue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a> implementation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29de6edd7b7dc562ad54c167c1a8d5af"></a><!-- doxytag: member="Ogre::SceneManager::deriveShadowCasterPass" ref="29de6edd7b7dc562ad54c167c1a8d5af" args="(const Pass *pass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Pass.html">Pass</a>* Ogre::SceneManager::deriveShadowCasterPass           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td>
          <td class="paramname"> <em>pass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for turning a regular pass into a shadow caster pass. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This is only used for texture shadows, basically we're trying to ensure that objects are rendered solid black. This method will usually return the standard solid black pass for all fixed function passes, but will merge in a vertex program and fudge the AutpoParamDataSource to set black lighting for passes with vertex programs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="90a6c5e9740c233a2c32443eb4bf1345"></a><!-- doxytag: member="Ogre::SceneManager::deriveShadowReceiverPass" ref="90a6c5e9740c233a2c32443eb4bf1345" args="(const Pass *pass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Pass.html">Pass</a>* Ogre::SceneManager::deriveShadowReceiverPass           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td>
          <td class="paramname"> <em>pass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for turning a regular pass into a shadow receiver pass. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This is only used for texture shadows, basically we're trying to ensure that objects are rendered with a projective texture. This method will usually return a standard single-texture pass for all fixed function passes, but will merge in a vertex program for passes with vertex programs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="651906559ecf9995cd318a8855b9c228"></a><!-- doxytag: member="Ogre::SceneManager::validatePassForRendering" ref="651906559ecf9995cd318a8855b9c228" args="(const Pass *pass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::validatePassForRendering           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td>
          <td class="paramname"> <em>pass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method to validate whether a <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> should be allowed to render. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Called just before a pass is about to be used for rendering a group to allow the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> to omit it if required. A return value of false skips this pass. </dd></dl>

</div>
</div><p>
<a class="anchor" name="822454b676e71d630ca2bcd19b0950d1"></a><!-- doxytag: member="Ogre::SceneManager::validateRenderableForRendering" ref="822454b676e71d630ca2bcd19b0950d1" args="(const Pass *pass, const Renderable *rend)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::validateRenderableForRendering           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td>
          <td class="paramname"> <em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&nbsp;</td>
          <td class="paramname"> <em>rend</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method to validate whether a <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> should be allowed to render. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Called just before a pass is about to be used for rendering a <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to allow the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> to omit it if required. A return value of false skips it. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b94645301bb83f4738c67407bcd9ec3"></a><!-- doxytag: member="Ogre::SceneManager::createSkyboxPlane" ref="8b94645301bb83f4738c67407bcd9ec3" args="(BoxPlane bp, Real distance, const Quaternion &amp;orientation, const String &amp;groupName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MeshPtr.html">MeshPtr</a> Ogre::SceneManager::createSkyboxPlane           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d397960">BoxPlane</a>&nbsp;</td>
          <td class="paramname"> <em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="65f806d3666e63f14e996e3d79e508a8"></a><!-- doxytag: member="Ogre::SceneManager::createSkydomePlane" ref="65f806d3666e63f14e996e3d79e508a8" args="(BoxPlane bp, Real curvature, Real tiling, Real distance, const Quaternion &amp;orientation, int xsegments, int ysegments, int ySegmentsToKeep, const String &amp;groupName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MeshPtr.html">MeshPtr</a> Ogre::SceneManager::createSkydomePlane           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneManager.html#5ff1f0a66a642f96927361029d397960">BoxPlane</a>&nbsp;</td>
          <td class="paramname"> <em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>curvature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>tiling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>xsegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ysegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ySegmentsToKeep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0876bb333239e903dadfa46ec3f494bf"></a><!-- doxytag: member="Ogre::SceneManager::useRenderableViewProjMode" ref="0876bb333239e903dadfa46ec3f494bf" args="(const Renderable *pRend)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::useRenderableViewProjMode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&nbsp;</td>
          <td class="paramname"> <em>pRend</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method used by _renderSingleObject to deal with renderables which override the camera's own view / projection materices. 
<p>

</div>
</div><p>
<a class="anchor" name="a3aa4dcb44572fa36c4d20e41751cc05"></a><!-- doxytag: member="Ogre::SceneManager::resetViewProjMode" ref="a3aa4dcb44572fa36c4d20e41751cc05" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::resetViewProjMode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method used by _renderSingleObject to deal with renderables which override the camera's own view / projection matrices. 
<p>

</div>
</div><p>
<a class="anchor" name="4e8e0def255fee437b420774354f1371"></a><!-- doxytag: member="Ogre::SceneManager::fireRenderQueueStarted" ref="4e8e0def255fee437b420774354f1371" args="(uint8 id, const String &amp;invocation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::fireRenderQueueStarted           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>invocation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for firing the queue start event, returns true if queue is to be skipped. 
<p>

</div>
</div><p>
<a class="anchor" name="48c65f5fdd8d9d631889585d82fe8ab9"></a><!-- doxytag: member="Ogre::SceneManager::fireRenderQueueEnded" ref="48c65f5fdd8d9d631889585d82fe8ab9" args="(uint8 id, const String &amp;invocation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::fireRenderQueueEnded           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>invocation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for firing the queue end event, returns true if queue is to be repeated. 
<p>

</div>
</div><p>
<a class="anchor" name="d5f565ed419ccb8ab372a0f708e32f68"></a><!-- doxytag: member="Ogre::SceneManager::fireShadowTexturesUpdated" ref="d5f565ed419ccb8ab372a0f708e32f68" args="(size_t numberOfShadowTextures)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::fireShadowTexturesUpdated           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numberOfShadowTextures</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for firing the texture shadows updated event. 
<p>

</div>
</div><p>
<a class="anchor" name="d338a97ae6e0079466dcd3a94e0193bd"></a><!-- doxytag: member="Ogre::SceneManager::fireShadowTexturesPreCaster" ref="d338a97ae6e0079466dcd3a94e0193bd" args="(Light *light, Camera *camera, size_t iteration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::fireShadowTexturesPreCaster           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for firing the pre caster texture shadows event. 
<p>

</div>
</div><p>
<a class="anchor" name="387b7d13cc8d2cb01f70066d6f10b359"></a><!-- doxytag: member="Ogre::SceneManager::fireShadowTexturesPreReceiver" ref="387b7d13cc8d2cb01f70066d6f10b359" args="(Light *light, Frustum *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::fireShadowTexturesPreReceiver           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Frustum.html">Frustum</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for firing the pre receiver texture shadows event. 
<p>

</div>
</div><p>
<a class="anchor" name="63d643fd58fb678a1eebdd1545056b6f"></a><!-- doxytag: member="Ogre::SceneManager::firePreFindVisibleObjects" ref="63d643fd58fb678a1eebdd1545056b6f" args="(Viewport *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::firePreFindVisibleObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for firing find visible objects event. 
<p>

</div>
</div><p>
<a class="anchor" name="71e96e9151e3d83f39917ecb1592ab8c"></a><!-- doxytag: member="Ogre::SceneManager::firePostFindVisibleObjects" ref="71e96e9151e3d83f39917ecb1592ab8c" args="(Viewport *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::firePostFindVisibleObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for firing find visible objects event. 
<p>

</div>
</div><p>
<a class="anchor" name="4dfb70c49bd65354acf13491890abe5e"></a><!-- doxytag: member="Ogre::SceneManager::setViewport" ref="4dfb70c49bd65354acf13491890abe5e" args="(Viewport *vp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setViewport           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td>
          <td class="paramname"> <em>vp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for setting the destination viewport for the next render. 
<p>

</div>
</div><p>
<a class="anchor" name="0185f535c0b92eda29fa741f533d1424"></a><!-- doxytag: member="Ogre::SceneManager::renderVisibleObjectsDefaultSequence" ref="0185f535c0b92eda29fa741f533d1424" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderVisibleObjectsDefaultSequence           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for rendering all objects using the default queue sequence. 
<p>

</div>
</div><p>
<a class="anchor" name="5d330306c0f22caf946d1ddbf0cc2474"></a><!-- doxytag: member="Ogre::SceneManager::renderVisibleObjectsCustomSequence" ref="5d330306c0f22caf946d1ddbf0cc2474" args="(RenderQueueInvocationSequence *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderVisibleObjectsCustomSequence           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueInvocationSequence.html">RenderQueueInvocationSequence</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for rendering all objects using a custom queue sequence. 
<p>

</div>
</div><p>
<a class="anchor" name="0878fb11733d9a265adc56805f6acccc"></a><!-- doxytag: member="Ogre::SceneManager::prepareRenderQueue" ref="0878fb11733d9a265adc56805f6acccc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::prepareRenderQueue           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for preparing the render queue for use with each render. 
<p>

</div>
</div><p>
<a class="anchor" name="505ac650e6f3d1f025a3a4ca87bacf0a"></a><!-- doxytag: member="Ogre::SceneManager::renderSingleObject" ref="505ac650e6f3d1f025a3a4ca87bacf0a" args="(Renderable *rend, const Pass *pass, bool lightScissoringClipping, bool doLightIteration, const LightList *manualLightList=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderSingleObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&nbsp;</td>
          <td class="paramname"> <em>rend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td>
          <td class="paramname"> <em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lightScissoringClipping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doLightIteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> *&nbsp;</td>
          <td class="paramname"> <em>manualLightList</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal utility method for rendering a single object. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Assumes that the pass has already been set up. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rend</em>&nbsp;</td><td>The renderable to issue to the pipeline </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pass</em>&nbsp;</td><td>The pass which is being used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lightScissoringClipping</em>&nbsp;</td><td>If true, passes that have the getLightScissorEnabled and/or getLightClipPlanesEnabled flags will cause calculation and setting of scissor rectangle and user clip planes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doLightIteration</em>&nbsp;</td><td>If true, this method will issue the renderable to the pipeline possibly multiple times, if the pass indicates it should be done once per light </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>manualLightList</em>&nbsp;</td><td>Only applicable if doLightIteration is false, this method allows you to pass in a previously determined set of lights which will be used for a single render of this object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9654870f0601526d98af8642546b1a0"></a><!-- doxytag: member="Ogre::SceneManager::createAutoParamDataSource" ref="f9654870f0601526d98af8642546b1a0" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1AutoParamDataSource.html">AutoParamDataSource</a>* Ogre::SceneManager::createAutoParamDataSource           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for creating the <a class="el" href="classOgre_1_1AutoParamDataSource.html" title="This utility class is used to hold the information used to generate the matrices...">AutoParamDataSource</a> instance. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00639">639</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

<p>References <a class="el" href="OgreMemoryAllocatorConfig_8h-source.html#l00421">OGRE_NEW</a>.</p>

</div>
</div><p>
<a class="anchor" name="9b47cb96d4c8daf13ad13f2cefdfb84f"></a><!-- doxytag: member="Ogre::SceneManager::findLightsAffectingFrustum" ref="9b47cb96d4c8daf13ad13f2cefdfb84f" args="(const Camera *camera)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::findLightsAffectingFrustum           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>camera</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for locating a list of lights which could be affecting the frustum. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Custom scene managers are encouraged to override this method to make use of their scene partitioning scheme to more efficiently locate lights, and to eliminate lights which may be occluded by word geometry. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0127361e6d7549373cf7cb991792d45b"></a><!-- doxytag: member="Ogre::SceneManager::initShadowVolumeMaterials" ref="0127361e6d7549373cf7cb991792d45b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::initShadowVolumeMaterials           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for setting up materials for shadows. 
<p>

</div>
</div><p>
<a class="anchor" name="901dc44fa7930877825f7be4b43006cd"></a><!-- doxytag: member="Ogre::SceneManager::ensureShadowTexturesCreated" ref="901dc44fa7930877825f7be4b43006cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::ensureShadowTexturesCreated           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for creating shadow textures (texture-based shadows). 
<p>

</div>
</div><p>
<a class="anchor" name="ee58adae03ba713cc72c4ec59d8b1333"></a><!-- doxytag: member="Ogre::SceneManager::destroyShadowTextures" ref="ee58adae03ba713cc72c4ec59d8b1333" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyShadowTextures           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for destroying shadow textures (texture-based shadows). 
<p>

</div>
</div><p>
<a class="anchor" name="e36765b6712df95d54fe0cc07de1a951"></a><!-- doxytag: member="Ogre::SceneManager::prepareShadowTextures" ref="e36765b6712df95d54fe0cc07de1a951" args="(Camera *cam, Viewport *vp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::prepareShadowTextures           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td>
          <td class="paramname"> <em>vp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for preparing shadow textures ready for use in a regular render. 
<p>

</div>
</div><p>
<a class="anchor" name="6b262351699ce4a35f93faa05612fb35"></a><!-- doxytag: member="Ogre::SceneManager::renderShadowVolumesToStencil" ref="6b262351699ce4a35f93faa05612fb35" args="(const Light *light, const Camera *cam, bool calcScissor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderShadowVolumesToStencil           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>calcScissor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for rendering all the objects for a given light into the stencil buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>light</em>&nbsp;</td><td>The light source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cam</em>&nbsp;</td><td>The camera being viewed from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>calcScissor</em>&nbsp;</td><td>Whether the method should set up any scissor state, or false if that's already been done </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="77a1e643384ab5a2d191642a052914c8"></a><!-- doxytag: member="Ogre::SceneManager::setShadowVolumeStencilState" ref="77a1e643384ab5a2d191642a052914c8" args="(bool secondpass, bool zfail, bool twosided)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowVolumeStencilState           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>secondpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>zfail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>twosided</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal utility method for setting stencil state for rendering shadow volumes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>secondpass</em>&nbsp;</td><td>Is this the second pass? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zfail</em>&nbsp;</td><td>Should we be using the zfail method? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>twosided</em>&nbsp;</td><td>Should we use a 2-sided stencil? </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac6e885d46b59352faf85df49e0c9973"></a><!-- doxytag: member="Ogre::SceneManager::renderShadowVolumeObjects" ref="ac6e885d46b59352faf85df49e0c9973" args="(ShadowCaster::ShadowRenderableListIterator iShadowRenderables, Pass *pass, const LightList *manualLightList, unsigned long flags, bool secondpass, bool zfail, bool twosided)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::renderShadowVolumeObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1VectorIterator.html">ShadowCaster::ShadowRenderableListIterator</a>&nbsp;</td>
          <td class="paramname"> <em>iShadowRenderables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td>
          <td class="paramname"> <em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> *&nbsp;</td>
          <td class="paramname"> <em>manualLightList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>secondpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>zfail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>twosided</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render a set of shadow renderables. 
<p>

</div>
</div><p>
<a class="anchor" name="79519a81dcd7a50402859133216f00f2"></a><!-- doxytag: member="Ogre::SceneManager::findShadowCastersForLight" ref="79519a81dcd7a50402859133216f00f2" args="(const Light *light, const Camera *camera)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1SceneManager.html#25fa6eff947e61a00179e65b7a466100">ShadowCasterList</a>&amp; Ogre::SceneManager::findShadowCastersForLight           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>camera</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for locating a list of shadow casters which could be affecting the frustum for a given light. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Custom scene managers are encouraged to override this method to add optimisations, and to add their own custom shadow casters (perhaps for world geometry) </dd></dl>

</div>
</div><p>
<a class="anchor" name="79019a1aaa0d930b1adfe4adb491654f"></a><!-- doxytag: member="Ogre::SceneManager::renderBasicQueueGroupObjects" ref="79019a1aaa0d930b1adfe4adb491654f" args="(RenderQueueGroup *pGroup, QueuedRenderableCollection::OrganisationMode om)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderBasicQueueGroupObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>pGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render a group in the ordinary way. 
<p>

</div>
</div><p>
<a class="anchor" name="7b0f910145e18b403ffda692dc56de0a"></a><!-- doxytag: member="Ogre::SceneManager::renderAdditiveStencilShadowedQueueGroupObjects" ref="7b0f910145e18b403ffda692dc56de0a" args="(RenderQueueGroup *group, QueuedRenderableCollection::OrganisationMode om)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderAdditiveStencilShadowedQueueGroupObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render a group with the added complexity of additive stencil shadows. 
<p>

</div>
</div><p>
<a class="anchor" name="9347a2cc68ffb1f0f30b2c3648a9f1ab"></a><!-- doxytag: member="Ogre::SceneManager::renderModulativeStencilShadowedQueueGroupObjects" ref="9347a2cc68ffb1f0f30b2c3648a9f1ab" args="(RenderQueueGroup *group, QueuedRenderableCollection::OrganisationMode om)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderModulativeStencilShadowedQueueGroupObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render a group with the added complexity of modulative stencil shadows. 
<p>

</div>
</div><p>
<a class="anchor" name="066a00620486e3bda9a256103c08cd55"></a><!-- doxytag: member="Ogre::SceneManager::renderTextureShadowCasterQueueGroupObjects" ref="066a00620486e3bda9a256103c08cd55" args="(RenderQueueGroup *group, QueuedRenderableCollection::OrganisationMode om)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderTextureShadowCasterQueueGroupObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render a group rendering only shadow casters. 
<p>

</div>
</div><p>
<a class="anchor" name="2fdad5a80651ae791c322546316bdac7"></a><!-- doxytag: member="Ogre::SceneManager::renderTextureShadowReceiverQueueGroupObjects" ref="2fdad5a80651ae791c322546316bdac7" args="(RenderQueueGroup *group, QueuedRenderableCollection::OrganisationMode om)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderTextureShadowReceiverQueueGroupObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render a group rendering only shadow receivers. 
<p>

</div>
</div><p>
<a class="anchor" name="6821367bfafa83a3c5d0ed8f0dea17f9"></a><!-- doxytag: member="Ogre::SceneManager::renderModulativeTextureShadowedQueueGroupObjects" ref="6821367bfafa83a3c5d0ed8f0dea17f9" args="(RenderQueueGroup *group, QueuedRenderableCollection::OrganisationMode om)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderModulativeTextureShadowedQueueGroupObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render a group with the added complexity of modulative texture shadows. 
<p>

</div>
</div><p>
<a class="anchor" name="900c414251c050209e24781067052ad3"></a><!-- doxytag: member="Ogre::SceneManager::renderAdditiveTextureShadowedQueueGroupObjects" ref="900c414251c050209e24781067052ad3" args="(RenderQueueGroup *group, QueuedRenderableCollection::OrganisationMode om)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderAdditiveTextureShadowedQueueGroupObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render a group with additive texture shadows. 
<p>

</div>
</div><p>
<a class="anchor" name="e9e2a6c19e5d5e11951dc0cd5c158fe8"></a><!-- doxytag: member="Ogre::SceneManager::renderObjects" ref="e9e2a6c19e5d5e11951dc0cd5c158fe8" args="(const QueuedRenderableCollection &amp;objs, QueuedRenderableCollection::OrganisationMode om, bool lightScissoringClipping, bool doLightIteration, const LightList *manualLightList=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderObjects           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1QueuedRenderableCollection.html">QueuedRenderableCollection</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lightScissoringClipping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doLightIteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> *&nbsp;</td>
          <td class="paramname"> <em>manualLightList</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render a set of objects, see renderSingleObject for param definitions. 
<p>

</div>
</div><p>
<a class="anchor" name="e588d960549fd37f66881da0c100265b"></a><!-- doxytag: member="Ogre::SceneManager::renderTransparentShadowCasterObjects" ref="e588d960549fd37f66881da0c100265b" args="(const QueuedRenderableCollection &amp;objs, QueuedRenderableCollection::OrganisationMode om, bool lightScissoringClipping, bool doLightIteration, const LightList *manualLightList=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::renderTransparentShadowCasterObjects           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1QueuedRenderableCollection.html">QueuedRenderableCollection</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lightScissoringClipping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doLightIteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> *&nbsp;</td>
          <td class="paramname"> <em>manualLightList</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render those objects in the transparent pass list which have shadow casting forced on. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This function is intended to be used to render the shadows of transparent objects which have transparency_casts_shadows set to 'on' in their material </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a2a90e25975a2f734657cda4f8544f0"></a><!-- doxytag: member="Ogre::SceneManager::updateRenderQueueSplitOptions" ref="7a2a90e25975a2f734657cda4f8544f0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::updateRenderQueueSplitOptions           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the state of the global render queue splitting based on a shadow option change. 
<p>

</div>
</div><p>
<a class="anchor" name="b5c96c7dc84fa2292c7e5062ad123c0c"></a><!-- doxytag: member="Ogre::SceneManager::updateRenderQueueGroupSplitOptions" ref="b5c96c7dc84fa2292c7e5062ad123c0c" args="(RenderQueueGroup *group, bool suppressShadows, bool suppressRenderState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::updateRenderQueueGroupSplitOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>suppressShadows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>suppressRenderState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the state of the render queue group splitting based on a shadow option change. 
<p>

</div>
</div><p>
<a class="anchor" name="b83baf07ebcc68e41b403f2126105f69"></a><!-- doxytag: member="Ogre::SceneManager::buildAndSetScissor" ref="b83baf07ebcc68e41b403f2126105f69" args="(const LightList &amp;ll, const Camera *cam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#4acd510f26a9a302753cf95b35096527">ClipResult</a> Ogre::SceneManager::buildAndSetScissor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set up a scissor rectangle from a group of lights. 
<p>

</div>
</div><p>
<a class="anchor" name="03ab7a77952100672c2191f74b898f72"></a><!-- doxytag: member="Ogre::SceneManager::buildScissor" ref="03ab7a77952100672c2191f74b898f72" args="(const Light *l, const Camera *cam, RealRect &amp;rect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::buildScissor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOgre_1_1TRect.html">RealRect</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rect</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update a scissor rectangle from a single light. 
<p>

</div>
</div><p>
<a class="anchor" name="e79444a2f5305caeab80b01f8d1275a3"></a><!-- doxytag: member="Ogre::SceneManager::resetScissor" ref="e79444a2f5305caeab80b01f8d1275a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::resetScissor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="386586877ecf98bd688954e18b2a47e8"></a><!-- doxytag: member="Ogre::SceneManager::buildAndSetLightClip" ref="386586877ecf98bd688954e18b2a47e8" args="(const LightList &amp;ll)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#4acd510f26a9a302753cf95b35096527">ClipResult</a> Ogre::SceneManager::buildAndSetLightClip           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ll</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build a set of user clip planes from a single non-directional light. 
<p>

</div>
</div><p>
<a class="anchor" name="b951496f7dff614730c5b59a8e9bae91"></a><!-- doxytag: member="Ogre::SceneManager::buildLightClip" ref="b951496f7dff614730c5b59a8e9bae91" args="(const Light *l, PlaneList &amp;planes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::buildLightClip           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>planes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c79994f9a877fc1cd988b581cc1368f6"></a><!-- doxytag: member="Ogre::SceneManager::resetLightClip" ref="c79994f9a877fc1cd988b581cc1368f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::resetLightClip           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2ce3efd7c504bcf7c1f0699e069118c2"></a><!-- doxytag: member="Ogre::SceneManager::checkCachedLightClippingInfo" ref="2ce3efd7c504bcf7c1f0699e069118c2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::checkCachedLightClippingInfo           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="92cef591d74630c19c534709dce030f8"></a><!-- doxytag: member="Ogre::SceneManager::getName" ref="92cef591d74630c19c534709dce030f8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::SceneManager::getName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mutex to protect the scene graph from simultaneous access from multiple threads. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>If you are updating the scene in a separate thread from the rendering thread, then you should lock this mutex before making any changes to the scene graph - that means creating, modifying or deleting a scene node, or attaching / detaching objects. It is <b>your</b> responsibility to take out this lock, the detail methods on the nodes will not do it for you (for the reasons discussed below). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that locking this mutex will prevent the scene being rendered until it is unlocked again. Therefore you should do this sparingly. Try to create any objects you need separately and fully prepare them before doing all your scene graph work in one go, thus keeping this lock for the shortest time possible. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A single global lock is used rather than a per-node lock since it keeps the number of locks required during rendering down to a minimum. Obtaining a lock, even if there is no contention, is not free so for performance it is good to do it as little as possible. Since modifying the scene in a separate thread is a fairly rare occurrence (relative to rendering), it is better to keep the locking required during rendering lower than to make update locks more granular. Return the instance name of this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00941">941</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="46690a40b65fd0e7e89752e1e36be727"></a><!-- doxytag: member="Ogre::SceneManager::getTypeName" ref="46690a40b65fd0e7e89752e1e36be727" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::SceneManager::getTypeName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the type name of this scene manager. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method has to be implemented by subclasses. It should return the type name of this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> which agrees with the type name of the <a class="el" href="classOgre_1_1SceneManagerFactory.html" title="Class which will create instances of a given SceneManager.">SceneManagerFactory</a> which created it. </dd></dl>

<p>Implemented in <a class="el" href="classOgre_1_1DefaultSceneManager.html#3e7bf86e745239456fb18dce99bca86d">Ogre::DefaultSceneManager</a>.</p>

</div>
</div><p>
<a class="anchor" name="62ca781b4c6d23dc3aab1f3a45d61843"></a><!-- doxytag: member="Ogre::SceneManager::createCamera" ref="62ca781b4c6d23dc3aab1f3a45d61843" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Camera.html">Camera</a>* Ogre::SceneManager::createCamera           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a camera to be managed by this scene manager. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This camera must be added to the scene at a later time using the attachObject method of the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> class. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name to give the new camera. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4dbe2eeec924f88c30010e9fd4d9da0e"></a><!-- doxytag: member="Ogre::SceneManager::getCamera" ref="4dbe2eeec924f88c30010e9fd4d9da0e" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Camera.html">Camera</a>* Ogre::SceneManager::getCamera           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a pointer to the named camera. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4af585550a9ed44ead58855419d5f84"></a><!-- doxytag: member="Ogre::SceneManager::hasCamera" ref="c4af585550a9ed44ead58855419d5f84" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasCamera           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a camera with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="cac58e45f8b6b6826c81933f02a45046"></a><!-- doxytag: member="Ogre::SceneManager::destroyCamera" ref="cac58e45f8b6b6826c81933f02a45046" args="(Camera *cam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyCamera           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a camera from the scene. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method removes a previously added camera from the scene. The camera is deleted so the caller must ensure no references to it's previous instance (e.g. in a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>) are used. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cam</em>&nbsp;</td><td>Pointer to the camera to remove </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="41b9358cdad6fd7113b2a0cad8112f67"></a><!-- doxytag: member="Ogre::SceneManager::destroyCamera" ref="41b9358cdad6fd7113b2a0cad8112f67" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyCamera           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a camera from the scene. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method removes an camera from the scene based on the camera's name rather than a pointer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9cb93862284e7443b94eaabdef21564a"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllCameras" ref="9cb93862284e7443b94eaabdef21564a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllCameras           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes (and destroys) all cameras from the scene. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Some cameras are internal created to dealing with texture shadow, their aren't supposed to destroy outside. So, while you are using texture shadow, don't call this method, or you can set the shadow technique other than texture-based, which will destroy all internal created shadow cameras and textures. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b127d52207729591dd51cb12a5b2ed2c"></a><!-- doxytag: member="Ogre::SceneManager::createLight" ref="b127d52207729591dd51cb12a5b2ed2c" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Light.html">Light</a>* Ogre::SceneManager::createLight           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a light for use in the scene. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Lights can either be in a fixed position and independent of the scene graph, or they can be attached to SceneNodes so they derive their position from the parent node. Either way, they are created using this method so that the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> manages their existence. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the new light, to identify it later. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f128cc414af001b325d40745b745b79c"></a><!-- doxytag: member="Ogre::SceneManager::getLight" ref="f128cc414af001b325d40745b745b79c" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Light.html">Light</a>* Ogre::SceneManager::getLight           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the named <a class="el" href="classOgre_1_1Light.html" title="Representation of a dynamic light source in the scene.">Light</a> which has previously been added to the scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="032173d58a1465af8550a394a9c5b870"></a><!-- doxytag: member="Ogre::SceneManager::hasLight" ref="032173d58a1465af8550a394a9c5b870" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasLight           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a light with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="bd89ebb9c348ed8230ad300ef7501948"></a><!-- doxytag: member="Ogre::SceneManager::getLightClippingPlanes" ref="bd89ebb9c348ed8230ad300ef7501948" args="(Light *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceOgre.html#4cfa65f236aec1767fc85022e87059a0">PlaneList</a>&amp; Ogre::SceneManager::getLightClippingPlanes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve a set of clipping planes for a given light. 
<p>

</div>
</div><p>
<a class="anchor" name="384b7ee3a28ba87866c68d689571aa8f"></a><!-- doxytag: member="Ogre::SceneManager::getLightScissorRect" ref="384b7ee3a28ba87866c68d689571aa8f" args="(Light *l, const Camera *cam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structOgre_1_1TRect.html">RealRect</a>&amp; Ogre::SceneManager::getLightScissorRect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve a scissor rectangle for a given light and camera. 
<p>

</div>
</div><p>
<a class="anchor" name="ef6d26cb64e7a1984ebff9b56c45c6e5"></a><!-- doxytag: member="Ogre::SceneManager::destroyLight" ref="ef6d26cb64e7a1984ebff9b56c45c6e5" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyLight           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the named light from the scene and destroys it. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> pointers held to this light after calling this method will be invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cce173aa89e849bda564f4e6e3be6402"></a><!-- doxytag: member="Ogre::SceneManager::destroyLight" ref="cce173aa89e849bda564f4e6e3be6402" args="(Light *light)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyLight           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>light</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the light from the scene and destroys it based on a pointer. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> pointers held to this light after calling this method will be invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="723da9119c26f5022e3a2818611e9aa0"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllLights" ref="723da9119c26f5022e3a2818611e9aa0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllLights           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes and destroys all lights in the scene. 
<p>

</div>
</div><p>
<a class="anchor" name="ebfa8b61550010c86fc3b605e2cda669"></a><!-- doxytag: member="Ogre::SceneManager::_notifyLightsDirty" ref="ebfa8b61550010c86fc3b605e2cda669" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_notifyLightsDirty           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advance method to increase the lights dirty counter due lights changed. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Scene manager tracking lights that affecting the frustum, if changes detected (the changes includes light list itself and the light's position and attenuation range), then increase the lights dirty counter. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>For some reason, you can call this method to force whole scene objects re-populate their light list. But near in mind, call to this method will harm performance, so should avoid if possible. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e9e8558a06d7bf26eadf349731f1cb3"></a><!-- doxytag: member="Ogre::SceneManager::_getLightsDirtyCounter" ref="4e9e8558a06d7bf26eadf349731f1cb3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#4304981347643708ee9a7ba8884e5758">ulong</a> Ogre::SceneManager::_getLightsDirtyCounter           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advance method to gets the lights dirty counter. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Scene manager tracking lights that affecting the frustum, if changes detected (the changes includes light list itself and the light's position and attenuation range), then increase the lights dirty counter. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>When implementing customise lights finding algorithm relied on either <a class="el" href="classOgre_1_1SceneManager.html#62876dcdf7cb0f7923de88e62cf077ac" title="Get the list of lights which could be affecting the frustum.">SceneManager::_getLightsAffectingFrustum</a> or <a class="el" href="classOgre_1_1SceneManager.html#028809d14d6efc7b1cf7d678d3e78605" title="Populate a light list with an ordered set of the lights which are closest to the...">SceneManager::_populateLightList</a>, might check this value for sure that the light list are really need to re-populate, otherwise, returns cached light list (if exists) for better performance. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01064">1064</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="62876dcdf7cb0f7923de88e62cf077ac"></a><!-- doxytag: member="Ogre::SceneManager::_getLightsAffectingFrustum" ref="62876dcdf7cb0f7923de88e62cf077ac" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a>&amp; Ogre::SceneManager::_getLightsAffectingFrustum           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the list of lights which could be affecting the frustum. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Note that default implementation of this method returns a cached light list, which is populated when rendering the scene. So by default the list of lights is only available during scene rendering. </dd></dl>

</div>
</div><p>
<a class="anchor" name="028809d14d6efc7b1cf7d678d3e78605"></a><!-- doxytag: member="Ogre::SceneManager::_populateLightList" ref="028809d14d6efc7b1cf7d678d3e78605" args="(const Vector3 &amp;position, Real radius, LightList &amp;destList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_populateLightList           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Populate a light list with an ordered set of the lights which are closest to the position specified. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Note that since directional lights have no position, they are always considered closer than any point lights and as such will always take precedence. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Subclasses of the default <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> may wish to take into account other issues such as possible visibility of the light if that information is included in their data structures. This basic scenemanager simply orders by distance, eliminating those lights which are out of range or could not be affecting the frustum (i.e. only the lights returned by <a class="el" href="classOgre_1_1SceneManager.html#62876dcdf7cb0f7923de88e62cf077ac" title="Get the list of lights which could be affecting the frustum.">SceneManager::_getLightsAffectingFrustum</a> are take into account). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The number of items in the list max exceed the maximum number of lights supported by the renderer, but the extraneous ones will never be used. In fact the limit will be imposed by <a class="el" href="classOgre_1_1Pass.html#7c90a998e60c3d1eaed4a9523cb11adf" title="Gets the maximum number of lights to be used by this pass.">Pass::getMaxSimultaneousLights</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>The position at which to evaluate the list of lights </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>The bounding radius to test </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destList</em>&nbsp;</td><td>List to be populated with ordered set of lights; will be cleared by this method before population. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b31f9c018b801240c238c7a048439150"></a><!-- doxytag: member="Ogre::SceneManager::createSceneNode" ref="b31f9c018b801240c238c7a048439150" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneManager::createSceneNode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an instance of a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Note that this does not add the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> to the scene hierarchy. This method is for convenience, since it allows an instance to be created for which the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> is responsible for allocating and releasing memory, which is convenient in complex scenes. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>To include the returned <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> in the scene, use the addChild method of the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> which is to be it's parent. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that this method takes no parameters, and the node created is unnamed (it is actually given a generated name, which you can retrieve if you want). If you wish to create a node with a specific name, call the alternative method which takes a name parameter. </dd></dl>

</div>
</div><p>
<a class="anchor" name="73c42645ea3b064ca6e0822a8f702cd4"></a><!-- doxytag: member="Ogre::SceneManager::createSceneNode" ref="73c42645ea3b064ca6e0822a8f702cd4" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneManager::createSceneNode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an instance of a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> with a given name. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Note that this does not add the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> to the scene hierarchy. This method is for convenience, since it allows an instance to be created for which the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> is responsible for allocating and releasing memory, which is convenient in complex scenes. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>To include the returned <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> in the scene, use the addChild method of the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> which is to be it's parent. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that this method takes a name parameter, which makes the node easier to retrieve directly again later. </dd></dl>

</div>
</div><p>
<a class="anchor" name="813346e505716ae5d24f714cfc4a5069"></a><!-- doxytag: member="Ogre::SceneManager::destroySceneNode" ref="813346e505716ae5d24f714cfc4a5069" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroySceneNode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> with a given name. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This allows you to physically delete an individual <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> if you want to. Note that this is not normally recommended, it's better to allow <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> to delete the nodes when the scene is cleared. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a613e5ffb08b95a90644a61ac10c9b5c"></a><!-- doxytag: member="Ogre::SceneManager::destroySceneNode" ref="a613e5ffb08b95a90644a61ac10c9b5c" args="(SceneNode *sn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroySceneNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td>
          <td class="paramname"> <em>sn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This allows you to physically delete an individual <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> if you want to. Note that this is not normally recommended, it's better to allow <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> to delete the nodes when the scene is cleared. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ef8edf722bd8436ad414967bc2e8c51"></a><!-- doxytag: member="Ogre::SceneManager::getRootSceneNode" ref="1ef8edf722bd8436ad414967bc2e8c51" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneManager::getRootSceneNode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> at the root of the scene hierarchy. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The entire scene is held as a hierarchy of nodes, which allows things like relative transforms, general changes in rendering state etc (See the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> class for more info). In this basic <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> class, the application using <a class="el" href="namespaceOgre.html">Ogre</a> is free to structure this hierarchy however it likes, since it has no real significance apart from making transforms relative to each node (more specialised subclasses will provide utility methods for building specific node structures e.g. loading a BSP tree). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>However, in all cases there is only ever one root node of the hierarchy, and this method returns a pointer to it. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c3389aea8f436037850ddc64f6d1d7d"></a><!-- doxytag: member="Ogre::SceneManager::getSceneNode" ref="8c3389aea8f436037850ddc64f6d1d7d" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneManager::getSceneNode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a named <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> from the scene graph. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>If you chose to name a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as you created it, or if you happened to make a note of the generated name, you can look it up wherever it is in the scene graph using this method. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="6389657d1838dcc93adc8b7e473e4c0a"></a><!-- doxytag: member="Ogre::SceneManager::hasSceneNode" ref="6389657d1838dcc93adc8b7e473e4c0a" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasSceneNode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a scene node with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="0aa3c748f97b760919741043348ef1d2"></a><!-- doxytag: member="Ogre::SceneManager::createEntity" ref="0aa3c748f97b760919741043348ef1d2" args="(const String &amp;entityName, const String &amp;meshName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Entity.html">Entity</a>* Ogre::SceneManager::createEntity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>meshName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> (instance of a discrete mesh). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entityName</em>&nbsp;</td><td>The name to be given to the entity (must be unique). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>meshName</em>&nbsp;</td><td>The name of the <a class="el" href="classOgre_1_1Mesh.html">Mesh</a> it is to be based on (e.g. 'knot.oof'). The mesh will be loaded if it is not already. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9d9c135f1e3fe85db6e1976f1df3fb35"></a><!-- doxytag: member="Ogre::SceneManager::createEntity" ref="9d9c135f1e3fe85db6e1976f1df3fb35" args="(const String &amp;entityName, PrefabType ptype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Entity.html">Entity</a>* Ogre::SceneManager::createEntity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>entityName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneManager.html#b4c2ff4f6c76f7fe0a8eae76f2a84cbf">PrefabType</a>&nbsp;</td>
          <td class="paramname"> <em>ptype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> (instance of a discrete mesh) from a range of prefab shapes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entityName</em>&nbsp;</td><td>The name to be given to the entity (must be unique). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptype</em>&nbsp;</td><td>The prefab type. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d7e8374bd4774284ec6adfbd286ddbc"></a><!-- doxytag: member="Ogre::SceneManager::getEntity" ref="0d7e8374bd4774284ec6adfbd286ddbc" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Entity.html">Entity</a>* Ogre::SceneManager::getEntity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a pointer to the named <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e6c904789a2393264e278c05e9c5395"></a><!-- doxytag: member="Ogre::SceneManager::hasEntity" ref="1e6c904789a2393264e278c05e9c5395" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasEntity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether an entity with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="aec976bb28961a149c71a5eba62f40e4"></a><!-- doxytag: member="Ogre::SceneManager::destroyEntity" ref="aec976bb28961a149c71a5eba62f40e4" args="(Entity *ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyEntity           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Entity.html">Entity</a> *&nbsp;</td>
          <td class="paramname"> <em>ent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys an <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Must only be done if the <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> is not attached to a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. It may be safer to wait to clear the whole scene if you are unsure use clearScene. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#a5b2047b5740b691b0e636d57f2dba7e" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets...">SceneManager::clearScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3e19d4a7d848a745a59e63fca36fa79c"></a><!-- doxytag: member="Ogre::SceneManager::destroyEntity" ref="3e19d4a7d848a745a59e63fca36fa79c" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyEntity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys an <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> by name. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Must only be done if the <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> is not attached to a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. It may be safer to wait to clear the whole scene if you are unsure use clearScene. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#a5b2047b5740b691b0e636d57f2dba7e" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets...">SceneManager::clearScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a77be68ccbfc90e2e1aed04340db4dc"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllEntities" ref="1a77be68ccbfc90e2e1aed04340db4dc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllEntities           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys all Entities. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Again, use caution since no <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> must be referred to elsewhere e.g. attached to a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> otherwise a crash is likely. Use clearScene if you are unsure (it clears <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> entries too.) </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#a5b2047b5740b691b0e636d57f2dba7e" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets...">SceneManager::clearScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="680ab7ccb241680100bfeea73681cce6"></a><!-- doxytag: member="Ogre::SceneManager::createManualObject" ref="680ab7ccb241680100bfeea73681cce6" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1ManualObject.html">ManualObject</a>* Ogre::SceneManager::createManualObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="classOgre_1_1ManualObject.html" title="Class providing a much simplified interface to generating manual objects with custom...">ManualObject</a>, an object which you populate with geometry manually through a GL immediate-mode style interface. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to be given to the object (must be unique). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3c5eb0c8dd2cedf713d7309d74daf83a"></a><!-- doxytag: member="Ogre::SceneManager::getManualObject" ref="3c5eb0c8dd2cedf713d7309d74daf83a" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1ManualObject.html">ManualObject</a>* Ogre::SceneManager::getManualObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a pointer to the named <a class="el" href="classOgre_1_1ManualObject.html" title="Class providing a much simplified interface to generating manual objects with custom...">ManualObject</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f6e3800eacb8a5bb39fd5c7e94e2c82"></a><!-- doxytag: member="Ogre::SceneManager::hasManualObject" ref="2f6e3800eacb8a5bb39fd5c7e94e2c82" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasManualObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a manual object with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="75d15c3ac882f78f0001d9d007f403be"></a><!-- doxytag: member="Ogre::SceneManager::destroyManualObject" ref="75d15c3ac882f78f0001d9d007f403be" args="(ManualObject *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyManualObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1ManualObject.html">ManualObject</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys a <a class="el" href="classOgre_1_1ManualObject.html" title="Class providing a much simplified interface to generating manual objects with custom...">ManualObject</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="d42dfd20473e780251db4e939d7668d0"></a><!-- doxytag: member="Ogre::SceneManager::destroyManualObject" ref="d42dfd20473e780251db4e939d7668d0" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyManualObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys a <a class="el" href="classOgre_1_1ManualObject.html" title="Class providing a much simplified interface to generating manual objects with custom...">ManualObject</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="b3e151b6d94feb6648b8c817ba485238"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllManualObjects" ref="b3e151b6d94feb6648b8c817ba485238" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllManualObjects           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys all ManualObjects from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="d0380187a8c572e303c93a64b3355062"></a><!-- doxytag: member="Ogre::SceneManager::createBillboardChain" ref="d0380187a8c572e303c93a64b3355062" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1BillboardChain.html">BillboardChain</a>* Ogre::SceneManager::createBillboardChain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a>, an object which you can use to render a linked chain of billboards. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to be given to the object (must be unique). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0667cd1101c4d3e56302b8f82132986b"></a><!-- doxytag: member="Ogre::SceneManager::getBillboardChain" ref="0667cd1101c4d3e56302b8f82132986b" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1BillboardChain.html">BillboardChain</a>* Ogre::SceneManager::getBillboardChain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a pointer to the named <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="496f747b6482bc8170495815859c921e"></a><!-- doxytag: member="Ogre::SceneManager::hasBillboardChain" ref="496f747b6482bc8170495815859c921e" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasBillboardChain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a billboard chain with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="98bc20d44752f40fd588f0ba91e4a904"></a><!-- doxytag: member="Ogre::SceneManager::destroyBillboardChain" ref="98bc20d44752f40fd588f0ba91e4a904" args="(BillboardChain *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyBillboardChain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1BillboardChain.html">BillboardChain</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys a <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="149fafd649d4b9ebb34fa7467314640f"></a><!-- doxytag: member="Ogre::SceneManager::destroyBillboardChain" ref="149fafd649d4b9ebb34fa7467314640f" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyBillboardChain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys a <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="2c01b8c2d82759fb875089c93df491a4"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllBillboardChains" ref="2c01b8c2d82759fb875089c93df491a4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllBillboardChains           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys all BillboardChains from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="c4edb21cec1bb77f7a003c506f344652"></a><!-- doxytag: member="Ogre::SceneManager::createRibbonTrail" ref="c4edb21cec1bb77f7a003c506f344652" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1RibbonTrail.html">RibbonTrail</a>* Ogre::SceneManager::createRibbonTrail           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="classOgre_1_1RibbonTrail.html" title="Subclass of BillboardChain which automatically leaves a trail behind one or more...">RibbonTrail</a>, an object which you can use to render a linked chain of billboards which follows one or more nodes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to be given to the object (must be unique). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fe38a813501eb293c9695c2db68c59b5"></a><!-- doxytag: member="Ogre::SceneManager::getRibbonTrail" ref="fe38a813501eb293c9695c2db68c59b5" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1RibbonTrail.html">RibbonTrail</a>* Ogre::SceneManager::getRibbonTrail           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a pointer to the named <a class="el" href="classOgre_1_1RibbonTrail.html" title="Subclass of BillboardChain which automatically leaves a trail behind one or more...">RibbonTrail</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="d0d074b988d997b4b9fe461c26ffbab0"></a><!-- doxytag: member="Ogre::SceneManager::hasRibbonTrail" ref="d0d074b988d997b4b9fe461c26ffbab0" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasRibbonTrail           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a ribbon trail with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="f9c802d5f62e0c7b807dad407e47b97e"></a><!-- doxytag: member="Ogre::SceneManager::destroyRibbonTrail" ref="f9c802d5f62e0c7b807dad407e47b97e" args="(RibbonTrail *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyRibbonTrail           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RibbonTrail.html">RibbonTrail</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys a <a class="el" href="classOgre_1_1RibbonTrail.html" title="Subclass of BillboardChain which automatically leaves a trail behind one or more...">RibbonTrail</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="6e86cea62012449c98c7afa14c241d78"></a><!-- doxytag: member="Ogre::SceneManager::destroyRibbonTrail" ref="6e86cea62012449c98c7afa14c241d78" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyRibbonTrail           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys a <a class="el" href="classOgre_1_1RibbonTrail.html" title="Subclass of BillboardChain which automatically leaves a trail behind one or more...">RibbonTrail</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="12e41109a26094ffe128beb5b6898f95"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllRibbonTrails" ref="12e41109a26094ffe128beb5b6898f95" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllRibbonTrails           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys all RibbonTrails from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="1ccfcf067b098ce531f16998e1bbe275"></a><!-- doxytag: member="Ogre::SceneManager::createParticleSystem" ref="1ccfcf067b098ce531f16998e1bbe275" args="(const String &amp;name, const String &amp;templateName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1ParticleSystem.html">ParticleSystem</a>* Ogre::SceneManager::createParticleSystem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>templateName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a particle system based on a template. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method creates a new <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> instance based on the named template (defined through <a class="el" href="classOgre_1_1ParticleSystemManager.html#c3b4d8e5717c7eb97a06ed0585709ce5" title="Create a new particle system template.">ParticleSystemManager::createTemplate</a>) and returns a pointer to the caller. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Each system created from a template takes the template's settings at the time of creation, but is completely separate from the template from there on. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Creating a particle system does not make it a part of the scene. As with other <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> subclasses, a <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> is not rendered until it is attached to a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>This is probably the more useful particle system creation method since it does not require manual setup of the system. Note that the initial quota is based on the template but may be changed later. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to give the new particle system instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>templateName</em>&nbsp;</td><td>The name of the template to base the new instance on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="62589dc6a7f70e5efdbf5ebd7a282ea9"></a><!-- doxytag: member="Ogre::SceneManager::createParticleSystem" ref="62589dc6a7f70e5efdbf5ebd7a282ea9" args="(const String &amp;name, size_t quota=500, const String &amp;resourceGroup=ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1ParticleSystem.html">ParticleSystem</a>* Ogre::SceneManager::createParticleSystem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>quota</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>resourceGroup</em> = <code><a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a blank particle system. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method creates a new, blank <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> instance and returns a pointer to it. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The instance returned from this method won't actually do anything because on creation a particle system has no emitters. The caller should manipulate the instance through it's <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> methods to actually create a real particle effect. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Creating a particle system does not make it a part of the scene. As with other <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> subclasses, a <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> is not rendered until it is attached to a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to give the <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quota</em>&nbsp;</td><td>The maximum number of particles to allow in this system. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resourceGroup</em>&nbsp;</td><td>The resource group which will be used to load dependent resources </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="499cc0669395a5a11aea7d19979765b7"></a><!-- doxytag: member="Ogre::SceneManager::getParticleSystem" ref="499cc0669395a5a11aea7d19979765b7" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1ParticleSystem.html">ParticleSystem</a>* Ogre::SceneManager::getParticleSystem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a pointer to the named <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="3dc7da5d60915c3667a531d2f053e34a"></a><!-- doxytag: member="Ogre::SceneManager::hasParticleSystem" ref="3dc7da5d60915c3667a531d2f053e34a" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasParticleSystem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a particle system with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="bde401fcf3796e3e2beb8c7603648f07"></a><!-- doxytag: member="Ogre::SceneManager::destroyParticleSystem" ref="bde401fcf3796e3e2beb8c7603648f07" args="(ParticleSystem *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyParticleSystem           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1ParticleSystem.html">ParticleSystem</a> *&nbsp;</td>
          <td class="paramname"> <em>obj</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys a <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="bb127ba7b98f3892426d4f55abd2a953"></a><!-- doxytag: member="Ogre::SceneManager::destroyParticleSystem" ref="bb127ba7b98f3892426d4f55abd2a953" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyParticleSystem           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys a <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="98dbd81cd9867b1032e02e1780b6eb49"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllParticleSystems" ref="98dbd81cd9867b1032e02e1780b6eb49" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllParticleSystems           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys all ParticleSystems from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="a5b2047b5740b691b0e636d57f2dba7e"></a><!-- doxytag: member="Ogre::SceneManager::clearScene" ref="a5b2047b5740b691b0e636d57f2dba7e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::clearScene           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc. 
<p>
Cameras are not deleted at this stage since they are still referenced by viewports, which are not destroyed during this process. 
</div>
</div><p>
<a class="anchor" name="7c26cdbb5703cf10a99add1f6a930ca2"></a><!-- doxytag: member="Ogre::SceneManager::setAmbientLight" ref="7c26cdbb5703cf10a99add1f6a930ca2" args="(const ColourValue &amp;colour)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::setAmbientLight           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colour</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the ambient light level to be used for the scene. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This sets the colour and intensity of the ambient light in the scene, i.e. the light which is 'sourceless' and illuminates all objects equally. The colour of an object is affected by a combination of the light in the scene, and the amount of light that object reflects (in this case based on the Material::ambient property). <p>
By default the ambient light in the scene is <a class="el" href="classOgre_1_1ColourValue.html#7f8a06f2a9dd645417c36b560f496c1a">ColourValue::Black</a>, i.e. no ambient light. This means that any objects rendered with a <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> which has lighting enabled (see <a class="el" href="classOgre_1_1Material.html#758ce629d7d709a7038ede19d21f59cf" title="Sets whether or not dynamic lighting is enabled for every Pass.">Material::setLightingEnabled</a>) will not be visible unless you have some dynamic lights in your scene. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4b5b77723e26e8ceb995f84b7fcade5"></a><!-- doxytag: member="Ogre::SceneManager::getAmbientLight" ref="d4b5b77723e26e8ceb995f84b7fcade5" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a>&amp; Ogre::SceneManager::getAmbientLight           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the ambient light level to be used for the scene. 
<p>

</div>
</div><p>
<a class="anchor" name="5ceb87944e7ba077e4c6ed8db8acf4cc"></a><!-- doxytag: member="Ogre::SceneManager::prepareWorldGeometry" ref="5ceb87944e7ba077e4c6ed8db8acf4cc" args="(const String &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::prepareWorldGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the source of the 'world' geometry, i.e. 
<p>
the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Depending on the type of <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> (subclasses will be specialised for particular world geometry types) you have requested via the <a class="el" href="classOgre_1_1Root.html" title="The root class of the Ogre system.">Root</a> or <a class="el" href="classOgre_1_1SceneManagerEnumerator.html" title="Enumerates the SceneManager classes available to applications.">SceneManagerEnumerator</a> classes, you can pass a filename to this method and it will attempt to load the world-level geometry for use. If you try to load an inappropriate type of world data an exception will be thrown. The default <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> cannot handle any sort of world geometry and so will always throw an exception. However subclasses like BspSceneManager can load particular types of world geometry e.g. "q3dm1.bsp". </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a237a294eb4ebebee35da1825f71f06"></a><!-- doxytag: member="Ogre::SceneManager::prepareWorldGeometry" ref="5a237a294eb4ebebee35da1825f71f06" args="(DataStreamPtr &amp;stream, const String &amp;typeName=StringUtil::BLANK)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::prepareWorldGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SharedPtr.html">DataStreamPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em> = <code><a class="el" href="classOgre_1_1StringUtil.html#d2ead745c8c6f4f7056270e22f29e4da">StringUtil::BLANK</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the source of the 'world' geometry, i.e. 
<p>
the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Depending on the type of <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> (subclasses will be specialised for particular world geometry types) you have requested via the <a class="el" href="classOgre_1_1Root.html" title="The root class of the Ogre system.">Root</a> or <a class="el" href="classOgre_1_1SceneManagerEnumerator.html" title="Enumerates the SceneManager classes available to applications.">SceneManagerEnumerator</a> classes, you can pass a stream to this method and it will attempt to load the world-level geometry for use. If the manager can only handle one input format the typeName parameter is not required. The stream passed will be read (and it's state updated). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Data stream containing data to load </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>typeName</em>&nbsp;</td><td>String identifying the type of world geometry contained in the stream - not required if this manager only supports one type of world geometry. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ccb0fdfbd1f61aa4d3d6e1f4625e1f9c"></a><!-- doxytag: member="Ogre::SceneManager::setWorldGeometry" ref="ccb0fdfbd1f61aa4d3d6e1f4625e1f9c" args="(const String &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setWorldGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the source of the 'world' geometry, i.e. 
<p>
the large, mainly static geometry making up the world e.g. rooms, landscape etc. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Depending on the type of <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> (subclasses will be specialised for particular world geometry types) you have requested via the <a class="el" href="classOgre_1_1Root.html" title="The root class of the Ogre system.">Root</a> or <a class="el" href="classOgre_1_1SceneManagerEnumerator.html" title="Enumerates the SceneManager classes available to applications.">SceneManagerEnumerator</a> classes, you can pass a filename to this method and it will attempt to load the world-level geometry for use. If you try to load an inappropriate type of world data an exception will be thrown. The default <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> cannot handle any sort of world geometry and so will always throw an exception. However subclasses like BspSceneManager can load particular types of world geometry e.g. "q3dm1.bsp". </dd></dl>

</div>
</div><p>
<a class="anchor" name="000a7ece2364c8da5e9f4b5d6aac6730"></a><!-- doxytag: member="Ogre::SceneManager::setWorldGeometry" ref="000a7ece2364c8da5e9f4b5d6aac6730" args="(DataStreamPtr &amp;stream, const String &amp;typeName=StringUtil::BLANK)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setWorldGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SharedPtr.html">DataStreamPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em> = <code><a class="el" href="classOgre_1_1StringUtil.html#d2ead745c8c6f4f7056270e22f29e4da">StringUtil::BLANK</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the source of the 'world' geometry, i.e. 
<p>
the large, mainly static geometry making up the world e.g. rooms, landscape etc. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Depending on the type of <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> (subclasses will be specialised for particular world geometry types) you have requested via the <a class="el" href="classOgre_1_1Root.html" title="The root class of the Ogre system.">Root</a> or <a class="el" href="classOgre_1_1SceneManagerEnumerator.html" title="Enumerates the SceneManager classes available to applications.">SceneManagerEnumerator</a> classes, you can pass a stream to this method and it will attempt to load the world-level geometry for use. If the manager can only handle one input format the typeName parameter is not required. The stream passed will be read (and it's state updated). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Data stream containing data to load </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>typeName</em>&nbsp;</td><td>String identifying the type of world geometry contained in the stream - not required if this manager only supports one type of world geometry. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1257fd328d54908eeb45398b3191f92b"></a><!-- doxytag: member="Ogre::SceneManager::estimateWorldGeometry" ref="1257fd328d54908eeb45398b3191f92b" args="(const String &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::SceneManager::estimateWorldGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Estimate the number of loading stages required to load the named world geometry. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method should be overridden by SceneManagers that provide custom world geometry that can take some time to load. They should return from this method a count of the number of stages of progress they can report on whilst loading. During real loading (setWorldGeomtry), they should call ResourceGroupManager::_notifyWorldGeometryProgress exactly that number of times when loading the geometry for real. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The default is to return 0, ie to not report progress. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01483">1483</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="eeea65a3bf511e82a9b59ba31b96e98f"></a><!-- doxytag: member="Ogre::SceneManager::estimateWorldGeometry" ref="eeea65a3bf511e82a9b59ba31b96e98f" args="(DataStreamPtr &amp;stream, const String &amp;typeName=StringUtil::BLANK)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::SceneManager::estimateWorldGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SharedPtr.html">DataStreamPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em> = <code><a class="el" href="classOgre_1_1StringUtil.html#d2ead745c8c6f4f7056270e22f29e4da">StringUtil::BLANK</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Estimate the number of loading stages required to load the named world geometry. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Operates just like the version of this method which takes a filename, but operates on a stream instead. Note that since the stream is updated, you'll need to reset the stream or reopen it when it comes to loading it for real. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>Data stream containing data to load </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>typeName</em>&nbsp;</td><td>String identifying the type of world geometry contained in the stream - not required if this manager only supports one type of world geometry. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01497">1497</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="dd6fe27d7a9500aafbe9325c21985801"></a><!-- doxytag: member="Ogre::SceneManager::getSuggestedViewpoint" ref="dd6fe27d7a9500aafbe9325c21985801" args="(bool random=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structOgre_1_1ViewPoint.html">ViewPoint</a> Ogre::SceneManager::getSuggestedViewpoint           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>random</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asks the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> to provide a suggested viewpoint from which the scene should be viewed. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Typically this method returns the origin unless a) world geometry has been loaded using <a class="el" href="classOgre_1_1SceneManager.html#ccb0fdfbd1f61aa4d3d6e1f4625e1f9c" title="Sets the source of the &#39;world&#39; geometry, i.e.">SceneManager::setWorldGeometry</a> and b) that world geometry has suggested 'start' points. If there is more than one viewpoint which the scene manager can suggest, it will always suggest the first one unless the random parameter is true. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>random</em>&nbsp;</td><td>If true, and there is more than one possible suggestion, a random one will be used. If false the same one will always be suggested. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success, true is returned. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>On failiure, false is returned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="34f3ddda75dcf75d5c5176446b3316a8"></a><!-- doxytag: member="Ogre::SceneManager::setOption" ref="34f3ddda75dcf75d5c5176446b3316a8" args="(const String &amp;strKey, const void *pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::setOption           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>strKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>pValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Method for setting a specific option of the Scene Manager. 
<p>
These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strKey</em>&nbsp;</td><td>The name of the option to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pValue</em>&nbsp;</td><td>A pointer to the value - the size should be calculated by the scene manager based on the key </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success, true is returned. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>On failiure, false is returned. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01528">1528</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2ea53a860f373185f5a46239f579a361"></a><!-- doxytag: member="Ogre::SceneManager::getOption" ref="2ea53a860f373185f5a46239f579a361" args="(const String &amp;strKey, void *pDestValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getOption           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>strKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pDestValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Method for getting the value of an implementation-specific Scene Manager option. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strKey</em>&nbsp;</td><td>The name of the option </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pDestValue</em>&nbsp;</td><td>A pointer to a memory location where the value will be copied. Currently, the memory will be allocated by the scene manager, but this may change </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success, true is returned and pDestValue points to the value of the given option. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>On failiure, false is returned and pDestValue is set to NULL. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01543">1543</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="31da84037d0cca0008e9e894e8ddb569"></a><!-- doxytag: member="Ogre::SceneManager::hasOption" ref="31da84037d0cca0008e9e894e8ddb569" args="(const String &amp;strKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasOption           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>strKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Method for verifying wether the scene manager has an implementation-specific option. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strKey</em>&nbsp;</td><td>The name of the option to check for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>If the scene manager contains the given option, true is returned. </dd></dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>If it does not, false is returned. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01554">1554</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e291393bc0c5bd48a8c6e79742180c93"></a><!-- doxytag: member="Ogre::SceneManager::getOptionValues" ref="e291393bc0c5bd48a8c6e79742180c93" args="(const String &amp;strKey, StringVector &amp;refValueList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getOptionValues           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>strKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#783e5227595f351519627abfb740ec85">StringVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refValueList</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Method for getting all possible values for a specific option. 
<p>
When this list is too large (i.e. the option expects, for example, a float), the return value will be true, but the list will contain just one element whose size will be set to 0. Otherwise, the list will be filled with all the possible values the option can accept. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strKey</em>&nbsp;</td><td>The name of the option to get the values for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refValueList</em>&nbsp;</td><td>A reference to a list that will be filled with the available values. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success (the option exists), true is returned. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>On failure, false is returned. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01569">1569</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7c8ff6b5c19eb9eeef9d5a6c9fca9fe8"></a><!-- doxytag: member="Ogre::SceneManager::getOptionKeys" ref="7c8ff6b5c19eb9eeef9d5a6c9fca9fe8" args="(StringVector &amp;refKeys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getOptionKeys           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#783e5227595f351519627abfb740ec85">StringVector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>refKeys</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Method for getting all the implementation-specific options of the scene manager. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>refKeys</em>&nbsp;</td><td>A reference to a list that will be filled with all the available options. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>On success, true is returned. On failiure, false is returned. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01577">1577</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="24ad98304368771d852a5ef62eb8d277"></a><!-- doxytag: member="Ogre::SceneManager::_updateSceneGraph" ref="24ad98304368771d852a5ef62eb8d277" args="(Camera *cam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_updateSceneGraph           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for updating the scene graph ie the tree of <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> instances managed by this class. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This must be done before issuing objects to the rendering pipeline, since derived transformations from parent nodes are not updated until required. This <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> is a basic implementation which simply updates all nodes from the root. This ensures the scene is up to date but requires all the nodes to be updated even if they are not visible. Subclasses could trim this such that only potentially visible nodes are updated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd51f4629d00ff23f5064c0d2ab37647"></a><!-- doxytag: member="Ogre::SceneManager::_findVisibleObjects" ref="bd51f4629d00ff23f5064c0d2ab37647" args="(Camera *cam, VisibleObjectsBoundsInfo *visibleBounds, bool onlyShadowCasters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_findVisibleObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>visibleBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>onlyShadowCasters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method which parses the scene to find visible objects to render. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>If you're implementing a custom scene manager, this is the most important method to override since it's here you can apply your custom world partitioning scheme. Once you have added the appropriate objects to the render queue, you can let the default <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> objects _renderVisibleObjects handle the actual rendering of the objects you pick. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> visible objects will be added to a rendering queue, which is indexed by material in order to ensure objects with the same material are rendered together to minimise render state changes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="58019e4c5104af4fe19d483fb1deec91"></a><!-- doxytag: member="Ogre::SceneManager::_applySceneAnimations" ref="58019e4c5104af4fe19d483fb1deec91" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_applySceneAnimations           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for applying animations to scene nodes. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Uses the internally stored <a class="el" href="classOgre_1_1AnimationState.html" title="Represents the state of an animation and the weight of it&#39;s influence.">AnimationState</a> objects to apply animation to SceneNodes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4714d027f9718bce87783bcca19f595"></a><!-- doxytag: member="Ogre::SceneManager::_renderVisibleObjects" ref="a4714d027f9718bce87783bcca19f595" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_renderVisibleObjects           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends visible objects found in _findVisibleObjects to the rendering engine. 
<p>

</div>
</div><p>
<a class="anchor" name="29ba8a2cad151d307d04781f749e7e84"></a><!-- doxytag: member="Ogre::SceneManager::_renderScene" ref="29ba8a2cad151d307d04781f749e7e84" args="(Camera *camera, Viewport *vp, bool includeOverlays)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_renderScene           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td>
          <td class="paramname"> <em>vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>includeOverlays</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prompts the class to send its contents to the renderer. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method prompts the scene manager to send the contents of the scene it manages to the rendering pipeline, possibly preceded by some sorting, culling or other scene management tasks. Note that this method is not normally called directly by the user application; it is called automatically by the <a class="el" href="namespaceOgre.html">Ogre</a> rendering loop. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>camera</em>&nbsp;</td><td>Pointer to a camera from whose viewpoint the scene is to be rendered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vp</em>&nbsp;</td><td>The target viewport </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>includeOverlays</em>&nbsp;</td><td>Whether or not overlay objects should be rendered </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="85f817bd7ceae5bb1601b9b838eaff80"></a><!-- doxytag: member="Ogre::SceneManager::_queueSkiesForRendering" ref="85f817bd7ceae5bb1601b9b838eaff80" args="(Camera *cam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_queueSkiesForRendering           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for queueing the sky objects with the params as previously set through setSkyBox, setSkyPlane and setSkyDome. 
<p>

</div>
</div><p>
<a class="anchor" name="b20c0ee49a853145d3350e6e32c59f32"></a><!-- doxytag: member="Ogre::SceneManager::_setDestinationRenderSystem" ref="b20c0ee49a853145d3350e6e32c59f32" args="(RenderSystem *sys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_setDestinationRenderSystem           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderSystem.html">RenderSystem</a> *&nbsp;</td>
          <td class="paramname"> <em>sys</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notifies the scene manager of its destination render system. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Called automatically by RenderSystem::addSceneManager this method simply notifies the manager of the render system to which its output must be directed. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sys</em>&nbsp;</td><td>Pointer to the <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> subclass to be used as a render target. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f9395e50574b0d0c343036cf816c2bf"></a><!-- doxytag: member="Ogre::SceneManager::setSkyPlane" ref="7f9395e50574b0d0c343036cf816c2bf" args="(bool enable, const Plane &amp;plane, const String &amp;materialName, Real scale=1000, Real tiling=10, bool drawFirst=true, Real bow=0, int xsegments=1, int ysegments=1, const String &amp;groupName=ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSkyPlane           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>scale</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>tiling</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>drawFirst</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>bow</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>xsegments</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ysegments</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupName</em> = <code><a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables / disables a 'sky plane' i.e. 
<p>
a plane at constant distance from the camera representing the sky. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as the <a class="el" href="classOgre_1_1Camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>To apply scaling, scrolls etc to the sky texture(s) you should use the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> class methods. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>True to enable the plane, false to disable it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>Details of the plane, i.e. it's normal and it's distance from the camera. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>materialName</em>&nbsp;</td><td>The name of the material the plane will use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tiling</em>&nbsp;</td><td>How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> texture coordinate transformation methods. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>drawFirst</em>&nbsp;</td><td>If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws <em>after</em> all other geometry which can be an optimisation - however you must ensure that the plane.d value is large enough that no objects will 'poke through' the sky plane when it is rendered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bow</em>&nbsp;</td><td>If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xsegments,ysegments</em>&nbsp;</td><td>Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tesselation on the plane to perform per-vertex effects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1791ac4fbc202fbea7247f236b363fa4"></a><!-- doxytag: member="Ogre::SceneManager::_setSkyPlane" ref="1791ac4fbc202fbea7247f236b363fa4" args="(bool enable, const Plane &amp;plane, const String &amp;materialName, Real scale=1000, Real tiling=10, uint8 renderQueue=RENDER_QUEUE_SKIES_EARLY, Real bow=0, int xsegments=1, int ysegments=1, const String &amp;groupName=ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_setSkyPlane           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>scale</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>tiling</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>renderQueue</em> = <code>RENDER_QUEUE_SKIES_EARLY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>bow</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>xsegments</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ysegments</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupName</em> = <code><a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables / disables a 'sky plane' i.e. 
<p>
a plane at constant distance from the camera representing the sky. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as the <a class="el" href="classOgre_1_1Camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>To apply scaling, scrolls etc to the sky texture(s) you should use the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> class methods. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>True to enable the plane, false to disable it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane</em>&nbsp;</td><td>Details of the plane, i.e. it's normal and it's distance from the camera. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>materialName</em>&nbsp;</td><td>The name of the material the plane will use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tiling</em>&nbsp;</td><td>How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> texture coordinate transformation methods. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>renderQueue</em>&nbsp;</td><td>The render queue to use when rendering this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bow</em>&nbsp;</td><td>If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xsegments,ysegments</em>&nbsp;</td><td>Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tesselation on the plane to perform per-vertex effects. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9d22e78d5f0059aeb0f822064af6ed5b"></a><!-- doxytag: member="Ogre::SceneManager::isSkyPlaneEnabled" ref="9d22e78d5f0059aeb0f822064af6ed5b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isSkyPlaneEnabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a key plane is enabled. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01754">1754</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f4199356f06cd6fd64c1257806e5e94f"></a><!-- doxytag: member="Ogre::SceneManager::getSkyPlaneNode" ref="f4199356f06cd6fd64c1257806e5e94f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneManager::getSkyPlaneNode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the sky plane node, if enabled. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01757">1757</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="68bd19b47ed424ebda3a7987a6d1c289"></a><!-- doxytag: member="Ogre::SceneManager::getSkyPlaneGenParameters" ref="68bd19b47ed424ebda3a7987a6d1c289" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structOgre_1_1SceneManager_1_1SkyPlaneGenParameters.html">SkyPlaneGenParameters</a>&amp; Ogre::SceneManager::getSkyPlaneGenParameters           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the parameters used to construct the SkyPlane, if any. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01760">1760</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f419fca38294bef65224162b3ad4af36"></a><!-- doxytag: member="Ogre::SceneManager::setSkyBox" ref="f419fca38294bef65224162b3ad4af36" args="(bool enable, const String &amp;materialName, Real distance=5000, bool drawFirst=true, const Quaternion &amp;orientation=Quaternion::IDENTITY, const String &amp;groupName=ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSkyBox           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em> = <code>5000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>drawFirst</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orientation</em> = <code><a class="el" href="classOgre_1_1Quaternion.html#441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupName</em> = <code><a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables / disables a 'sky box' i.e. 
<p>
a 6-sided box at constant distance from the camera representing the sky. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as the <a class="el" href="classOgre_1_1Camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> class for more information. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>True to enable the skybox, false to disable it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>materialName</em>&nbsp;</td><td>The name of the material the box will use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>drawFirst</em>&nbsp;</td><td>If true, the box is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws <em>after</em> all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky box when it is rendered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orientation</em>&nbsp;</td><td>Optional parameter to specify the orientation of the box. By default the 'top' of the box is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1dd29bf89d777d7c2b032ebffca7e8d5"></a><!-- doxytag: member="Ogre::SceneManager::_setSkyBox" ref="1dd29bf89d777d7c2b032ebffca7e8d5" args="(bool enable, const String &amp;materialName, Real distance=5000, uint8 renderQueue=RENDER_QUEUE_SKIES_EARLY, const Quaternion &amp;orientation=Quaternion::IDENTITY, const String &amp;groupName=ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_setSkyBox           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em> = <code>5000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>renderQueue</em> = <code>RENDER_QUEUE_SKIES_EARLY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orientation</em> = <code><a class="el" href="classOgre_1_1Quaternion.html#441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupName</em> = <code><a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables / disables a 'sky box' i.e. 
<p>
a 6-sided box at constant distance from the camera representing the sky. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> as the <a class="el" href="classOgre_1_1Camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> class for more information. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>True to enable the skybox, false to disable it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>materialName</em>&nbsp;</td><td>The name of the material the box will use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>renderQueue</em>&nbsp;</td><td>The render queue to use when rendering this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orientation</em>&nbsp;</td><td>Optional parameter to specify the orientation of the box. By default the 'top' of the box is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1209e1308df35bae42460f8aece7549b"></a><!-- doxytag: member="Ogre::SceneManager::isSkyBoxEnabled" ref="1209e1308df35bae42460f8aece7549b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isSkyBoxEnabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a skybox is enabled. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01846">1846</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3092d641b3b6697fa12517898463c49b"></a><!-- doxytag: member="Ogre::SceneManager::getSkyBoxNode" ref="3092d641b3b6697fa12517898463c49b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneManager::getSkyBoxNode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the skybox node, if enabled. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01849">1849</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ca48eb6f90fcd5f169c94ad3d1a27ef6"></a><!-- doxytag: member="Ogre::SceneManager::getSkyBoxGenParameters" ref="ca48eb6f90fcd5f169c94ad3d1a27ef6" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structOgre_1_1SceneManager_1_1SkyBoxGenParameters.html">SkyBoxGenParameters</a>&amp; Ogre::SceneManager::getSkyBoxGenParameters           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the parameters used to generate the current SkyBox, if any. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01852">1852</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="dd758e3fa5df1291df9ff98b2594d35b"></a><!-- doxytag: member="Ogre::SceneManager::setSkyDome" ref="dd758e3fa5df1291df9ff98b2594d35b" args="(bool enable, const String &amp;materialName, Real curvature=10, Real tiling=8, Real distance=4000, bool drawFirst=true, const Quaternion &amp;orientation=Quaternion::IDENTITY, int xsegments=16, int ysegments=16, int ysegments_keep=-1, const String &amp;groupName=ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSkyDome           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>curvature</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>tiling</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em> = <code>4000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>drawFirst</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orientation</em> = <code><a class="el" href="classOgre_1_1Quaternion.html#441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>xsegments</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ysegments</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ysegments_keep</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupName</em> = <code><a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables / disables a 'sky dome' i.e. 
<p>
an illusion of a curved sky. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>True to enable the skydome, false to disable it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>materialName</em>&nbsp;</td><td>The name of the material the dome will use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curvature</em>&nbsp;</td><td>The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tiling</em>&nbsp;</td><td>How many times to tile the texture(s) across the dome. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>drawFirst</em>&nbsp;</td><td>If true, the dome is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws <em>after</em> all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky when it is rendered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orientation</em>&nbsp;</td><td>Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a6eea5fcfe5a6210a5db044e14a525f8"></a><!-- doxytag: member="Ogre::SceneManager::_setSkyDome" ref="a6eea5fcfe5a6210a5db044e14a525f8" args="(bool enable, const String &amp;materialName, Real curvature=10, Real tiling=8, Real distance=4000, uint8 renderQueue=RENDER_QUEUE_SKIES_EARLY, const Quaternion &amp;orientation=Quaternion::IDENTITY, int xsegments=16, int ysegments=16, int ysegments_keep=-1, const String &amp;groupName=ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_setSkyDome           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>curvature</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>tiling</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em> = <code>4000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>renderQueue</em> = <code>RENDER_QUEUE_SKIES_EARLY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>orientation</em> = <code><a class="el" href="classOgre_1_1Quaternion.html#441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>xsegments</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ysegments</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ysegments_keep</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>groupName</em> = <code><a class="el" href="classOgre_1_1ResourceGroupManager.html#62561ccf5ff323942a9a4fab94bee7e3">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables / disables a 'sky dome' i.e. 
<p>
an illusion of a curved sky. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>True to enable the skydome, false to disable it </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>materialName</em>&nbsp;</td><td>The name of the material the dome will use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>curvature</em>&nbsp;</td><td>The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tiling</em>&nbsp;</td><td>How many times to tile the texture(s) across the dome. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>renderQueue</em>&nbsp;</td><td>The render queue to use when rendering this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orientation</em>&nbsp;</td><td>Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the resource group to which to assign the plane mesh. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="418e075ad2d68dec59105f743fccdae8"></a><!-- doxytag: member="Ogre::SceneManager::isSkyDomeEnabled" ref="418e075ad2d68dec59105f743fccdae8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isSkyDomeEnabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return whether a skydome is enabled. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01970">1970</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b48d1e49e2b176863c72af383b86120e"></a><!-- doxytag: member="Ogre::SceneManager::getSkyDomeNode" ref="b48d1e49e2b176863c72af383b86120e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* Ogre::SceneManager::getSkyDomeNode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the sky dome node, if enabled. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01973">1973</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6af078e9234b8d90812ca46a7dd7151b"></a><!-- doxytag: member="Ogre::SceneManager::getSkyDomeGenParameters" ref="6af078e9234b8d90812ca46a7dd7151b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structOgre_1_1SceneManager_1_1SkyDomeGenParameters.html">SkyDomeGenParameters</a>&amp; Ogre::SceneManager::getSkyDomeGenParameters           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the parameters used to generate the current SkyDome, if any. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l01976">1976</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b804195c05873da617dcd16198a63d1c"></a><!-- doxytag: member="Ogre::SceneManager::setFog" ref="b804195c05873da617dcd16198a63d1c" args="(FogMode mode=FOG_NONE, const ColourValue &amp;colour=ColourValue::White, Real expDensity=0.001, Real linearStart=0.0, Real linearEnd=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::setFog           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FOG_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colour</em> = <code><a class="el" href="classOgre_1_1ColourValue.html#8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>expDensity</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>linearStart</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>linearEnd</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the fogging mode applied to the scene. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method sets up the scene-wide fogging effect. These settings apply to all geometry rendered, UNLESS the material with which it is rendered has it's own fog settings (see <a class="el" href="classOgre_1_1Material.html#32937d27d1a0211a76d9ce8035a221ee" title="Sets the fogging mode applied to each pass.">Material::setFog</a>). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colour</em>&nbsp;</td><td>The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expDensity</em>&nbsp;</td><td>The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>linearStart</em>&nbsp;</td><td>Distance in world units at which linear fog starts to encroach. Only applicable if mode is FOG_LINEAR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>linearEnd</em>&nbsp;</td><td>Distance in world units at which linear fog becomes completely opaque. Only applicable if mode is FOG_LINEAR. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="361b6c81efb56c75fd70b5c6e357c3b3"></a><!-- doxytag: member="Ogre::SceneManager::getFogMode" ref="361b6c81efb56c75fd70b5c6e357c3b3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> Ogre::SceneManager::getFogMode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the fog mode for the scene. 
<p>

</div>
</div><p>
<a class="anchor" name="306704e4889173ad708e1d0f5d7e3930"></a><!-- doxytag: member="Ogre::SceneManager::getFogColour" ref="306704e4889173ad708e1d0f5d7e3930" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a>&amp; Ogre::SceneManager::getFogColour           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the fog colour for the scene. 
<p>

</div>
</div><p>
<a class="anchor" name="b1a6c6d9e62244cf7b179920241d1f60"></a><!-- doxytag: member="Ogre::SceneManager::getFogStart" ref="b1a6c6d9e62244cf7b179920241d1f60" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getFogStart           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the fog start distance for the scene. 
<p>

</div>
</div><p>
<a class="anchor" name="685fdcd7904870ecff70e6cf7e962ca4"></a><!-- doxytag: member="Ogre::SceneManager::getFogEnd" ref="685fdcd7904870ecff70e6cf7e962ca4" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getFogEnd           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the fog end distance for the scene. 
<p>

</div>
</div><p>
<a class="anchor" name="251033c27ac5d12c4f9bb2eee43b4d6a"></a><!-- doxytag: member="Ogre::SceneManager::getFogDensity" ref="251033c27ac5d12c4f9bb2eee43b4d6a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getFogDensity           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the fog density for the scene. 
<p>

</div>
</div><p>
<a class="anchor" name="e4d6f699a273cf16a8ce09757ebf8baf"></a><!-- doxytag: member="Ogre::SceneManager::createBillboardSet" ref="e4d6f699a273cf16a8ce09757ebf8baf" args="(const String &amp;name, unsigned int poolSize=20)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1BillboardSet.html">BillboardSet</a>* Ogre::SceneManager::createBillboardSet           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>poolSize</em> = <code>20</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> for use with this scene manager. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method creates a new <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> which is registered with the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. The <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> will destroy this object when it shuts down or when the <a class="el" href="classOgre_1_1SceneManager.html#a5b2047b5740b691b0e636d57f2dba7e" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets...">SceneManager::clearScene</a> method is called, so the caller does not have to worry about destroying this object (in fact, it definitely should not do this). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>See the <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> documentations for full details of the returned class. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to give to this billboard set. Must be unique. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poolSize</em>&nbsp;</td><td>The initial size of the pool of billboards (see <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> for more information) </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f244f7e07456f6ababa2fa97399627fd"></a><!-- doxytag: member="Ogre::SceneManager::getBillboardSet" ref="f244f7e07456f6ababa2fa97399627fd" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1BillboardSet.html">BillboardSet</a>* Ogre::SceneManager::getBillboardSet           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a pointer to the named <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="8227de25c67053821c2bfbdf9b27504b"></a><!-- doxytag: member="Ogre::SceneManager::hasBillboardSet" ref="8227de25c67053821c2bfbdf9b27504b" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasBillboardSet           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a billboardset with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="86252d84802cb54bba22bd8ed87d84f0"></a><!-- doxytag: member="Ogre::SceneManager::destroyBillboardSet" ref="86252d84802cb54bba22bd8ed87d84f0" args="(BillboardSet *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyBillboardSet           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1BillboardSet.html">BillboardSet</a> *&nbsp;</td>
          <td class="paramname"> <em>set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys an <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Must only be done if the <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> is not attached to a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. It may be safer to wait to clear the whole scene. If you are unsure, use clearScene. </dd></dl>

</div>
</div><p>
<a class="anchor" name="56ecce16952d08b045e500d28981d307"></a><!-- doxytag: member="Ogre::SceneManager::destroyBillboardSet" ref="56ecce16952d08b045e500d28981d307" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyBillboardSet           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys an <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> from the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> by name. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Must only be done if the <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> is not attached to a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a>. It may be safer to wait to clear the whole scene. If you are unsure, use clearScene. </dd></dl>

</div>
</div><p>
<a class="anchor" name="62742f3922523e75b72f6e8303fea251"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllBillboardSets" ref="62742f3922523e75b72f6e8303fea251" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllBillboardSets           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes &amp; destroys all BillboardSets. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Again, use caution since no <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with...">BillboardSet</a> must be referred to elsewhere e.g. attached to a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> otherwise a crash is likely. Use clearScene if you are unsure (it clears <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> entries too.) </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#a5b2047b5740b691b0e636d57f2dba7e" title="Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets...">SceneManager::clearScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="46c5cbc33b0f498ed01670289e87584c"></a><!-- doxytag: member="Ogre::SceneManager::setDisplaySceneNodes" ref="46c5cbc33b0f498ed01670289e87584c" args="(bool display)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setDisplaySceneNodes           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>display</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> whether it should render the SceneNodes which make up the scene as well as the objects in the scene. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method is mainly for debugging purposes. If you set this to 'true', each node will be rendered as a set of 3 axes to allow you to easily see the orientation of the nodes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="abe2da637fd725bf8326c662a019f4d3"></a><!-- doxytag: member="Ogre::SceneManager::getDisplaySceneNodes" ref="abe2da637fd725bf8326c662a019f4d3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getDisplaySceneNodes           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if all scene nodes axis are to be displayed. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02090">2090</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8ffb7989a0db906222663ff2d34317ea"></a><!-- doxytag: member="Ogre::SceneManager::createAnimation" ref="8ffb7989a0db906222663ff2d34317ea" args="(const String &amp;name, Real length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Animation.html">Animation</a>* Ogre::SceneManager::createAnimation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an animation which can be used to animate scene nodes. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>An animation is a collection of 'tracks' which over time change the position / orientation of <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> objects. In this case, the animation will likely have tracks to modify the position / orientation of <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> objects, e.g. to make objects move along a path. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>You don't need to use an <a class="el" href="classOgre_1_1Animation.html" title="An animation sequence.">Animation</a> object to move objects around - you can do it yourself using the methods of the <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> in your <a class="el" href="classOgre_1_1FrameListener.html" title="A interface class defining a listener which can be used to receive notifications...">FrameListener</a> class. However, when you need relatively complex scripted animation, this is the class to use since it will interpolate between keyframes for you and generally make the whole process easier to manage. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>A single animation can affect multiple <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> objects (each <a class="el" href="classOgre_1_1AnimationTrack.html" title="A &#39;track&#39; in an animation sequence, i.e.">AnimationTrack</a> affects a single <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>). In addition, through animation blending a single <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> can be affected by multiple animations, athough this is more useful when performing skeletal animation (see <a class="el" href="classOgre_1_1Skeleton.html#affbdd130cfc11e8b61fb1ed76486a78" title="Creates a new Animation object for animating this skeleton.">Skeleton::createAnimation</a>). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that whilst it uses the same classes, the animations created here are kept separate from the skeletal animations of meshes (each <a class="el" href="classOgre_1_1Skeleton.html" title="A collection of Bone objects used to animate a skinned mesh.">Skeleton</a> owns those animations). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the animation, must be unique within this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The total length of the animation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ba18a3e34e9ee8c286b6b4dfff42011"></a><!-- doxytag: member="Ogre::SceneManager::getAnimation" ref="7ba18a3e34e9ee8c286b6b4dfff42011" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1Animation.html">Animation</a>* Ogre::SceneManager::getAnimation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Looks up an <a class="el" href="classOgre_1_1Animation.html" title="An animation sequence.">Animation</a> object previously created with createAnimation. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="a88f44e5200e790105cb18814bdee7e5"></a><!-- doxytag: member="Ogre::SceneManager::hasAnimation" ref="a88f44e5200e790105cb18814bdee7e5" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasAnimation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether an animation with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="7ac4e76d36c8f059d7389bf1233563b5"></a><!-- doxytag: member="Ogre::SceneManager::destroyAnimation" ref="7ac4e76d36c8f059d7389bf1233563b5" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAnimation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys an <a class="el" href="classOgre_1_1Animation.html" title="An animation sequence.">Animation</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You should ensure that none of your code is referencing this animation objects since the memory will be freed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="019a31618f2285f79be2b414488c04c3"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllAnimations" ref="019a31618f2285f79be2b414488c04c3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllAnimations           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all animations created using this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="3e060f962b38c9e9f43f8618ff652ea3"></a><!-- doxytag: member="Ogre::SceneManager::createAnimationState" ref="3e060f962b38c9e9f43f8618ff652ea3" args="(const String &amp;animName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1AnimationState.html">AnimationState</a>* Ogre::SceneManager::createAnimationState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>animName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an <a class="el" href="classOgre_1_1AnimationState.html" title="Represents the state of an animation and the weight of it&#39;s influence.">AnimationState</a> object for managing application of animations. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You can create <a class="el" href="classOgre_1_1Animation.html" title="An animation sequence.">Animation</a> objects for animating <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> obejcts using the createAnimation method. However, in order to actually apply those animations you have to call methods on <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> and <a class="el" href="classOgre_1_1Animation.html" title="An animation sequence.">Animation</a> in a particular order (namely <a class="el" href="classOgre_1_1Node.html#10b19feffaf2d215682ba1aca8d07038" title="Resets the position / orientation / scale of this node to it&#39;s initial state...">Node::resetToInitialState</a> and <a class="el" href="classOgre_1_1Animation.html#a79ff8a4ddeb63225e6d68f6a16e9a24" title="Applies an animation given a specific time point and weight.">Animation::apply</a>). To make this easier and to help track the current time position of animations, the <a class="el" href="classOgre_1_1AnimationState.html" title="Represents the state of an animation and the weight of it&#39;s influence.">AnimationState</a> object is provided.  So if you don't want to control animation application manually, call this method, update the returned object as you like every frame and let <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> apply the animation state for you. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Remember, <a class="el" href="classOgre_1_1AnimationState.html" title="Represents the state of an animation and the weight of it&#39;s influence.">AnimationState</a> objects are disabled by default at creation time. Turn them on when you want them using their setEnabled method. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that any <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> affected by this automatic animation will have it's state reset to it's initial position before application of the animation. Unless specifically modified using <a class="el" href="classOgre_1_1Node.html#8119af87243123929da530b01dd54fd4" title="Sets the current transform of this node to be the &#39;initial state&#39; ie that...">Node::setInitialState</a> the <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> assumes it's initial state is at the origin. If you want the base state of the <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> to be elsewhere, make your changes to the node using the standard transform methods, then call setInitialState to 'bake' this reference position into the node. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>If the target of your animation is to be a generic <a class="el" href="classOgre_1_1AnimableValue.html" title="Defines an object property which is animable, i.e.">AnimableValue</a>, you should ensure that it has a base value set (unlike nodes this has no default). </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1AnimableValue.html#acef098935627873fd41f7b3bd37d3cf" title="Internal method to set a value as base.">AnimableValue::setAsBaseValue</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>animName</em>&nbsp;</td><td>The name of an animation created already with createAnimation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e4d6cc4ff860b1e8f73ec9d3a9a960a9"></a><!-- doxytag: member="Ogre::SceneManager::getAnimationState" ref="e4d6cc4ff860b1e8f73ec9d3a9a960a9" args="(const String &amp;animName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1AnimationState.html">AnimationState</a>* Ogre::SceneManager::getAnimationState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>animName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves animation state as previously created using createAnimationState. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="08510a6f311d26de3a385b809bb51c32"></a><!-- doxytag: member="Ogre::SceneManager::hasAnimationState" ref="08510a6f311d26de3a385b809bb51c32" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasAnimationState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether an animation state with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="22a3f58bff113aaac870c18741f7cd76"></a><!-- doxytag: member="Ogre::SceneManager::destroyAnimationState" ref="22a3f58bff113aaac870c18741f7cd76" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAnimationState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys an <a class="el" href="classOgre_1_1AnimationState.html" title="Represents the state of an animation and the weight of it&#39;s influence.">AnimationState</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You should ensure that none of your code is referencing this animation state object since the memory will be freed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a60a84672be1f532323cdb5dbfdc2c66"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllAnimationStates" ref="a60a84672be1f532323cdb5dbfdc2c66" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllAnimationStates           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all animation states created using this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="16f971d1a34ce55b83c16634a56e2b6a"></a><!-- doxytag: member="Ogre::SceneManager::manualRender" ref="16f971d1a34ce55b83c16634a56e2b6a" args="(RenderOperation *rend, Pass *pass, Viewport *vp, const Matrix4 &amp;worldMatrix, const Matrix4 &amp;viewMatrix, const Matrix4 &amp;projMatrix, bool doBeginEndFrame=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::manualRender           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderOperation.html">RenderOperation</a> *&nbsp;</td>
          <td class="paramname"> <em>rend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td>
          <td class="paramname"> <em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a> *&nbsp;</td>
          <td class="paramname"> <em>vp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>worldMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>viewMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>projMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doBeginEndFrame</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Manual rendering method, for advanced users only. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method allows you to send rendering commands through the pipeline on demand, bypassing OGRE's normal world processing. You should only use this if you really know what you're doing; OGRE does lots of things for you that you really should let it do. However, there are times where it may be useful to have this manual interface, for example overlaying something on top of the scene rendered by OGRE. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Because this is an instant rendering method, timing is important. The best time to call it is from a <a class="el" href="classOgre_1_1RenderTargetListener.html" title="A interface class defining a listener which can be used to receive notifications...">RenderTargetListener</a> event handler. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Don't call this method a lot, it's designed for rare (1 or 2 times per frame) use. Calling it regularly per frame will cause frame rate drops! </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rend</em>&nbsp;</td><td>A <a class="el" href="classOgre_1_1RenderOperation.html" title="&#39;New&#39; rendering operation using vertex buffers.">RenderOperation</a> object describing the rendering op </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pass</em>&nbsp;</td><td>The <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> to use for this render </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vp</em>&nbsp;</td><td>Pointer to the viewport to render to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>worldMatrix</em>&nbsp;</td><td>The transform to apply from object to world space </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>viewMatrix</em>&nbsp;</td><td>The transform to apply from world to view space </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>projMatrix</em>&nbsp;</td><td>The transform to apply from view to screen space </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doBeginEndFrame</em>&nbsp;</td><td>If true, beginFrame() and endFrame() are called, otherwise not. You should leave this as false if you are calling this within the main render loop. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8accbffd3a95901ac09bc32784b2e27d"></a><!-- doxytag: member="Ogre::SceneManager::getRenderQueue" ref="8accbffd3a95901ac09bc32784b2e27d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a>* Ogre::SceneManager::getRenderQueue           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the internal render queue, for advanced users only. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The render queue is mainly used internally to manage the scene object rendering queue, it also exports some methods to allow advanced users to configure the behavior of rendering process. Most methods provided by <a class="el" href="classOgre_1_1RenderQueue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a> are supposed to be used internally only, you should reference to the <a class="el" href="classOgre_1_1RenderQueue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a> API for more information. Do not access this directly unless you know what you are doing. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e60242c5d130f884cd605d3393186df6"></a><!-- doxytag: member="Ogre::SceneManager::addRenderQueueListener" ref="e60242c5d130f884cd605d3393186df6" args="(RenderQueueListener *newListener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::addRenderQueueListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueListener.html">RenderQueueListener</a> *&nbsp;</td>
          <td class="paramname"> <em>newListener</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a new <a class="el" href="classOgre_1_1RenderQueueListener.html" title="Abstract interface which classes must implement if they wish to receive events from...">RenderQueueListener</a> which will be notified when render queues are processed. 
<p>

</div>
</div><p>
<a class="anchor" name="190471ba7a61111d576a1e8ca9862706"></a><!-- doxytag: member="Ogre::SceneManager::removeRenderQueueListener" ref="190471ba7a61111d576a1e8ca9862706" args="(RenderQueueListener *delListener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::removeRenderQueueListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueListener.html">RenderQueueListener</a> *&nbsp;</td>
          <td class="paramname"> <em>delListener</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a listener previously added with addRenderQueueListener. 
<p>

</div>
</div><p>
<a class="anchor" name="80869e48b56b0c02a52e9027cad26fa7"></a><!-- doxytag: member="Ogre::SceneManager::addSpecialCaseRenderQueue" ref="80869e48b56b0c02a52e9027cad26fa7" args="(uint8 qid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::addSpecialCaseRenderQueue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>qid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an item to the 'special case' render queue list. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Normally all render queues are rendered, in their usual sequence, only varying if a <a class="el" href="classOgre_1_1RenderQueueListener.html" title="Abstract interface which classes must implement if they wish to receive events from...">RenderQueueListener</a> nominates for the queue to be repeated or skipped. This method allows you to add a render queue to a 'special case' list, which varies the behaviour. The effect of this list depends on the 'mode' in which this list is in, which might be to exclude these render queues, or to include them alone (excluding all other queues). This allows you to perform broad selective rendering without requiring a <a class="el" href="classOgre_1_1RenderQueueListener.html" title="Abstract interface which classes must implement if they wish to receive events from...">RenderQueueListener</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qid</em>&nbsp;</td><td>The identifier of the queue which should be added to the special case list. Nothing happens if the queue is already in the list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5683d75af7c73bfdd9db2b9185b99a53"></a><!-- doxytag: member="Ogre::SceneManager::removeSpecialCaseRenderQueue" ref="5683d75af7c73bfdd9db2b9185b99a53" args="(uint8 qid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::removeSpecialCaseRenderQueue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>qid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an item to the 'special case' render queue list. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#80869e48b56b0c02a52e9027cad26fa7" title="Adds an item to the &#39;special case&#39; render queue list.">SceneManager::addSpecialCaseRenderQueue</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qid</em>&nbsp;</td><td>The identifier of the queue which should be removed from the special case list. Nothing happens if the queue is not in the list. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cfc2cc0a7f105a068603955c4dbbe3c4"></a><!-- doxytag: member="Ogre::SceneManager::clearSpecialCaseRenderQueues" ref="cfc2cc0a7f105a068603955c4dbbe3c4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::clearSpecialCaseRenderQueues           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the 'special case' render queue list. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#80869e48b56b0c02a52e9027cad26fa7" title="Adds an item to the &#39;special case&#39; render queue list.">SceneManager::addSpecialCaseRenderQueue</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="10753c0e57be813e135395e3a882777a"></a><!-- doxytag: member="Ogre::SceneManager::setSpecialCaseRenderQueueMode" ref="10753c0e57be813e135395e3a882777a" args="(SpecialCaseRenderQueueMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setSpecialCaseRenderQueueMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6">SpecialCaseRenderQueueMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the way the special case render queue list is processed. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#80869e48b56b0c02a52e9027cad26fa7" title="Adds an item to the &#39;special case&#39; render queue list.">SceneManager::addSpecialCaseRenderQueue</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode of processing </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ed183c1907c928f384cd087b40a3f685"></a><!-- doxytag: member="Ogre::SceneManager::getSpecialCaseRenderQueueMode" ref="ed183c1907c928f384cd087b40a3f685" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6">SpecialCaseRenderQueueMode</a> Ogre::SceneManager::getSpecialCaseRenderQueueMode           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the way the special case render queue list is processed. 
<p>

</div>
</div><p>
<a class="anchor" name="bdf79b63bce9f65571359c96a585eb9f"></a><!-- doxytag: member="Ogre::SceneManager::isRenderQueueToBeProcessed" ref="bdf79b63bce9f65571359c96a585eb9f" args="(uint8 qid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isRenderQueueToBeProcessed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>qid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether or not the named queue will be rendered based on the current 'special case' render queue list and mode. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#80869e48b56b0c02a52e9027cad26fa7" title="Adds an item to the &#39;special case&#39; render queue list.">SceneManager::addSpecialCaseRenderQueue</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>qid</em>&nbsp;</td><td>The identifier of the queue which should be tested </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the queue will be rendered, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="3c0437a615af536aaf69ba267f2f15d2"></a><!-- doxytag: member="Ogre::SceneManager::setWorldGeometryRenderQueue" ref="3c0437a615af536aaf69ba267f2f15d2" args="(uint8 qid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setWorldGeometryRenderQueue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&nbsp;</td>
          <td class="paramname"> <em>qid</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the render queue that the world geometry (if any) this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> renders will be associated with. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>SceneManagers which provide 'world geometry' should place it in a specialised render queue in order to make it possible to enable / disable it easily using the addSpecialCaseRenderQueue method. Even if the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> does not use the render queues to render the world geometry, it should still pick a queue to represent it's manual rendering, and check isRenderQueueToBeProcessed before rendering. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Setting this may not affect the actual ordering of rendering the world geometry, if the world geometry is being rendered manually by the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. If the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> feeds world geometry into the queues, however, the ordering will be affected. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f036aed42b3e7480915704f29865c788"></a><!-- doxytag: member="Ogre::SceneManager::getWorldGeometryRenderQueue" ref="f036aed42b3e7480915704f29865c788" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::SceneManager::getWorldGeometryRenderQueue           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the render queue that the world geometry (if any) this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> renders will be associated with. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>SceneManagers which provide 'world geometry' should place it in a specialised render queue in order to make it possible to enable / disable it easily using the addSpecialCaseRenderQueue method. Even if the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> does not use the render queues to render the world geometry, it should still pick a queue to represent it's manual rendering, and check isRenderQueueToBeProcessed before rendering. </dd></dl>

</div>
</div><p>
<a class="anchor" name="487859007d68fe9f261aea1645252563"></a><!-- doxytag: member="Ogre::SceneManager::showBoundingBoxes" ref="487859007d68fe9f261aea1645252563" args="(bool bShow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::showBoundingBoxes           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bShow</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows all bounding boxes of scene nodes to be displayed. 
<p>

</div>
</div><p>
<a class="anchor" name="a22b0b7e88539bb34a5c9c309c87bd34"></a><!-- doxytag: member="Ogre::SceneManager::getShowBoundingBoxes" ref="a22b0b7e88539bb34a5c9c309c87bd34" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getShowBoundingBoxes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if all bounding boxes of scene nodes are to be displayed. 
<p>

</div>
</div><p>
<a class="anchor" name="ae9af47cfe8ae3184744e9d19d73341f"></a><!-- doxytag: member="Ogre::SceneManager::_notifyAutotrackingSceneNode" ref="ae9af47cfe8ae3184744e9d19d73341f" args="(SceneNode *node, bool autoTrack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_notifyAutotrackingSceneNode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoTrack</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for notifying the manager that a <a class="el" href="classOgre_1_1SceneNode.html" title="Class representing a node in the scene graph.">SceneNode</a> is autotracking. 
<p>

</div>
</div><p>
<a class="anchor" name="acbb49cc9b31adb40d3bbddc8f51d89a"></a><!-- doxytag: member="Ogre::SceneManager::createAABBQuery" ref="acbb49cc9b31adb40d3bbddc8f51d89a" args="(const AxisAlignedBox &amp;box, unsigned long mask=0xFFFFFFFF)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1AxisAlignedBoxSceneQuery.html">AxisAlignedBoxSceneQuery</a>* Ogre::SceneManager::createAABBQuery           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mask</em> = <code>0xFFFFFFFF</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="classOgre_1_1AxisAlignedBoxSceneQuery.html" title="Specialises the SceneQuery class for querying within an axis aligned box.">AxisAlignedBoxSceneQuery</a> for this scene manager. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method creates a new instance of a query object for this scene manager, for an axis aligned box region. See <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> and <a class="el" href="classOgre_1_1AxisAlignedBoxSceneQuery.html" title="Specialises the SceneQuery class for querying within an axis aligned box.">AxisAlignedBoxSceneQuery</a> for full details. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="classOgre_1_1SceneManager.html#08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type.">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>box</em>&nbsp;</td><td>Details of the box which describes the region for this query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> for details. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40730811207d2a7ef8f8fc0c3fda8b91"></a><!-- doxytag: member="Ogre::SceneManager::createSphereQuery" ref="40730811207d2a7ef8f8fc0c3fda8b91" args="(const Sphere &amp;sphere, unsigned long mask=0xFFFFFFFF)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1SphereSceneQuery.html">SphereSceneQuery</a>* Ogre::SceneManager::createSphereQuery           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Sphere.html">Sphere</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mask</em> = <code>0xFFFFFFFF</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classOgre_1_1SphereSceneQuery.html" title="Specialises the SceneQuery class for querying within a sphere.">SphereSceneQuery</a> for this scene manager. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method creates a new instance of a query object for this scene manager, for a spherical region. See <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> and <a class="el" href="classOgre_1_1SphereSceneQuery.html" title="Specialises the SceneQuery class for querying within a sphere.">SphereSceneQuery</a> for full details. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="classOgre_1_1SceneManager.html#08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type.">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sphere</em>&nbsp;</td><td>Details of the sphere which describes the region for this query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> for details. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cc61e987518b30805120ac4009b5dd33"></a><!-- doxytag: member="Ogre::SceneManager::createPlaneBoundedVolumeQuery" ref="cc61e987518b30805120ac4009b5dd33" args="(const PlaneBoundedVolumeList &amp;volumes, unsigned long mask=0xFFFFFFFF)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1PlaneBoundedVolumeListSceneQuery.html">PlaneBoundedVolumeListSceneQuery</a>* Ogre::SceneManager::createPlaneBoundedVolumeQuery           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f6bda7879d1ac92561a02cbd1833e1b1">PlaneBoundedVolumeList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>volumes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mask</em> = <code>0xFFFFFFFF</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classOgre_1_1PlaneBoundedVolumeListSceneQuery.html" title="Specialises the SceneQuery class for querying within a plane-bounded volume.">PlaneBoundedVolumeListSceneQuery</a> for this scene manager. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method creates a new instance of a query object for this scene manager, for a region enclosed by a set of planes (normals pointing inwards). See <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> and <a class="el" href="classOgre_1_1PlaneBoundedVolumeListSceneQuery.html" title="Specialises the SceneQuery class for querying within a plane-bounded volume.">PlaneBoundedVolumeListSceneQuery</a> for full details. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="classOgre_1_1SceneManager.html#08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type.">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>volumes</em>&nbsp;</td><td>Details of the volumes which describe the region for this query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> for details. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="95a6c54fd3bf3e9a3c4d16cc7dc67d5c"></a><!-- doxytag: member="Ogre::SceneManager::createRayQuery" ref="95a6c54fd3bf3e9a3c4d16cc7dc67d5c" args="(const Ray &amp;ray, unsigned long mask=0xFFFFFFFF)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1RaySceneQuery.html">RaySceneQuery</a>* Ogre::SceneManager::createRayQuery           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Ray.html">Ray</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mask</em> = <code>0xFFFFFFFF</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classOgre_1_1RaySceneQuery.html" title="Specialises the SceneQuery class for querying along a ray.">RaySceneQuery</a> for this scene manager. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method creates a new instance of a query object for this scene manager, looking for objects which fall along a ray. See <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> and <a class="el" href="classOgre_1_1RaySceneQuery.html" title="Specialises the SceneQuery class for querying along a ray.">RaySceneQuery</a> for full details. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="classOgre_1_1SceneManager.html#08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type.">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ray</em>&nbsp;</td><td>Details of the ray which describes the region for this query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> for details. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="82b0c69188695880a693df4e6392ebba"></a><!-- doxytag: member="Ogre::SceneManager::createIntersectionQuery" ref="82b0c69188695880a693df4e6392ebba" args="(unsigned long mask=0xFFFFFFFF)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1IntersectionSceneQuery.html">IntersectionSceneQuery</a>* Ogre::SceneManager::createIntersectionQuery           </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>mask</em> = <code>0xFFFFFFFF</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="classOgre_1_1IntersectionSceneQuery.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting...">IntersectionSceneQuery</a> for this scene manager. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method creates a new instance of a query object for locating intersecting objects. See <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> and <a class="el" href="classOgre_1_1IntersectionSceneQuery.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting...">IntersectionSceneQuery</a> for full details. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The instance returned from this method must be destroyed by calling <a class="el" href="classOgre_1_1SceneManager.html#08f7adf5f342c6808481fa922c8c62a0" title="Destroys a scene query of any type.">SceneManager::destroyQuery</a> when it is no longer required. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The query mask to apply to this query; can be used to filter out certain objects; see <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> for details. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="08f7adf5f342c6808481fa922c8c62a0"></a><!-- doxytag: member="Ogre::SceneManager::destroyQuery" ref="08f7adf5f342c6808481fa922c8c62a0" args="(SceneQuery *query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyQuery           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneQuery.html">SceneQuery</a> *&nbsp;</td>
          <td class="paramname"> <em>query</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a scene query of any type. 
<p>

</div>
</div><p>
<a class="anchor" name="02d7d29cc4bc8ee4cbe40d16a984291c"></a><!-- doxytag: member="Ogre::SceneManager::getCameraIterator" ref="02d7d29cc4bc8ee4cbe40d16a984291c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MapIterator.html">CameraIterator</a> Ogre::SceneManager::getCameraIterator           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a specialised <a class="el" href="classOgre_1_1MapIterator.html" title="Wraps iteration over a map.">MapIterator</a> over all cameras in the scene. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02384">2384</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b28450738168fe330709ad0d090df6b5"></a><!-- doxytag: member="Ogre::SceneManager::getAnimationIterator" ref="b28450738168fe330709ad0d090df6b5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MapIterator.html">AnimationIterator</a> Ogre::SceneManager::getAnimationIterator           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a specialised <a class="el" href="classOgre_1_1MapIterator.html" title="Wraps iteration over a map.">MapIterator</a> over all animations in the scene. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02388">2388</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="39bf64e686d94b6856d3ff06d627b61c"></a><!-- doxytag: member="Ogre::SceneManager::getAnimationStateIterator" ref="39bf64e686d94b6856d3ff06d627b61c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MapIterator.html">AnimationStateIterator</a> Ogre::SceneManager::getAnimationStateIterator           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a specialised <a class="el" href="classOgre_1_1MapIterator.html" title="Wraps iteration over a map.">MapIterator</a> over all animation states in the scene. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02392">2392</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0f8f32d176059a385527cf9970ddc892"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTechnique" ref="0f8f32d176059a385527cf9970ddc892" args="(ShadowTechnique technique)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTechnique           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#79dcd426d291c31072c1ad6f183715d6">ShadowTechnique</a>&nbsp;</td>
          <td class="paramname"> <em>technique</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the general shadow technique to be used in this scene. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>There are multiple ways to generate shadows in a scene, and each has strengths and weaknesses. <ul>
<li>
Stencil-based approaches can be used to draw very long, extreme shadows without loss of precision and the 'additive' version can correctly show the shadowing of complex effects like bump mapping because they physically exclude the light from those areas. However, the edges are very sharp and stencils cannot handle transparency, and they involve a fair amount of CPU work in order to calculate the shadow volumes, especially when animated objects are involved. </li>
<li>
Texture-based approaches are good for handling transparency (they can, for example, correctly shadow a mesh which uses alpha to represent holes), and they require little CPU overhead, and can happily shadow geometry which is deformed by a vertex program, unlike stencil shadows. However, they have a fixed precision which can introduce 'jaggies' at long range and have fillrate issues of their own. </li>
</ul>
</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>We support 2 kinds of stencil shadows, and 2 kinds of texture-based shadows, and one simple decal approach. The 2 stencil approaches differ in the amount of multipass work that is required - the modulative approach simply 'darkens' areas in shadow after the main render, which is the least expensive, whilst the additive approach has to perform a render per light and adds the cumulative effect, whcih is more expensive but more accurate. The texture based shadows both work in roughly the same way, the only difference is that the shadowmap approach is slightly more accurate, but requires a more recent graphics card. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Note that because mixing many shadow techniques can cause problems, only one technique is supported at once. Also, you should call this method at the start of the scene setup. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>technique</em>&nbsp;</td><td>The shadowing technique to use for the scene. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b2a69e400687b335c414a6053de2b34"></a><!-- doxytag: member="Ogre::SceneManager::getShadowTechnique" ref="2b2a69e400687b335c414a6053de2b34" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#79dcd426d291c31072c1ad6f183715d6">ShadowTechnique</a> Ogre::SceneManager::getShadowTechnique           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current shadow technique. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02431">2431</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e2b74088a5229f3bbb09da8589968d9b"></a><!-- doxytag: member="Ogre::SceneManager::setShowDebugShadows" ref="e2b74088a5229f3bbb09da8589968d9b" args="(bool debug)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShowDebugShadows           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>debug</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables / disables the rendering of debug information for shadows. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02434">2434</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d6d310a8836f8c08b4f4f189f855d510"></a><!-- doxytag: member="Ogre::SceneManager::getShowDebugShadows" ref="d6d310a8836f8c08b4f4f189f855d510" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getShowDebugShadows           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Are debug shadows shown? 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02436">2436</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d8ab6139696f9ef50d8abea0528e85b4"></a><!-- doxytag: member="Ogre::SceneManager::setShadowColour" ref="d8ab6139696f9ef50d8abea0528e85b4" args="(const ColourValue &amp;colour)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowColour           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colour</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the colour used to modulate areas in shadow. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This is only applicable for shadow techniques which involve darkening the area in shadow, as opposed to masking out the light. This colour provided is used as a modulative value to darken the areas. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c3b3146c419a2d272b14c5dc50b024c3"></a><!-- doxytag: member="Ogre::SceneManager::getShadowColour" ref="c3b3146c419a2d272b14c5dc50b024c3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a>&amp; Ogre::SceneManager::getShadowColour           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the colour used to modulate areas in shadow. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This is only applicable for shadow techniques which involve darkening the area in shadow, as opposed to masking out the light. This colour provided is used as a modulative value to darken the areas. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9d220fa31bf0d95ad65558936c71a194"></a><!-- doxytag: member="Ogre::SceneManager::setShadowDirectionalLightExtrusionDistance" ref="9d220fa31bf0d95ad65558936c71a194" args="(Real dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowDirectionalLightExtrusionDistance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>dist</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the distance a shadow volume is extruded for a directional light. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Although directional lights are essentially infinite, there are many reasons to limit the shadow extrusion distance to a finite number, not least of which is compatibility with older cards (which do not support infinite positions), and shadow caster elimination. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The default value is 10,000 world units. This does not apply to point lights or spotlights, since they extrude up to their attenuation range. </dd></dl>

</div>
</div><p>
<a class="anchor" name="73a0ca638976062f80ebd967a638be22"></a><!-- doxytag: member="Ogre::SceneManager::getShadowDirectionalLightExtrusionDistance" ref="73a0ca638976062f80ebd967a638be22" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getShadowDirectionalLightExtrusionDistance           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the distance a shadow volume is extruded for a directional light. 
<p>

</div>
</div><p>
<a class="anchor" name="0e593d05e2f892b8fc3bfca917a75fef"></a><!-- doxytag: member="Ogre::SceneManager::setShadowFarDistance" ref="0e593d05e2f892b8fc3bfca917a75fef" args="(Real distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowFarDistance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the default maximum distance away from the camera that shadows will be visible. 
<p>
You have to call this function before you create lights or the default distance of zero will be used. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Shadow techniques can be expensive, therefore it is a good idea to limit them to being rendered close to the camera if possible, and to skip the expense of rendering shadows for distance objects. This method allows you to set the distance at which shadows will no longer be rendered. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Each shadow technique can interpret this subtely differently. For example, one technique may use this to eliminate casters, another might use it to attenuate the shadows themselves. You should tweak this value to suit your chosen shadow technique and scene setup. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f9420b7a640d29475bc09a83f4e2458"></a><!-- doxytag: member="Ogre::SceneManager::getShadowFarDistance" ref="8f9420b7a640d29475bc09a83f4e2458" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getShadowFarDistance           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the default maximum distance away from the camera that shadows will be visible. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02487">2487</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2d50ad888092c98a14139ce03a904388"></a><!-- doxytag: member="Ogre::SceneManager::getShadowFarDistanceSquared" ref="2d50ad888092c98a14139ce03a904388" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getShadowFarDistanceSquared           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02489">2489</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3364ae687de3cbf3bd5e87ffd52877e5"></a><!-- doxytag: member="Ogre::SceneManager::setShadowIndexBufferSize" ref="3364ae687de3cbf3bd5e87ffd52877e5" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowIndexBufferSize           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum size of the index buffer used to render shadow primitives. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method allows you to tweak the size of the index buffer used to render shadow primitives (including stencil shadow volumes). The default size is 51,200 entries, which is 100k of GPU memory, or enough to render approximately 17,000 triangles. You can reduce this as long as you do not have any models / world geometry chunks which could require more than the amount you set. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The maximum number of triangles required to render a single shadow volume (including light and dark caps when needed) will be 3x the number of edges on the light silhouette, plus the number of light-facing triangles. On average, half the triangles will be facing toward the light, but the number of triangles in the silhouette entirely depends on the mesh - angular meshes will have a higher silhouette tris/mesh tris ratio than a smooth mesh. You can estimate the requirements for your particular mesh by rendering it alone in a scene with shadows enabled and a single light - rotate it or the light and make a note of how high the triangle count goes (remembering to subtract the mesh triangle count) </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of indexes; divide this by 3 to determine the number of triangles. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ce6c0cf42787f6c51e4df2e13d3482a0"></a><!-- doxytag: member="Ogre::SceneManager::getShadowIndexBufferSize" ref="ce6c0cf42787f6c51e4df2e13d3482a0" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::SceneManager::getShadowIndexBufferSize           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the size of the shadow index buffer. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02519">2519</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c594a29110119bed71f1c0c61265394b"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureSize" ref="c594a29110119bed71f1c0c61265394b" args="(unsigned short size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureSize           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the size of the texture used for all texture-based shadows. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The larger the shadow texture, the better the detail on texture based shadows, but obviously this takes more memory. The default size is 512. Sizes must be a power of 2. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is the simple form, see setShadowTextureConfig for the more complex form. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3e8c1da7e6770a80383e9079484fbd94"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureConfig" ref="3e8c1da7e6770a80383e9079484fbd94" args="(size_t shadowIndex, unsigned short width, unsigned short height, PixelFormat format)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureConfig           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>shadowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&nbsp;</td>
          <td class="paramname"> <em>format</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the detailed configuration for a shadow texture. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shadowIndex</em>&nbsp;</td><td>The index of the texture to configure, must be &lt; the number of shadow textures setting </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width,height</em>&nbsp;</td><td>The dimensions of the texture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>The pixel format of the texture </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0ff40f3cef8dd775ee782bbae15d436b"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureConfig" ref="0ff40f3cef8dd775ee782bbae15d436b" args="(size_t shadowIndex, const ShadowTextureConfig &amp;config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureConfig           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>shadowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOgre_1_1ShadowTextureConfig.html">ShadowTextureConfig</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>config</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the detailed configuration for a shadow texture. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shadowIndex</em>&nbsp;</td><td>The index of the texture to configure, must be &lt; the number of shadow textures setting </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>config</em>&nbsp;</td><td>Configuration structure </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1bb99c11f9213def3e23784ccff6435f"></a><!-- doxytag: member="Ogre::SceneManager::getShadowTextureConfigIterator" ref="1bb99c11f9213def3e23784ccff6435f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstShadowTextureConfigIterator</a> Ogre::SceneManager::getShadowTextureConfigIterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the current shadow texture settings. 
<p>

</div>
</div><p>
<a class="anchor" name="87fac14153b877effba7196f116cbdc6"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTexturePixelFormat" ref="87fac14153b877effba7196f116cbdc6" args="(PixelFormat fmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTexturePixelFormat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&nbsp;</td>
          <td class="paramname"> <em>fmt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the pixel format of the textures used for texture-based shadows. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>By default, a colour texture is used (PF_X8R8G8B8) for texture shadows, but if you want to use more advanced texture shadow types you can alter this. If you do, you will have to also call setShadowTextureCasterMaterial and setShadowTextureReceiverMaterial to provide shader-based materials to use these customised shadow texture formats. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is the simple form, see setShadowTextureConfig for the more complex form. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b960b480425cecbe39573215fb5e48c"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureCount" ref="7b960b480425cecbe39573215fb5e48c" args="(size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureCount           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the number of textures allocated for texture-based shadows. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The default number of textures assigned to deal with texture based shadows is 1; however this means you can only have one light casting shadows at the same time. You can increase this number in order to make this more flexible, but be aware of the texture memory it will use. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7806a68edbfbbeac721dee76de6f869e"></a><!-- doxytag: member="Ogre::SceneManager::getShadowTextureCount" ref="7806a68edbfbbeac721dee76de6f869e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::SceneManager::getShadowTextureCount           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of the textures allocated for texture based shadows. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02571">2571</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="70f8eddf9b8617783fb7d0995b985a9a"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureCountPerLightType" ref="70f8eddf9b8617783fb7d0995b985a9a" args="(Light::LightTypes type, size_t count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::setShadowTextureCountPerLightType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Light.html#4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the number of shadow textures a light type uses. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The default for all light types is 1. This means that each light uses only 1 shadow texture. Call this if you need more than 1 shadow texture per light, E.G. PSSM. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This feature only works with the Integrated shadow technique. Also remember to increase the total number of shadow textures you request appropriately (e.g. via setShadowTextureCount)!! </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02582">2582</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="04405da47f025ac1e628ee25f1b85fc4"></a><!-- doxytag: member="Ogre::SceneManager::getShadowTextureCountPerLightType" ref="04405da47f025ac1e628ee25f1b85fc4" args="(Light::LightTypes type) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::SceneManager::getShadowTextureCountPerLightType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Light.html#4f1dea084d1497c6f49e802ade940dbc">Light::LightTypes</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of shadow textures is assigned for the given light type. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02585">2585</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="371e8c69a14e788d8983955c6f5d86f9"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureSettings" ref="371e8c69a14e788d8983955c6f5d86f9" args="(unsigned short size, unsigned short count, PixelFormat fmt=PF_X8R8G8B8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureSettings           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#7e0353e7d36d4c2e8468641b7303d39c">PixelFormat</a>&nbsp;</td>
          <td class="paramname"> <em>fmt</em> = <code>PF_X8R8G8B8</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the size and count of textures used in texture-based shadows. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#c594a29110119bed71f1c0c61265394b" title="Set the size of the texture used for all texture-based shadows.">setShadowTextureSize</a> and <a class="el" href="classOgre_1_1SceneManager.html#7b960b480425cecbe39573215fb5e48c" title="Set the number of textures allocated for texture-based shadows.">setShadowTextureCount</a> for details, this method just allows you to change both at once, which can save on reallocation if the textures have already been created. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is the simple form, see setShadowTextureConfig for the more complex form. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf504cf97c1723f6fab069335ecee9a0"></a><!-- doxytag: member="Ogre::SceneManager::getShadowTexture" ref="bf504cf97c1723f6fab069335ecee9a0" args="(size_t shadowIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1TexturePtr.html">TexturePtr</a>&amp; Ogre::SceneManager::getShadowTexture           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>shadowIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a reference to the shadow texture currently in use at the given index. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you change shadow settings, this reference may no longer be correct, so be sure not to hold the returned reference over texture shadow configuration changes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="893663f55c2b4a29467cff25b9b1b3f4"></a><!-- doxytag: member="Ogre::SceneManager::setShadowDirLightTextureOffset" ref="893663f55c2b4a29467cff25b9b1b3f4" args="(Real offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowDirLightTextureOffset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>When generating a shadow texture from a directional light, an approximation is used since it is not possible to render the entire scene to one texture. The texture is projected onto an area centred on the camera, and is the shadow far distance * 2 in length (it is square). This wastes a lot of texture space outside the frustum though, so this offset allows you to move the texture in front of the camera more. However, be aware that this can cause a little shadow 'jittering' during rotation, and that if you move it too far then you'll start to get artefacts close to the camera. The value is represented as a proportion of the shadow far distance, and the default is 0.6. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02621">2621</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="74ce4995eac32da6d1c2d2cef58c7019"></a><!-- doxytag: member="Ogre::SceneManager::getShadowDirLightTextureOffset" ref="74ce4995eac32da6d1c2d2cef58c7019" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::SceneManager::getShadowDirLightTextureOffset           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02625">2625</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="72fa019aa4efbc6943842efcf5f38078"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureFadeStart" ref="72fa019aa4efbc6943842efcf5f38078" args="(Real fadeStart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureFadeStart           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>fadeStart</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the proportional distance at which texture shadows begin to fade out. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>To hide the edges where texture shadows end (in directional lights) <a class="el" href="namespaceOgre.html">Ogre</a> will fade out the shadow in the distance. This value is a proportional distance of the entire shadow visibility distance at which the shadow begins to fade out. The default is 0.7 </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02633">2633</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="237a09e65919b808473c543fb886723f"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureFadeEnd" ref="237a09e65919b808473c543fb886723f" args="(Real fadeEnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureFadeEnd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>fadeEnd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the proportional distance at which texture shadows finish to fading out. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>To hide the edges where texture shadows end (in directional lights) <a class="el" href="namespaceOgre.html">Ogre</a> will fade out the shadow in the distance. This value is a proportional distance of the entire shadow visibility distance at which the shadow is completely invisible. The default is 0.9. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02642">2642</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8de7e38165fe9b0aa4baddf95ef006e7"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureSelfShadow" ref="8de7e38165fe9b0aa4baddf95ef006e7" args="(bool selfShadow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureSelfShadow           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>selfShadow</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not texture shadows should attempt to self-shadow. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The default implementation of texture shadows uses a fixed-function colour texture projection approach for maximum compatibility, and as such cannot support self-shadowing. However, if you decide to implement a more complex shadowing technique using the setShadowTextureCasterMaterial and setShadowTextureReceiverMaterial there is a possibility you may be able to support self-shadowing (e.g by implementing a shader-based shadow map). In this case you might want to enable this option. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selfShadow</em>&nbsp;</td><td>Whether to attempt self-shadowing with texture shadows </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a5062fe502bf8cd49b974a5ca8052468"></a><!-- doxytag: member="Ogre::SceneManager::getShadowTextureSelfShadow" ref="a5062fe502bf8cd49b974a5ca8052468" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getShadowTextureSelfShadow           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether or not texture shadows attempt to self-shadow. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02660">2660</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9f0cde141313583e65561abdfae6a0ec"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureCasterMaterial" ref="9f0cde141313583e65561abdfae6a0ec" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureCasterMaterial           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the default material to use for rendering shadow casters. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>By default shadow casters are rendered into the shadow texture using an automatically generated fixed-function pass. This allows basic projective texture shadows, but it's possible to use more advanced shadow techniques by overriding the caster and receiver materials, for example providing vertex and fragment programs to implement shadow maps. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>You can rely on the ambient light in the scene being set to the requested texture shadow colour, if that's useful. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Individual objects may also override the vertex program in your default material if their materials include shadow_caster_vertex_program_ref, shadow_receiver_vertex_program_ref shadow_caster_material entries, so if you use both make sure they are compatible. <p>
Only a single pass is allowed in your material, although multiple techniques may be used for hardware fallback. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e0d524bf189e08fdab005ca2b5560190"></a><!-- doxytag: member="Ogre::SceneManager::setShadowTextureReceiverMaterial" ref="e0d524bf189e08fdab005ca2b5560190" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowTextureReceiverMaterial           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the default material to use for rendering shadow receivers. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>By default shadow receivers are rendered as a post-pass using basic modulation. This allows basic projective texture shadows, but it's possible to use more advanced shadow techniques by overriding the caster and receiver materials, for example providing vertex and fragment programs to implement shadow maps. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>You can rely on texture unit 0 containing the shadow texture, and for the unit to be set to use projective texturing from the light (only useful if you're using fixed-function, which is unlikely; otherwise you should rely on the texture_viewproj_matrix auto binding) </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Individual objects may also override the vertex program in your default material if their materials include shadow_caster_vertex_program_ref shadow_receiver_vertex_program_ref shadow_receiver_material entries, so if you use both make sure they are compatible. <p>
Only a single pass is allowed in your material, although multiple techniques may be used for hardware fallback. </dd></dl>

</div>
</div><p>
<a class="anchor" name="af865048d62de79942fea2758c33ee3e"></a><!-- doxytag: member="Ogre::SceneManager::setShadowCasterRenderBackFaces" ref="af865048d62de79942fea2758c33ee3e" args="(bool bf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowCasterRenderBackFaces           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bf</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Rendering back faces rather than front faces into a shadow texture can help minimise depth comparison issues, if you're using depth shadowmapping. You will probably still need some biasing but you won't need as much. For solid objects the result is the same anyway, if you have objects with holes you may want to turn this option off. The default is to enable this option. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02716">2716</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="99b0932e1331a4e07e0db0301172da20"></a><!-- doxytag: member="Ogre::SceneManager::getShadowCasterRenderBackFaces" ref="99b0932e1331a4e07e0db0301172da20" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getShadowCasterRenderBackFaces           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02721">2721</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="dbe1da236689cdd20690d5da950dce33"></a><!-- doxytag: member="Ogre::SceneManager::setShadowCameraSetup" ref="dbe1da236689cdd20690d5da950dce33" args="(const ShadowCameraSetupPtr &amp;shadowSetup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowCameraSetup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1SharedPtr.html">ShadowCameraSetupPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shadowSetup</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the shadow camera setup to use for all lights which don't have their own shadow camera setup. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1ShadowCameraSetup.html" title="This class allows you to plug in new ways to define the camera setup when rendering...">ShadowCameraSetup</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae7259371b79bafd3f164daaf34a919c"></a><!-- doxytag: member="Ogre::SceneManager::getShadowCameraSetup" ref="ae7259371b79bafd3f164daaf34a919c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1SharedPtr.html">ShadowCameraSetupPtr</a>&amp; Ogre::SceneManager::getShadowCameraSetup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the shadow camera setup in use for all lights which don't have their own shadow camera setup. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1ShadowCameraSetup.html" title="This class allows you to plug in new ways to define the camera setup when rendering...">ShadowCameraSetup</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a40a406b22c8d5dd282523f8dcd09e34"></a><!-- doxytag: member="Ogre::SceneManager::setShadowUseInfiniteFarPlane" ref="a40a406b22c8d5dd282523f8dcd09e34" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowUseInfiniteFarPlane           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether we should use an inifinite camera far plane when rendering stencil shadows. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Stencil shadow coherency is very reliant on the shadow volume not being clipped by the far plane. If this clipping happens, you get a kind of 'negative' shadow effect. The best way to achieve coherency is to move the far plane of the camera out to infinity, thus preventing the far plane from clipping the shadow volumes. When combined with vertex program extrusion of the volume to infinity, which <a class="el" href="namespaceOgre.html">Ogre</a> does when available, this results in very robust shadow volumes. For this reason, when you enable stencil shadows, <a class="el" href="namespaceOgre.html">Ogre</a> automatically changes your camera settings to project to infinity if the card supports it. You can disable this behaviour if you like by calling this method; although you can never enable infinite projection if the card does not support it. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>If you disable infinite projection, or it is not available, you need to be far more careful with your light attenuation / directional light extrusion distances to avoid clipping artefacts at the far plane. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Recent cards will generally support infinite far plane projection. However, we have found some cases where they do not, especially on Direct3D. There is no standard capability we can check to validate this, so we use some heuristics based on experience: <ul>
<li>
OpenGL always seems to support it no matter what the card </li>
<li>
Direct3D on non-vertex program capable systems (including vertex program capable cards on Direct3D7) does not support it </li>
<li>
Direct3D on GeForce3 and GeForce4 Ti does not seem to support infinite projection</li>
<li>
</li>
</ul>
Therefore in the <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> implementation, we may veto the use of an infinite far plane based on these heuristics. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02771">2771</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="bcd82e9adadad77f0935b5cdb7182ec6"></a><!-- doxytag: member="Ogre::SceneManager::isShadowTechniqueStencilBased" ref="bcd82e9adadad77f0935b5cdb7182ec6" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isShadowTechniqueStencilBased           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is there a stencil shadow based shadowing technique in use? 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02775">2775</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

<p>References <a class="el" href="OgreCommon_8h-source.html#l00193">Ogre::SHADOWDETAILTYPE_STENCIL</a>.</p>

</div>
</div><p>
<a class="anchor" name="194ea7ba828e1f713226f16eec8cd8b5"></a><!-- doxytag: member="Ogre::SceneManager::isShadowTechniqueTextureBased" ref="194ea7ba828e1f713226f16eec8cd8b5" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isShadowTechniqueTextureBased           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is there a texture shadow based shadowing technique in use? 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02778">2778</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

<p>References <a class="el" href="OgreCommon_8h-source.html#l00196">Ogre::SHADOWDETAILTYPE_TEXTURE</a>.</p>

</div>
</div><p>
<a class="anchor" name="0d931a137e72d11bdaeb200fa0a8ffb8"></a><!-- doxytag: member="Ogre::SceneManager::isShadowTechniqueModulative" ref="0d931a137e72d11bdaeb200fa0a8ffb8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isShadowTechniqueModulative           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is there a modulative shadowing technique in use? 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02781">2781</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

<p>References <a class="el" href="OgreCommon_8h-source.html#l00187">Ogre::SHADOWDETAILTYPE_MODULATIVE</a>.</p>

</div>
</div><p>
<a class="anchor" name="6c46ea94370e147deb8c49823db0ed7d"></a><!-- doxytag: member="Ogre::SceneManager::isShadowTechniqueAdditive" ref="6c46ea94370e147deb8c49823db0ed7d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isShadowTechniqueAdditive           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is there an additive shadowing technique in use? 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02784">2784</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

<p>References <a class="el" href="OgreCommon_8h-source.html#l00184">Ogre::SHADOWDETAILTYPE_ADDITIVE</a>.</p>

</div>
</div><p>
<a class="anchor" name="7145a399f90a25b120bd9802d24448a7"></a><!-- doxytag: member="Ogre::SceneManager::isShadowTechniqueIntegrated" ref="7145a399f90a25b120bd9802d24448a7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isShadowTechniqueIntegrated           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is the shadow technique integrated into primary materials? 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02787">2787</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

<p>References <a class="el" href="OgreCommon_8h-source.html#l00190">Ogre::SHADOWDETAILTYPE_INTEGRATED</a>.</p>

</div>
</div><p>
<a class="anchor" name="6dfdf56d941a145875d81c4c763f9391"></a><!-- doxytag: member="Ogre::SceneManager::isShadowTechniqueInUse" ref="6dfdf56d941a145875d81c4c763f9391" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::isShadowTechniqueInUse           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is there any shadowing technique in use? 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02790">2790</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

<p>References <a class="el" href="OgreCommon_8h-source.html#l00181">Ogre::SHADOWTYPE_NONE</a>.</p>

</div>
</div><p>
<a class="anchor" name="83a8347369ffc819ea8c85e4d416fb9c"></a><!-- doxytag: member="Ogre::SceneManager::setShadowUseLightClipPlanes" ref="83a8347369ffc819ea8c85e4d416fb9c" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setShadowUseLightClipPlanes           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02795">2795</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="50faf3e81e28c16fefea6937d4b6a611"></a><!-- doxytag: member="Ogre::SceneManager::getShadowUseLightClipPlanes" ref="50faf3e81e28c16fefea6937d4b6a611" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getShadowUseLightClipPlanes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02799">2799</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6b54e34b6a8e72d4c1456bda016731ad"></a><!-- doxytag: member="Ogre::SceneManager::addListener" ref="6b54e34b6a8e72d4c1456bda016731ad" args="(Listener *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::addListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneManager_1_1Listener.html">Listener</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a listener which will get called back on scene manager events. 
<p>

</div>
</div><p>
<a class="anchor" name="4437b11b78eae8f5db205aa89c0235ee"></a><!-- doxytag: member="Ogre::SceneManager::removeListener" ref="4437b11b78eae8f5db205aa89c0235ee" args="(Listener *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::removeListener           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneManager_1_1Listener.html">Listener</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a listener. 
<p>

</div>
</div><p>
<a class="anchor" name="552d1695774ca8f8da355ef0f11be86c"></a><!-- doxytag: member="Ogre::SceneManager::createStaticGeometry" ref="552d1695774ca8f8da355ef0f11be86c" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1StaticGeometry.html">StaticGeometry</a>* Ogre::SceneManager::createStaticGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instance suitable for use with this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> is a way of batching up geometry into a more efficient form at the expense of being able to move it. Please read the <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> class documentation for full information. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to give the new object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instance </dd></dl>

</div>
</div><p>
<a class="anchor" name="3193bc1a8bc05df184234b59a7701a2f"></a><!-- doxytag: member="Ogre::SceneManager::getStaticGeometry" ref="3193bc1a8bc05df184234b59a7701a2f" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1StaticGeometry.html">StaticGeometry</a>* Ogre::SceneManager::getStaticGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve a previously created <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instance. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="cbaddd36a321a7c00085f654df71991d"></a><!-- doxytag: member="Ogre::SceneManager::hasStaticGeometry" ref="cbaddd36a321a7c00085f654df71991d" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasStaticGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a static geometry instance with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="54d553be3f6098ce229e6db53ec15227"></a><!-- doxytag: member="Ogre::SceneManager::destroyStaticGeometry" ref="54d553be3f6098ce229e6db53ec15227" args="(StaticGeometry *geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyStaticGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1StaticGeometry.html">StaticGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove &amp; destroy a <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instance. 
<p>

</div>
</div><p>
<a class="anchor" name="e4f180b40f4bf55669f9842fe922a003"></a><!-- doxytag: member="Ogre::SceneManager::destroyStaticGeometry" ref="e4f180b40f4bf55669f9842fe922a003" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyStaticGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove &amp; destroy a <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instance. 
<p>

</div>
</div><p>
<a class="anchor" name="64f54ea048af80532212c8f60bea95d6"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllStaticGeometry" ref="64f54ea048af80532212c8f60bea95d6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllStaticGeometry           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove &amp; destroy all <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a> instances. 
<p>

</div>
</div><p>
<a class="anchor" name="af98f349389bbdd1c3fb25c418e56887"></a><!-- doxytag: member="Ogre::SceneManager::createInstancedGeometry" ref="af98f349389bbdd1c3fb25c418e56887" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1InstancedGeometry.html">InstancedGeometry</a>* Ogre::SceneManager::createInstancedGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instance suitable for use with this <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> is a way of batching up geometry into a more efficient form, and still be able to move it. Please read the <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> class documentation for full information. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to give the new object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instance </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b2a069b6fd8b7e49f70d7384f96a7f4"></a><!-- doxytag: member="Ogre::SceneManager::getInstancedGeometry" ref="2b2a069b6fd8b7e49f70d7384f96a7f4" args="(const String &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1InstancedGeometry.html">InstancedGeometry</a>* Ogre::SceneManager::getInstancedGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve a previously created <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instance. 
<p>

</div>
</div><p>
<a class="anchor" name="18bca397484fe3ba8ae396a959043e00"></a><!-- doxytag: member="Ogre::SceneManager::destroyInstancedGeometry" ref="18bca397484fe3ba8ae396a959043e00" args="(InstancedGeometry *geom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyInstancedGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1InstancedGeometry.html">InstancedGeometry</a> *&nbsp;</td>
          <td class="paramname"> <em>geom</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove &amp; destroy a <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instance. 
<p>

</div>
</div><p>
<a class="anchor" name="54a8d0104ab73e3421e16dc316ea15fc"></a><!-- doxytag: member="Ogre::SceneManager::destroyInstancedGeometry" ref="54a8d0104ab73e3421e16dc316ea15fc" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyInstancedGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove &amp; destroy a <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instance. 
<p>

</div>
</div><p>
<a class="anchor" name="be13b71355bfe6d93303bdb73b458007"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllInstancedGeometry" ref="be13b71355bfe6d93303bdb73b458007" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllInstancedGeometry           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove &amp; destroy all <a class="el" href="classOgre_1_1InstancedGeometry.html" title="Pre-transforms and batches up meshes for efficient use as instanced geometry in a...">InstancedGeometry</a> instances. 
<p>

</div>
</div><p>
<a class="anchor" name="edbccf093ce9ee7c4db9d59d9344bc94"></a><!-- doxytag: member="Ogre::SceneManager::createMovableObject" ref="edbccf093ce9ee7c4db9d59d9344bc94" args="(const String &amp;name, const String &amp;typeName, const NameValuePairList *params=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>* Ogre::SceneManager::createMovableObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#0537f38d7a77fcbe9f600f6ed8a926d6">NameValuePairList</a> *&nbsp;</td>
          <td class="paramname"> <em>params</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a movable object of the type specified. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This is the generalised form of <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> creation where you can create a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> of any specialised type generically, including any new types registered using plugins. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name to give the object. Must be unique within type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>typeName</em>&nbsp;</td><td>The type of object to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>Optional name/value pair list to give extra parameters to the created object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cac42f73eb41692a098bf31f1401d7e7"></a><!-- doxytag: member="Ogre::SceneManager::destroyMovableObject" ref="cac42f73eb41692a098bf31f1401d7e7" args="(const String &amp;name, const String &amp;typeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyMovableObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> with the name specified, of the type specified. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> will automatically detach itself from any nodes on destruction. </dd></dl>

</div>
</div><p>
<a class="anchor" name="32a135e382bac33ecd42f946713e2f38"></a><!-- doxytag: member="Ogre::SceneManager::destroyMovableObject" ref="32a135e382bac33ecd42f946713e2f38" args="(MovableObject *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyMovableObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> will automatically detach itself from any nodes on destruction. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8aca5477f30dd55321a101f25c6a5ee2"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllMovableObjectsByType" ref="8aca5477f30dd55321a101f25c6a5ee2" args="(const String &amp;typeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllMovableObjectsByType           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy all MovableObjects of a given type. 
<p>

</div>
</div><p>
<a class="anchor" name="f985062a80dbc20d8fe523be166ecca6"></a><!-- doxytag: member="Ogre::SceneManager::destroyAllMovableObjects" ref="f985062a80dbc20d8fe523be166ecca6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::destroyAllMovableObjects           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy all MovableObjects. 
<p>

</div>
</div><p>
<a class="anchor" name="f30f35e9d9630ae360fbf5a9de136452"></a><!-- doxytag: member="Ogre::SceneManager::getMovableObject" ref="f30f35e9d9630ae360fbf5a9de136452" args="(const String &amp;name, const String &amp;typeName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>* Ogre::SceneManager::getMovableObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a reference to a previously created <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Throws an exception if the named instance does not exist </dd></dl>

</div>
</div><p>
<a class="anchor" name="af8016cc1956244c4dd6844b030e06b9"></a><!-- doxytag: member="Ogre::SceneManager::hasMovableObject" ref="af8016cc1956244c4dd6844b030e06b9" args="(const String &amp;name, const String &amp;typeName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::hasMovableObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether a movable object instance with the given name exists. 
<p>

</div>
</div><p>
<a class="anchor" name="f19c32fbc0adc0fa28d8e6c26d9800cb"></a><!-- doxytag: member="Ogre::SceneManager::getMovableObjectIterator" ref="f19c32fbc0adc0fa28d8e6c26d9800cb" args="(const String &amp;typeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOgre_1_1MapIterator.html">MovableObjectIterator</a> Ogre::SceneManager::getMovableObjectIterator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over all MovableObect instances of a given type. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The iterator returned from this method is not thread safe, do not use this if you are creating or deleting objects of this type in another thread. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f13eb691a7bdd67e17a402dee98c4b5f"></a><!-- doxytag: member="Ogre::SceneManager::injectMovableObject" ref="f13eb691a7bdd67e17a402dee98c4b5f" args="(MovableObject *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::injectMovableObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inject a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> instance created externally. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method 'injects' a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> instance created externally into the <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> instance registry held in the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a>. You might want to use this if you have a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> which you don't want to register a factory for; for example a <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> which cannot be generally constructed by clients. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is important that the <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> has a unique name for the type, and that its getMovableType() method returns a proper type name. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d14c16852b08107db556a180e61d7a1"></a><!-- doxytag: member="Ogre::SceneManager::extractMovableObject" ref="6d14c16852b08107db556a180e61d7a1" args="(const String &amp;name, const String &amp;typeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::extractMovableObject           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a previously injected <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Essentially this does the same as destroyMovableObject, but only removes the instance from the internal lists, it does not attempt to destroy it. </dd></dl>

</div>
</div><p>
<a class="anchor" name="874431ce04c34fa6dcbdb2ed1420b168"></a><!-- doxytag: member="Ogre::SceneManager::extractMovableObject" ref="874431ce04c34fa6dcbdb2ed1420b168" args="(MovableObject *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::extractMovableObject           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract a previously injected <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Essentially this does the same as destroyMovableObject, but only removes the instance from the internal lists, it does not attempt to destroy it. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1c55f5e97c66261de71c979db64f6355"></a><!-- doxytag: member="Ogre::SceneManager::extractAllMovableObjectsByType" ref="1c55f5e97c66261de71c979db64f6355" args="(const String &amp;typeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::extractAllMovableObjectsByType           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract all injected MovableObjects of a given type. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Essentially this does the same as destroyAllMovableObjectsByType, but only removes the instances from the internal lists, it does not attempt to destroy them. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ef478368ad95d09c9df5ed114ba47c36"></a><!-- doxytag: member="Ogre::SceneManager::setVisibilityMask" ref="ef478368ad95d09c9df5ed114ba47c36" args="(uint32 vmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setVisibilityMask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a>&nbsp;</td>
          <td class="paramname"> <em>vmask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Note that this is combined with any per-viewport visibility mask through an 'and' operation. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Viewport.html#d5a4fe00ee05861c157bf63e78e1c2b0" title="Sets a per-viewport visibility mask.">Viewport::setVisibilityMask</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02932">2932</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="bd074aaefc7c579a0c6d09593bb7d3e6"></a><!-- doxytag: member="Ogre::SceneManager::getVisibilityMask" ref="bd074aaefc7c579a0c6d09593bb7d3e6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::SceneManager::getVisibilityMask           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02937">2937</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4ac70da4acb59963d90d58b0b76814e1"></a><!-- doxytag: member="Ogre::SceneManager::_getCombinedVisibilityMask" ref="4ac70da4acb59963d90d58b0b76814e1" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::SceneManager::_getCombinedVisibilityMask           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for getting the combination between the global visibility mask and the per-viewport visibility mask. 
<p>

</div>
</div><p>
<a class="anchor" name="04c8414da02aec3e3f98acd013917ed2"></a><!-- doxytag: member="Ogre::SceneManager::setFindVisibleObjects" ref="04c8414da02aec3e3f98acd013917ed2" args="(bool find)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setFindVisibleObjects           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>find</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> should search for visible objects, or whether they are being manually handled. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This is an advanced function, you should not use this unless you know what you are doing. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02950">2950</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3d7d7f344e528eea2e99481247de72c7"></a><!-- doxytag: member="Ogre::SceneManager::getFindVisibleObjects" ref="3d7d7f344e528eea2e99481247de72c7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getFindVisibleObjects           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets whether the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> should search for visible objects, or whether they are being manually handled. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02955">2955</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4fa4a94b8687098a6751be1ed36e20f7"></a><!-- doxytag: member="Ogre::SceneManager::setNormaliseNormalsOnScale" ref="4fa4a94b8687098a6751be1ed36e20f7" args="(bool n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setNormaliseNormalsOnScale           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to automatically normalise normals on objects whenever they are scaled. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Scaling can distort normals so the default behaviour is to compensate for this, but it has a cost. If you would prefer to manually manage this, set this option to 'false' and use <a class="el" href="classOgre_1_1Pass.html#d00b9d37cf0d5d7af26d23a2a48f5541" title="If set to true, this forces normals to be normalised dynamically by the hardware...">Pass::setNormaliseNormals</a> only when needed. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02965">2965</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0fdae2f94c44e3f1be79c8c27f965ec2"></a><!-- doxytag: member="Ogre::SceneManager::getNormaliseNormalsOnScale" ref="0fdae2f94c44e3f1be79c8c27f965ec2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getNormaliseNormalsOnScale           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get whether to automatically normalise normals on objects whenever they are scaled. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02970">2970</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2a4d997503b651187f2e129cd5eeb7ad"></a><!-- doxytag: member="Ogre::SceneManager::setFlipCullingOnNegativeScale" ref="2a4d997503b651187f2e129cd5eeb7ad" args="(bool n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setFlipCullingOnNegativeScale           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to automatically flip the culling mode on objects whenever they are negatively scaled. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Negativelyl scaling an object has the effect of flipping the triangles, so the culling mode should probably be inverted to deal with this. If you would prefer to manually manage this, set this option to 'false' and use different materials with <a class="el" href="classOgre_1_1Pass.html#8942abf3ede0f3cb43584c85c4071734" title="Sets the culling mode for this pass based on the &#39;vertex winding&#39;.">Pass::setCullingMode</a> set manually as needed. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02980">2980</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="bf5b90fccee3356293e5335265a2ea29"></a><!-- doxytag: member="Ogre::SceneManager::getFlipCullingOnNegativeScale" ref="bf5b90fccee3356293e5335265a2ea29" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getFlipCullingOnNegativeScale           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get whether to automatically flip the culling mode on objects whenever they are negatively scaled. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l02985">2985</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3ef597efaec718cbe41c1244df9a0adf"></a><!-- doxytag: member="Ogre::SceneManager::_injectRenderWithPass" ref="3ef597efaec718cbe41c1244df9a0adf" args="(Pass *pass, Renderable *rend, bool shadowDerivation=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_injectRenderWithPass           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td>
          <td class="paramname"> <em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Renderable.html">Renderable</a> *&nbsp;</td>
          <td class="paramname"> <em>rend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>shadowDerivation</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render something as if it came from the current queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pass</em>&nbsp;</td><td><a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> pass to use for setting up this quad. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rend</em>&nbsp;</td><td><a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> to render </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shadowDerivation</em>&nbsp;</td><td>Whether passes should be replaced with shadow caster / receiver passes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6753ea2b52715774b7fdd59da232917a"></a><!-- doxytag: member="Ogre::SceneManager::_suppressRenderStateChanges" ref="6753ea2b52715774b7fdd59da232917a" args="(bool suppress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_suppressRenderStateChanges           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>suppress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates to the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> whether it should suppress changing the <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> states when rendering objects. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This method allows you to tell the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> not to change any <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> state until you tell it to. This method is only intended for advanced use, don't use it if you're unsure of the effect. The only RenderSystems calls made are to set the world matrix for each object (note - view an projection matrices are NOT SET - they are under your control) and to render the object; it is up to the caller to do everything else, including enabling any vertex / fragment programs and updating their parameter state, and binding parameters to the <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a>. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Calling this implicitly disables shadow processing since no shadows can be rendered without changing state. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>suppress</em>&nbsp;</td><td>If true, no <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> state changes will be issued until this method is called again with a parameter of false. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f94f21965555436d24e715d2408fbb06"></a><!-- doxytag: member="Ogre::SceneManager::_areRenderStateChangesSuppressed" ref="f94f21965555436d24e715d2408fbb06" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::_areRenderStateChangesSuppressed           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Are render state changes suppressed? 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#6753ea2b52715774b7fdd59da232917a" title="Indicates to the SceneManager whether it should suppress changing the RenderSystem...">_suppressRenderStateChanges</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l03017">3017</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="90c2bebde23c88f9946e80627724ca44"></a><!-- doxytag: member="Ogre::SceneManager::_setPass" ref="90c2bebde23c88f9946e80627724ca44" args="(const Pass *pass, bool evenIfSuppressed=false, bool shadowDerivation=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOgre_1_1Pass.html">Pass</a>* Ogre::SceneManager::_setPass           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td>
          <td class="paramname"> <em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>evenIfSuppressed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>shadowDerivation</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for setting up the renderstate for a rendering pass. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pass</em>&nbsp;</td><td>The <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> details to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evenIfSuppressed</em>&nbsp;</td><td>Sets the pass details even if render state changes are suppressed; if you are using this to manually set state when render state changes are suppressed, you should set this to true. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shadowDerivation</em>&nbsp;</td><td>If false, disables the derivation of shadow passes from original passes </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> object that was used instead of the one passed in, can happen when rendering shadow passes </dd></dl>

</div>
</div><p>
<a class="anchor" name="63644515ee55a20f31979e94eb227a1c"></a><!-- doxytag: member="Ogre::SceneManager::_suppressShadows" ref="63644515ee55a20f31979e94eb227a1c" args="(bool suppress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_suppressShadows           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>suppress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates to the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> whether it should suppress the active shadow rendering technique until told otherwise. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This is a temporary alternative to setShadowTechnique to suppress the rendering of shadows and forcing all processing down the standard rendering path. This is intended for internal use only. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>suppress</em>&nbsp;</td><td>If true, no shadow rendering will occur until this method is called again with a parameter of false. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="832e91f368f91e727dd2386cc00e7485"></a><!-- doxytag: member="Ogre::SceneManager::_areShadowsSuppressed" ref="832e91f368f91e727dd2386cc00e7485" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::_areShadowsSuppressed           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Are shadows suppressed? 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneManager.html#63644515ee55a20f31979e94eb227a1c" title="Indicates to the SceneManager whether it should suppress the active shadow rendering...">_suppressShadows</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l03050">3050</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e738d9a6259878ba16d0153539d3f7f8"></a><!-- doxytag: member="Ogre::SceneManager::_renderQueueGroupObjects" ref="e738d9a6259878ba16d0153539d3f7f8" args="(RenderQueueGroup *group, QueuedRenderableCollection::OrganisationMode om)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::_renderQueueGroupObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1RenderQueueGroup.html">RenderQueueGroup</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html#b44ba16fe8e8c0247234d4e6edfae844">QueuedRenderableCollection::OrganisationMode</a>&nbsp;</td>
          <td class="paramname"> <em>om</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Render the objects in a given queue group. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You should only call this from a <a class="el" href="classOgre_1_1RenderQueueInvocation.html" title="Class representing the invocation of queue groups in a RenderQueue.">RenderQueueInvocation</a> implementation </dd></dl>

</div>
</div><p>
<a class="anchor" name="f55b7d8cf3daf68db0266139faf73492"></a><!-- doxytag: member="Ogre::SceneManager::setQueuedRenderableVisitor" ref="f55b7d8cf3daf68db0266139faf73492" args="(SceneMgrQueuedRenderableVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::SceneManager::setQueuedRenderableVisitor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a> *&nbsp;</td>
          <td class="paramname"> <em>visitor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advanced method for supplying an alternative visitor, used for parsing the render queues and sending the results to the renderer. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You can use this method to insert your own implementation of the <a class="el" href="classOgre_1_1QueuedRenderableVisitor.html" title="Visitor interface for items in a QueuedRenderableCollection.">QueuedRenderableVisitor</a> interface, which receives calls as the queued renderables are parsed in a given order (determined by <a class="el" href="classOgre_1_1RenderQueueInvocationSequence.html" title="Class to hold a linear sequence of RenderQueueInvocation objects.">RenderQueueInvocationSequence</a>) and are sent to the renderer. If you provide your own implementation of this visitor, you are responsible for either calling the rendersystem, or passing the calls on to the base class implementation. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Ownership is not taken of this pointer, you are still required to delete it yourself once you're finished. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>visitor</em>&nbsp;</td><td>Your implementation of <a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html" title="Inner helper class to implement the visitor pattern for rendering objects in a queue...">SceneMgrQueuedRenderableVisitor</a>. If you pass 0, the default implementation will be used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fe6dac1f080afffd346271af26c464d7"></a><!-- doxytag: member="Ogre::SceneManager::getQueuedRenderableVisitor" ref="fe6dac1f080afffd346271af26c464d7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a>* Ogre::SceneManager::getQueuedRenderableVisitor           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current visitor object which processes queued renderables. 
<p>

</div>
</div><p>
<a class="anchor" name="a5ed3c081ae69e90569fd0c2727a34df"></a><!-- doxytag: member="Ogre::SceneManager::getDestinationRenderSystem" ref="a5ed3c081ae69e90569fd0c2727a34df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderSystem.html">RenderSystem</a>* Ogre::SceneManager::getDestinationRenderSystem           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the rendersystem subclass to which the output of this Scene Manager gets sent. 
<p>

</div>
</div><p>
<a class="anchor" name="6e2c9ea54992be4b4729ab6243ed3e3a"></a><!-- doxytag: member="Ogre::SceneManager::getCurrentViewport" ref="6e2c9ea54992be4b4729ab6243ed3e3a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a>* Ogre::SceneManager::getCurrentViewport           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the current viewport being rendered (advanced use only, only valid during viewport update. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l03087">3087</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a724f4e6c46ceaa95a13d60a7d504db0"></a><!-- doxytag: member="Ogre::SceneManager::getVisibleObjectsBoundsInfo" ref="a724f4e6c46ceaa95a13d60a7d504db0" args="(const Camera *cam) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a>&amp; Ogre::SceneManager::getVisibleObjectsBoundsInfo           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Camera.html">Camera</a> *&nbsp;</td>
          <td class="paramname"> <em>cam</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a visibility boundary box for a specific camera. 
<p>

</div>
</div><p>
<a class="anchor" name="63b60c5540665c878d5f15138c4cfa21"></a><!-- doxytag: member="Ogre::SceneManager::getShadowCasterBoundsInfo" ref="63b60c5540665c878d5f15138c4cfa21" args="(const Light *light, size_t iteration=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">VisibleObjectsBoundsInfo</a>&amp; Ogre::SceneManager::getShadowCasterBoundsInfo           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Light.html">Light</a> *&nbsp;</td>
          <td class="paramname"> <em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>iteration</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the shadow caster AAB for a specific light-camera combination. 
<p>

</div>
</div><p>
<a class="anchor" name="52de83e40cb386682bf3d148affd192b"></a><!-- doxytag: member="Ogre::SceneManager::setCameraRelativeRendering" ref="52de83e40cb386682bf3d148affd192b" args="(bool rel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::SceneManager::setCameraRelativeRendering           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>rel</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This is a technique to alleviate some of the precision issues associated with rendering far from the origin, where single-precision floats as used in most GPUs begin to lose their precision. Instead of including the camera translation in the view matrix, it only includes the rotation, and the world matrices of objects must be expressed relative to this. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If you need this option, you will probably also need to enable double-precision mode in <a class="el" href="namespaceOgre.html">Ogre</a> (OGRE_DOUBLE_PRECISION), since even though this will alleviate the rendering precision, the source camera and object positions will still suffer from precision issues leading to jerky movement. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l03109">3109</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8aaf50983e9000284a8eed93a51353bc"></a><!-- doxytag: member="Ogre::SceneManager::getCameraRelativeRendering" ref="8aaf50983e9000284a8eed93a51353bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::SceneManager::getCameraRelativeRendering           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l03114">3114</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="421b197ca3a38da17e2eb1531a645fa2"></a><!-- doxytag: member="Ogre::SceneManager::operator new" ref="421b197ca3a38da17e2eb1531a645fa2" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
operator new, with debug line info 
<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00062">62</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4bdf968b7b9af8a5239a27da73d5711"></a><!-- doxytag: member="Ogre::SceneManager::operator new" ref="c4bdf968b7b9af8a5239a27da73d5711" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00067">67</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b78a921e54419be677839cdf15d1f0b8"></a><!-- doxytag: member="Ogre::SceneManager::operator new" ref="b78a921e54419be677839cdf15d1f0b8" args="(size_t sz, void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
placement operator new 
<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00073">73</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4be37baef81876985aa1071ad5acc6dd"></a><!-- doxytag: member="Ogre::SceneManager::operator new[]" ref="4be37baef81876985aa1071ad5acc6dd" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
array operator new, with debug line info 
<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00079">79</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="fa2943846ba6a2b5824a12857139cf5e"></a><!-- doxytag: member="Ogre::SceneManager::operator new[]" ref="fa2943846ba6a2b5824a12857139cf5e" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00084">84</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8357fe4fb4849772b94baa4bf47c7ded"></a><!-- doxytag: member="Ogre::SceneManager::operator delete" ref="8357fe4fb4849772b94baa4bf47c7ded" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00089">89</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c727e879a260c37b00ce5505fe8e144"></a><!-- doxytag: member="Ogre::SceneManager::operator delete" ref="1c727e879a260c37b00ce5505fe8e144" args="(void *ptr, void *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00095">95</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cb46d4b0a597156d9ba5abc39d127792"></a><!-- doxytag: member="Ogre::SceneManager::operator delete" ref="cb46d4b0a597156d9ba5abc39d127792" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00101">101</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="93e6a86dde5483c053ca0f2a85bbfd6c"></a><!-- doxytag: member="Ogre::SceneManager::operator delete[]" ref="93e6a86dde5483c053ca0f2a85bbfd6c" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[]           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00106">106</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="595ea4c05da8aa987d3800e65d23355d"></a><!-- doxytag: member="Ogre::SceneManager::operator delete[]" ref="595ea4c05da8aa987d3800e65d23355d" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[]           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00112">112</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="25811fa0c23672b27dccfffd48bec43a"></a><!-- doxytag: member="Ogre::SceneManager::SceneMgrQueuedRenderableVisitor" ref="25811fa0c23672b27dccfffd48bec43a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow visitor helper to access protected methods. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00892">892</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="da8f4ecc06b8ffe99834d8e1db66c123"></a><!-- doxytag: member="Ogre::SceneManager::WORLD_GEOMETRY_TYPE_MASK" ref="da8f4ecc06b8ffe99834d8e1db66c123" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="el" href="classOgre_1_1SceneManager.html#da8f4ecc06b8ffe99834d8e1db66c123">Ogre::SceneManager::WORLD_GEOMETRY_TYPE_MASK</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query type mask which will be used for world geometry. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00145">145</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="43d0ee887419ee93d24975b906eb2783"></a><!-- doxytag: member="Ogre::SceneManager::ENTITY_TYPE_MASK" ref="43d0ee887419ee93d24975b906eb2783" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="el" href="classOgre_1_1SceneManager.html#43d0ee887419ee93d24975b906eb2783">Ogre::SceneManager::ENTITY_TYPE_MASK</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query type mask which will be used for entities. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00147">147</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c036d861c2df264375b88e9f3a407b1e"></a><!-- doxytag: member="Ogre::SceneManager::FX_TYPE_MASK" ref="c036d861c2df264375b88e9f3a407b1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="el" href="classOgre_1_1SceneManager.html#c036d861c2df264375b88e9f3a407b1e">Ogre::SceneManager::FX_TYPE_MASK</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query type mask which will be used for effects like billboardsets / particle systems. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00149">149</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="369ad7a1b8e0455052ea0bca0383942e"></a><!-- doxytag: member="Ogre::SceneManager::STATICGEOMETRY_TYPE_MASK" ref="369ad7a1b8e0455052ea0bca0383942e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="el" href="classOgre_1_1SceneManager.html#369ad7a1b8e0455052ea0bca0383942e">Ogre::SceneManager::STATICGEOMETRY_TYPE_MASK</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query type mask which will be used for <a class="el" href="classOgre_1_1StaticGeometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene...">StaticGeometry</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00151">151</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="eb00e5cde673e9bcf74ec69027cf8039"></a><!-- doxytag: member="Ogre::SceneManager::LIGHT_TYPE_MASK" ref="eb00e5cde673e9bcf74ec69027cf8039" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="el" href="classOgre_1_1SceneManager.html#eb00e5cde673e9bcf74ec69027cf8039">Ogre::SceneManager::LIGHT_TYPE_MASK</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query type mask which will be used for lights. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00153">153</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e0f8858848acb8c595f495db753facb9"></a><!-- doxytag: member="Ogre::SceneManager::FRUSTUM_TYPE_MASK" ref="e0f8858848acb8c595f495db753facb9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="el" href="classOgre_1_1SceneManager.html#e0f8858848acb8c595f495db753facb9">Ogre::SceneManager::FRUSTUM_TYPE_MASK</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Query type mask which will be used for frusta and cameras. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00155">155</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="01d4bf3c6e81fddcfc96ec3f2714c8ac"></a><!-- doxytag: member="Ogre::SceneManager::USER_TYPE_MASK_LIMIT" ref="01d4bf3c6e81fddcfc96ec3f2714c8ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="el" href="classOgre_1_1SceneManager.html#01d4bf3c6e81fddcfc96ec3f2714c8ac">Ogre::SceneManager::USER_TYPE_MASK_LIMIT</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
User type mask limit. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00157">157</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0ff0b1a5241287f4ce969e9755079fb2"></a><!-- doxytag: member="Ogre::SceneManager::mName" ref="0ff0b1a5241287f4ce969e9755079fb2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1SceneManager.html#0ff0b1a5241287f4ce969e9755079fb2">Ogre::SceneManager::mName</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Instance name. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00333">333</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5411ad8b9ea980057db76161e58bb3d3"></a><!-- doxytag: member="Ogre::SceneManager::mRenderQueue" ref="5411ad8b9ea980057db76161e58bb3d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderQueue.html">RenderQueue</a>* <a class="el" href="classOgre_1_1SceneManager.html#5411ad8b9ea980057db76161e58bb3d3">Ogre::SceneManager::mRenderQueue</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queue of objects for rendering. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00336">336</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="63e5b71e4fe7e66e1e22ef900bc04912"></a><!-- doxytag: member="Ogre::SceneManager::mLastRenderQueueInvocationCustom" ref="63e5b71e4fe7e66e1e22ef900bc04912" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#63e5b71e4fe7e66e1e22ef900bc04912">Ogre::SceneManager::mLastRenderQueueInvocationCustom</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00337">337</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1046dbbb22cc771860703cfca3a9d06a"></a><!-- doxytag: member="Ogre::SceneManager::mAmbientLight" ref="1046dbbb22cc771860703cfca3a9d06a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> <a class="el" href="classOgre_1_1SceneManager.html#1046dbbb22cc771860703cfca3a9d06a">Ogre::SceneManager::mAmbientLight</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Current ambient light, cached for <a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a>. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00340">340</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8264f0c4e49a76667f3977acb955c7b1"></a><!-- doxytag: member="Ogre::SceneManager::mDestRenderSystem" ref="8264f0c4e49a76667f3977acb955c7b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1RenderSystem.html">RenderSystem</a>* <a class="el" href="classOgre_1_1SceneManager.html#8264f0c4e49a76667f3977acb955c7b1">Ogre::SceneManager::mDestRenderSystem</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The rendering system to send the scene to. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00343">343</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a7fc776f4946fdcf92c696524a4c2d4d"></a><!-- doxytag: member="Ogre::SceneManager::mCameras" ref="a7fc776f4946fdcf92c696524a4c2d4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#361c61a0f17ac50c8fd49bc0dd3ff622">CameraList</a> <a class="el" href="classOgre_1_1SceneManager.html#a7fc776f4946fdcf92c696524a4c2d4d">Ogre::SceneManager::mCameras</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Central list of cameras - for easy memory management and lookup. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00349">349</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0973d08b56629d0116237af5b948f771"></a><!-- doxytag: member="Ogre::SceneManager::mStaticGeometryList" ref="0973d08b56629d0116237af5b948f771" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#f9c15d5bd04bde23d9a6f1de191623b4">StaticGeometryList</a> <a class="el" href="classOgre_1_1SceneManager.html#0973d08b56629d0116237af5b948f771">Ogre::SceneManager::mStaticGeometryList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00352">352</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5aa17d2f39c5e8769f0e444db659fa91"></a><!-- doxytag: member="Ogre::SceneManager::mInstancedGeometryList" ref="5aa17d2f39c5e8769f0e444db659fa91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#2228301bdefd1eb05500e140d212771d">InstancedGeometryList</a> <a class="el" href="classOgre_1_1SceneManager.html#5aa17d2f39c5e8769f0e444db659fa91">Ogre::SceneManager::mInstancedGeometryList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00354">354</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a63f58cfe1efa7a19a2ae2227d58cabc"></a><!-- doxytag: member="Ogre::SceneManager::mSceneNodes" ref="a63f58cfe1efa7a19a2ae2227d58cabc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#f50133e2bd9b7629687560f221289559">SceneNodeList</a> <a class="el" href="classOgre_1_1SceneManager.html#a63f58cfe1efa7a19a2ae2227d58cabc">Ogre::SceneManager::mSceneNodes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Central list of SceneNodes - for easy memory management. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Note that this list is used only for memory management; the structure of the scene is held using the hierarchy of SceneNodes starting with the root node. However you can look up nodes this way. </dd></dl>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00364">364</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9a2f86d3b64b1a0a5f722fa4e18a0207"></a><!-- doxytag: member="Ogre::SceneManager::mCameraInProgress" ref="9a2f86d3b64b1a0a5f722fa4e18a0207" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Camera.html">Camera</a>* <a class="el" href="classOgre_1_1SceneManager.html#9a2f86d3b64b1a0a5f722fa4e18a0207">Ogre::SceneManager::mCameraInProgress</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classOgre_1_1Camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> in progress. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00367">367</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d341e52c96894a27d6bcc83760386e85"></a><!-- doxytag: member="Ogre::SceneManager::mCurrentViewport" ref="d341e52c96894a27d6bcc83760386e85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Viewport.html">Viewport</a>* <a class="el" href="classOgre_1_1SceneManager.html#d341e52c96894a27d6bcc83760386e85">Ogre::SceneManager::mCurrentViewport</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Current <a class="el" href="classOgre_1_1Viewport.html" title="An abstraction of a viewport, i.e.">Viewport</a>. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00369">369</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="47dc6b93ef3b1462268e4878bd8118e6"></a><!-- doxytag: member="Ogre::SceneManager::mSceneRoot" ref="47dc6b93ef3b1462268e4878bd8118e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* <a class="el" href="classOgre_1_1SceneManager.html#47dc6b93ef3b1462268e4878bd8118e6">Ogre::SceneManager::mSceneRoot</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classOgre_1_1Root.html" title="The root class of the Ogre system.">Root</a> scene node. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00372">372</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2496f428b7e345aeee68319ebf3848ea"></a><!-- doxytag: member="Ogre::SceneManager::mAutoTrackingSceneNodes" ref="2496f428b7e345aeee68319ebf3848ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#14f8ae72e357eb840b335c67fd991087">AutoTrackingSceneNodes</a> <a class="el" href="classOgre_1_1SceneManager.html#2496f428b7e345aeee68319ebf3848ea">Ogre::SceneManager::mAutoTrackingSceneNodes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00376">376</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1b356cfd900fc11d9aab12384db846f2"></a><!-- doxytag: member="Ogre::SceneManager::mSkyPlaneEntity" ref="1b356cfd900fc11d9aab12384db846f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Entity.html">Entity</a>* <a class="el" href="classOgre_1_1SceneManager.html#1b356cfd900fc11d9aab12384db846f2">Ogre::SceneManager::mSkyPlaneEntity</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00380">380</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d119673b6459a4417ccd6b9132f6949e"></a><!-- doxytag: member="Ogre::SceneManager::mSkyDomeEntity" ref="d119673b6459a4417ccd6b9132f6949e" args="[5]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Entity.html">Entity</a>* <a class="el" href="classOgre_1_1SceneManager.html#d119673b6459a4417ccd6b9132f6949e">Ogre::SceneManager::mSkyDomeEntity</a>[5]<code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00381">381</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1632eb9454092102844767bce15d1f22"></a><!-- doxytag: member="Ogre::SceneManager::mSkyBoxObj" ref="1632eb9454092102844767bce15d1f22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ManualObject.html">ManualObject</a>* <a class="el" href="classOgre_1_1SceneManager.html#1632eb9454092102844767bce15d1f22">Ogre::SceneManager::mSkyBoxObj</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00382">382</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a22625c805a1f0f666323afb95eae01c"></a><!-- doxytag: member="Ogre::SceneManager::mSkyPlaneNode" ref="a22625c805a1f0f666323afb95eae01c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* <a class="el" href="classOgre_1_1SceneManager.html#a22625c805a1f0f666323afb95eae01c">Ogre::SceneManager::mSkyPlaneNode</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00384">384</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="21476fa21be2e1fa6e822fa173ee4031"></a><!-- doxytag: member="Ogre::SceneManager::mSkyDomeNode" ref="21476fa21be2e1fa6e822fa173ee4031" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* <a class="el" href="classOgre_1_1SceneManager.html#21476fa21be2e1fa6e822fa173ee4031">Ogre::SceneManager::mSkyDomeNode</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00385">385</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9a97c216a74023a495dd4a913163c0ec"></a><!-- doxytag: member="Ogre::SceneManager::mSkyBoxNode" ref="9a97c216a74023a495dd4a913163c0ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneNode.html">SceneNode</a>* <a class="el" href="classOgre_1_1SceneManager.html#9a97c216a74023a495dd4a913163c0ec">Ogre::SceneManager::mSkyBoxNode</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00386">386</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="743ba63a3432f88ffae6d01c7887b754"></a><!-- doxytag: member="Ogre::SceneManager::mSkyPlaneEnabled" ref="743ba63a3432f88ffae6d01c7887b754" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#743ba63a3432f88ffae6d01c7887b754">Ogre::SceneManager::mSkyPlaneEnabled</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00389">389</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="856c7625cb2589f10b57ea25c25d4ff6"></a><!-- doxytag: member="Ogre::SceneManager::mSkyPlaneRenderQueue" ref="856c7625cb2589f10b57ea25c25d4ff6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> <a class="el" href="classOgre_1_1SceneManager.html#856c7625cb2589f10b57ea25c25d4ff6">Ogre::SceneManager::mSkyPlaneRenderQueue</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00390">390</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cc6d350acb01f02cbf50090451610e38"></a><!-- doxytag: member="Ogre::SceneManager::mSkyPlane" ref="cc6d350acb01f02cbf50090451610e38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Plane.html">Plane</a> <a class="el" href="classOgre_1_1SceneManager.html#cc6d350acb01f02cbf50090451610e38">Ogre::SceneManager::mSkyPlane</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00391">391</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6c4e525a3069ba18e984aafd7bb4166f"></a><!-- doxytag: member="Ogre::SceneManager::mSkyPlaneGenParameters" ref="6c4e525a3069ba18e984aafd7bb4166f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOgre_1_1SceneManager_1_1SkyPlaneGenParameters.html">SkyPlaneGenParameters</a> <a class="el" href="classOgre_1_1SceneManager.html#6c4e525a3069ba18e984aafd7bb4166f">Ogre::SceneManager::mSkyPlaneGenParameters</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00392">392</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="870b9f0b19b51dd4de3450a7b8f1dada"></a><!-- doxytag: member="Ogre::SceneManager::mSkyBoxEnabled" ref="870b9f0b19b51dd4de3450a7b8f1dada" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#870b9f0b19b51dd4de3450a7b8f1dada">Ogre::SceneManager::mSkyBoxEnabled</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00394">394</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c1c486c6f054ee0ad11a546787dd3c92"></a><!-- doxytag: member="Ogre::SceneManager::mSkyBoxRenderQueue" ref="c1c486c6f054ee0ad11a546787dd3c92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> <a class="el" href="classOgre_1_1SceneManager.html#c1c486c6f054ee0ad11a546787dd3c92">Ogre::SceneManager::mSkyBoxRenderQueue</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00395">395</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9a0a6799f6c031e3ba5e19e52e224be1"></a><!-- doxytag: member="Ogre::SceneManager::mSkyBoxOrientation" ref="9a0a6799f6c031e3ba5e19e52e224be1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> <a class="el" href="classOgre_1_1SceneManager.html#9a0a6799f6c031e3ba5e19e52e224be1">Ogre::SceneManager::mSkyBoxOrientation</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00396">396</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="fc3531fffee2ca7a25951a0a0a59af50"></a><!-- doxytag: member="Ogre::SceneManager::mSkyBoxGenParameters" ref="fc3531fffee2ca7a25951a0a0a59af50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOgre_1_1SceneManager_1_1SkyBoxGenParameters.html">SkyBoxGenParameters</a> <a class="el" href="classOgre_1_1SceneManager.html#fc3531fffee2ca7a25951a0a0a59af50">Ogre::SceneManager::mSkyBoxGenParameters</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00397">397</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6be93df7298573396205fcad20e51d80"></a><!-- doxytag: member="Ogre::SceneManager::mSkyDomeEnabled" ref="6be93df7298573396205fcad20e51d80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#6be93df7298573396205fcad20e51d80">Ogre::SceneManager::mSkyDomeEnabled</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00399">399</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c5ec31ff245698c0ca5d5cb86e14b40c"></a><!-- doxytag: member="Ogre::SceneManager::mSkyDomeRenderQueue" ref="c5ec31ff245698c0ca5d5cb86e14b40c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> <a class="el" href="classOgre_1_1SceneManager.html#c5ec31ff245698c0ca5d5cb86e14b40c">Ogre::SceneManager::mSkyDomeRenderQueue</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00400">400</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="332c8e9c42e45503ceb067b3ebb7f469"></a><!-- doxytag: member="Ogre::SceneManager::mSkyDomeOrientation" ref="332c8e9c42e45503ceb067b3ebb7f469" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Quaternion.html">Quaternion</a> <a class="el" href="classOgre_1_1SceneManager.html#332c8e9c42e45503ceb067b3ebb7f469">Ogre::SceneManager::mSkyDomeOrientation</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00401">401</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="68bc63ccd0178ee6812cd792ac25ff1e"></a><!-- doxytag: member="Ogre::SceneManager::mSkyDomeGenParameters" ref="68bc63ccd0178ee6812cd792ac25ff1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOgre_1_1SceneManager_1_1SkyDomeGenParameters.html">SkyDomeGenParameters</a> <a class="el" href="classOgre_1_1SceneManager.html#68bc63ccd0178ee6812cd792ac25ff1e">Ogre::SceneManager::mSkyDomeGenParameters</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00402">402</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="17ed14a33b5393704f343d2c90568588"></a><!-- doxytag: member="Ogre::SceneManager::mFogMode" ref="17ed14a33b5393704f343d2c90568588" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> <a class="el" href="classOgre_1_1SceneManager.html#17ed14a33b5393704f343d2c90568588">Ogre::SceneManager::mFogMode</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00405">405</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="77a36143ecafeea94fc7a0656ffaf112"></a><!-- doxytag: member="Ogre::SceneManager::mFogColour" ref="77a36143ecafeea94fc7a0656ffaf112" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> <a class="el" href="classOgre_1_1SceneManager.html#77a36143ecafeea94fc7a0656ffaf112">Ogre::SceneManager::mFogColour</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00406">406</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d697a57bccc4fc33010c2f8151330605"></a><!-- doxytag: member="Ogre::SceneManager::mFogStart" ref="d697a57bccc4fc33010c2f8151330605" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="classOgre_1_1SceneManager.html#d697a57bccc4fc33010c2f8151330605">Ogre::SceneManager::mFogStart</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00407">407</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3af93cd3e5f38b3554d3328ceb0df312"></a><!-- doxytag: member="Ogre::SceneManager::mFogEnd" ref="3af93cd3e5f38b3554d3328ceb0df312" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="classOgre_1_1SceneManager.html#3af93cd3e5f38b3554d3328ceb0df312">Ogre::SceneManager::mFogEnd</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00408">408</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="08ed5443cb044a3f6fb749cb90454b49"></a><!-- doxytag: member="Ogre::SceneManager::mFogDensity" ref="08ed5443cb044a3f6fb749cb90454b49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="classOgre_1_1SceneManager.html#08ed5443cb044a3f6fb749cb90454b49">Ogre::SceneManager::mFogDensity</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00409">409</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4d8e465d0733b5a86dc1935efcdc3af4"></a><!-- doxytag: member="Ogre::SceneManager::mSpecialCaseQueueList" ref="4d8e465d0733b5a86dc1935efcdc3af4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#8864f70edf5d284c2be437d4d586e505">SpecialCaseRenderQueueList</a> <a class="el" href="classOgre_1_1SceneManager.html#4d8e465d0733b5a86dc1935efcdc3af4">Ogre::SceneManager::mSpecialCaseQueueList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00412">412</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c23b56bba91b3582f8af00dbf8050dd5"></a><!-- doxytag: member="Ogre::SceneManager::mSpecialCaseQueueMode" ref="c23b56bba91b3582f8af00dbf8050dd5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#6aa3039230bf91b09b8587dba0c482c6">SpecialCaseRenderQueueMode</a> <a class="el" href="classOgre_1_1SceneManager.html#c23b56bba91b3582f8af00dbf8050dd5">Ogre::SceneManager::mSpecialCaseQueueMode</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00413">413</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="eb54113eccb7f6f55e70f9319932373a"></a><!-- doxytag: member="Ogre::SceneManager::mWorldGeometryRenderQueue" ref="eb54113eccb7f6f55e70f9319932373a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> <a class="el" href="classOgre_1_1SceneManager.html#eb54113eccb7f6f55e70f9319932373a">Ogre::SceneManager::mWorldGeometryRenderQueue</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00414">414</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a3a4b9ce9a0f555e8e52de3a8bbdf5c0"></a><!-- doxytag: member="Ogre::SceneManager::mLastFrameNumber" ref="a3a4b9ce9a0f555e8e52de3a8bbdf5c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classOgre_1_1SceneManager.html#a3a4b9ce9a0f555e8e52de3a8bbdf5c0">Ogre::SceneManager::mLastFrameNumber</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00416">416</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="784d6dc8b5c3336f34fd78cea0d718d4"></a><!-- doxytag: member="Ogre::SceneManager::mTempXform" ref="784d6dc8b5c3336f34fd78cea0d718d4" args="[256]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> <a class="el" href="classOgre_1_1SceneManager.html#784d6dc8b5c3336f34fd78cea0d718d4">Ogre::SceneManager::mTempXform</a>[256]<code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00417">417</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c35d16e51f409760b8dd2766b63d647"></a><!-- doxytag: member="Ogre::SceneManager::mResetIdentityView" ref="1c35d16e51f409760b8dd2766b63d647" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#1c35d16e51f409760b8dd2766b63d647">Ogre::SceneManager::mResetIdentityView</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00418">418</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="000946f678ee7508dfbc31268c5d966e"></a><!-- doxytag: member="Ogre::SceneManager::mResetIdentityProj" ref="000946f678ee7508dfbc31268c5d966e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#000946f678ee7508dfbc31268c5d966e">Ogre::SceneManager::mResetIdentityProj</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00419">419</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d86119ced614f90d301930b1b0f19588"></a><!-- doxytag: member="Ogre::SceneManager::mNormaliseNormalsOnScale" ref="d86119ced614f90d301930b1b0f19588" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#d86119ced614f90d301930b1b0f19588">Ogre::SceneManager::mNormaliseNormalsOnScale</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00421">421</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="fc663fea2a213f5c0800259604c84df5"></a><!-- doxytag: member="Ogre::SceneManager::mFlipCullingOnNegativeScale" ref="fc663fea2a213f5c0800259604c84df5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#fc663fea2a213f5c0800259604c84df5">Ogre::SceneManager::mFlipCullingOnNegativeScale</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00422">422</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3797a6b398dda83a98ff62d9883aac9c"></a><!-- doxytag: member="Ogre::SceneManager::mPassCullingMode" ref="3797a6b398dda83a98ff62d9883aac9c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a> <a class="el" href="classOgre_1_1SceneManager.html#3797a6b398dda83a98ff62d9883aac9c">Ogre::SceneManager::mPassCullingMode</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00423">423</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ba61fc3252c41dca8fb9a161fee093e0"></a><!-- doxytag: member="Ogre::SceneManager::mCamVisibleObjectsMap" ref="ba61fc3252c41dca8fb9a161fee093e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#99e7aa7b0f6f45e6cc750668cebf53e3">CamVisibleObjectsMap</a> <a class="el" href="classOgre_1_1SceneManager.html#ba61fc3252c41dca8fb9a161fee093e0">Ogre::SceneManager::mCamVisibleObjectsMap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00435">435</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="604f8366d8b27064a4a20f48cc37dac4"></a><!-- doxytag: member="Ogre::SceneManager::mShadowCamLightMapping" ref="604f8366d8b27064a4a20f48cc37dac4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#6ce1f7a7cc475c7cf797eb3867a4a01c">ShadowCamLightMapping</a> <a class="el" href="classOgre_1_1SceneManager.html#604f8366d8b27064a4a20f48cc37dac4">Ogre::SceneManager::mShadowCamLightMapping</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00439">439</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ca3a6092095443e4a5a7fb8169bcf83e"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCountPerType" ref="ca3a6092095443e4a5a7fb8169bcf83e" args="[3]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classOgre_1_1SceneManager.html#ca3a6092095443e4a5a7fb8169bcf83e">Ogre::SceneManager::mShadowTextureCountPerType</a>[3]<code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array defining shadow count per light type. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00442">442</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8f714dccdf13fcf8d9ad2d80ab55933a"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureIndexLightList" ref="8f714dccdf13fcf8d9ad2d80ab55933a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; <a class="el" href="classOgre_1_1SceneManager.html#8f714dccdf13fcf8d9ad2d80ab55933a">Ogre::SceneManager::mShadowTextureIndexLightList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array defining shadow texture index in light list. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00445">445</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="64adaac04645e2f83bf04862a20c5d45"></a><!-- doxytag: member="Ogre::SceneManager::mLightsAffectingFrustum" ref="64adaac04645e2f83bf04862a20c5d45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#b82c6299605910b4051ebb3cc3e5539e">LightList</a> <a class="el" href="classOgre_1_1SceneManager.html#64adaac04645e2f83bf04862a20c5d45">Ogre::SceneManager::mLightsAffectingFrustum</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00469">469</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="da2783d02c2dcd52fb91e0409ab5ec20"></a><!-- doxytag: member="Ogre::SceneManager::mCachedLightInfos" ref="da2783d02c2dcd52fb91e0409ab5ec20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#05443775a1f947308c5d90a24d45ed6f">LightInfoList</a> <a class="el" href="classOgre_1_1SceneManager.html#da2783d02c2dcd52fb91e0409ab5ec20">Ogre::SceneManager::mCachedLightInfos</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00470">470</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="72f4d87312aee00bd2236e4ae1331b35"></a><!-- doxytag: member="Ogre::SceneManager::mTestLightInfos" ref="72f4d87312aee00bd2236e4ae1331b35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#05443775a1f947308c5d90a24d45ed6f">LightInfoList</a> <a class="el" href="classOgre_1_1SceneManager.html#72f4d87312aee00bd2236e4ae1331b35">Ogre::SceneManager::mTestLightInfos</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00471">471</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cd54728be554ef19ce5cdf207de09959"></a><!-- doxytag: member="Ogre::SceneManager::mLightsDirtyCounter" ref="cd54728be554ef19ce5cdf207de09959" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#4304981347643708ee9a7ba8884e5758">ulong</a> <a class="el" href="classOgre_1_1SceneManager.html#cd54728be554ef19ce5cdf207de09959">Ogre::SceneManager::mLightsDirtyCounter</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00472">472</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8a3af0a8a5116a4a02dd3d8420078658"></a><!-- doxytag: member="Ogre::SceneManager::mMovableObjectCollectionMap" ref="8a3af0a8a5116a4a02dd3d8420078658" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#5bdfdd7b221b17f4901a1c53d4011e80">MovableObjectCollectionMap</a> <a class="el" href="classOgre_1_1SceneManager.html#8a3af0a8a5116a4a02dd3d8420078658">Ogre::SceneManager::mMovableObjectCollectionMap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00482">482</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="adaa9d36a795c8dad209fb4740015a30"></a><!-- doxytag: member="Ogre::SceneManager::mShadowCasterPlainBlackPass" ref="adaa9d36a795c8dad209fb4740015a30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* <a class="el" href="classOgre_1_1SceneManager.html#adaa9d36a795c8dad209fb4740015a30">Ogre::SceneManager::mShadowCasterPlainBlackPass</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A pass designed to let us render shadow colour on white for texture shadows. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00502">502</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="593f82c978aa7ab17043dead7a24d29f"></a><!-- doxytag: member="Ogre::SceneManager::mShadowReceiverPass" ref="593f82c978aa7ab17043dead7a24d29f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* <a class="el" href="classOgre_1_1SceneManager.html#593f82c978aa7ab17043dead7a24d29f">Ogre::SceneManager::mShadowReceiverPass</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A pass designed to let us render shadow receivers for texture shadows. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00504">504</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="070effc83d84478c31dc811dc92703c7"></a><!-- doxytag: member="Ogre::SceneManager::mDisplayNodes" ref="070effc83d84478c31dc811dc92703c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#070effc83d84478c31dc811dc92703c7">Ogre::SceneManager::mDisplayNodes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00569">569</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7c96613569926a2bbe5a359644157482"></a><!-- doxytag: member="Ogre::SceneManager::mAnimationsList" ref="7c96613569926a2bbe5a359644157482" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#260738557c9a32aed8d5ca14c28d300f">AnimationList</a> <a class="el" href="classOgre_1_1SceneManager.html#7c96613569926a2bbe5a359644157482">Ogre::SceneManager::mAnimationsList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00573">573</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="20a4a6f6531d749b1436be1184264c0b"></a><!-- doxytag: member="Ogre::SceneManager::mAnimationStates" ref="20a4a6f6531d749b1436be1184264c0b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1AnimationStateSet.html">AnimationStateSet</a> <a class="el" href="classOgre_1_1SceneManager.html#20a4a6f6531d749b1436be1184264c0b">Ogre::SceneManager::mAnimationStates</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00575">575</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d0c4537d20d352ad2818ec7cabcb7e7b"></a><!-- doxytag: member="Ogre::SceneManager::mRenderQueueListeners" ref="d0c4537d20d352ad2818ec7cabcb7e7b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#b55740025112ba1139656d035f27bb45">RenderQueueListenerList</a> <a class="el" href="classOgre_1_1SceneManager.html#d0c4537d20d352ad2818ec7cabcb7e7b">Ogre::SceneManager::mRenderQueueListeners</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00587">587</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="077722cc09750f78a8769b0ed5e5bf72"></a><!-- doxytag: member="Ogre::SceneManager::mListeners" ref="077722cc09750f78a8769b0ed5e5bf72" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#9e4af19ff8fe945ba6e50dc1b71918da">ListenerList</a> <a class="el" href="classOgre_1_1SceneManager.html#077722cc09750f78a8769b0ed5e5bf72">Ogre::SceneManager::mListeners</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00590">590</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ecf3af703dea330078f41ab6ed016c7e"></a><!-- doxytag: member="Ogre::SceneManager::mShowBoundingBoxes" ref="ecf3af703dea330078f41ab6ed016c7e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#ecf3af703dea330078f41ab6ed016c7e">Ogre::SceneManager::mShowBoundingBoxes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag that indicates if all of the scene node's bounding boxes should be shown as a wireframe. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00610">610</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="63d007556fe8e97a917d952494c8e3a5"></a><!-- doxytag: member="Ogre::SceneManager::mAutoParamDataSource" ref="63d007556fe8e97a917d952494c8e3a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1AutoParamDataSource.html">AutoParamDataSource</a>* <a class="el" href="classOgre_1_1SceneManager.html#63d007556fe8e97a917d952494c8e3a5">Ogre::SceneManager::mAutoParamDataSource</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Utility class for calculating automatic parameters for gpu programs. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00645">645</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7adaeed1d654ab66a2c7fff4c03a431e"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTechnique" ref="7adaeed1d654ab66a2c7fff4c03a431e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#79dcd426d291c31072c1ad6f183715d6">ShadowTechnique</a> <a class="el" href="classOgre_1_1SceneManager.html#7adaeed1d654ab66a2c7fff4c03a431e">Ogre::SceneManager::mShadowTechnique</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00647">647</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="54cbafb5e6dcc0e9f324d3898cead7ef"></a><!-- doxytag: member="Ogre::SceneManager::mDebugShadows" ref="54cbafb5e6dcc0e9f324d3898cead7ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#54cbafb5e6dcc0e9f324d3898cead7ef">Ogre::SceneManager::mDebugShadows</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00648">648</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f888882852ac5512310c18017e7921e5"></a><!-- doxytag: member="Ogre::SceneManager::mShadowColour" ref="f888882852ac5512310c18017e7921e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> <a class="el" href="classOgre_1_1SceneManager.html#f888882852ac5512310c18017e7921e5">Ogre::SceneManager::mShadowColour</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00649">649</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9276e06185787c851f1ff54a152f28ad"></a><!-- doxytag: member="Ogre::SceneManager::mShadowDebugPass" ref="9276e06185787c851f1ff54a152f28ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* <a class="el" href="classOgre_1_1SceneManager.html#9276e06185787c851f1ff54a152f28ad">Ogre::SceneManager::mShadowDebugPass</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00650">650</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="97eb70f23035e4cf0f75aadd11850b57"></a><!-- doxytag: member="Ogre::SceneManager::mShadowStencilPass" ref="97eb70f23035e4cf0f75aadd11850b57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* <a class="el" href="classOgre_1_1SceneManager.html#97eb70f23035e4cf0f75aadd11850b57">Ogre::SceneManager::mShadowStencilPass</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00651">651</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a14524c82d79c3e76942b0fd6dac3ac3"></a><!-- doxytag: member="Ogre::SceneManager::mShadowModulativePass" ref="a14524c82d79c3e76942b0fd6dac3ac3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* <a class="el" href="classOgre_1_1SceneManager.html#a14524c82d79c3e76942b0fd6dac3ac3">Ogre::SceneManager::mShadowModulativePass</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00652">652</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="63c239863d9a55286a5cb7a024793659"></a><!-- doxytag: member="Ogre::SceneManager::mShadowMaterialInitDone" ref="63c239863d9a55286a5cb7a024793659" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#63c239863d9a55286a5cb7a024793659">Ogre::SceneManager::mShadowMaterialInitDone</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00653">653</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="63697c1137a52b5e02035b66b6de9874"></a><!-- doxytag: member="Ogre::SceneManager::mShadowIndexBuffer" ref="63697c1137a52b5e02035b66b6de9874" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1HardwareIndexBufferSharedPtr.html">HardwareIndexBufferSharedPtr</a> <a class="el" href="classOgre_1_1SceneManager.html#63697c1137a52b5e02035b66b6de9874">Ogre::SceneManager::mShadowIndexBuffer</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00654">654</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7475f0391505adff66471a7d8b0a4da8"></a><!-- doxytag: member="Ogre::SceneManager::mShadowIndexBufferSize" ref="7475f0391505adff66471a7d8b0a4da8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classOgre_1_1SceneManager.html#7475f0391505adff66471a7d8b0a4da8">Ogre::SceneManager::mShadowIndexBufferSize</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00655">655</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="dd5db2bd810b8c5565afa345de0e0dfb"></a><!-- doxytag: member="Ogre::SceneManager::mFullScreenQuad" ref="dd5db2bd810b8c5565afa345de0e0dfb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Rectangle2D.html">Rectangle2D</a>* <a class="el" href="classOgre_1_1SceneManager.html#dd5db2bd810b8c5565afa345de0e0dfb">Ogre::SceneManager::mFullScreenQuad</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00656">656</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="45946d6a943570d2d7ac0a803a75c77e"></a><!-- doxytag: member="Ogre::SceneManager::mShadowDirLightExtrudeDist" ref="45946d6a943570d2d7ac0a803a75c77e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="classOgre_1_1SceneManager.html#45946d6a943570d2d7ac0a803a75c77e">Ogre::SceneManager::mShadowDirLightExtrudeDist</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00657">657</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="fcdad5f25f6c3956c11a824fba5d68ec"></a><!-- doxytag: member="Ogre::SceneManager::mIlluminationStage" ref="fcdad5f25f6c3956c11a824fba5d68ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#51db39cc4fa15b28086a1793d42fc827">IlluminationRenderStage</a> <a class="el" href="classOgre_1_1SceneManager.html#fcdad5f25f6c3956c11a824fba5d68ec">Ogre::SceneManager::mIlluminationStage</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00658">658</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="76f9b63473b07dd34092f46f79f88e54"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureConfigList" ref="76f9b63473b07dd34092f46f79f88e54" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#498ca415d30ec282949ce7dce9d1db69">ShadowTextureConfigList</a> <a class="el" href="classOgre_1_1SceneManager.html#76f9b63473b07dd34092f46f79f88e54">Ogre::SceneManager::mShadowTextureConfigList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00659">659</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a893151c589403e0c043d8edf6d67448"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureConfigDirty" ref="a893151c589403e0c043d8edf6d67448" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#a893151c589403e0c043d8edf6d67448">Ogre::SceneManager::mShadowTextureConfigDirty</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00660">660</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="eee75145f20f44d4bcdeba9d1884a13b"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextures" ref="eee75145f20f44d4bcdeba9d1884a13b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#b5efceec9e1a6e88e156564c15e86f6a">ShadowTextureList</a> <a class="el" href="classOgre_1_1SceneManager.html#eee75145f20f44d4bcdeba9d1884a13b">Ogre::SceneManager::mShadowTextures</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00661">661</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="67ade0caa6fe5a91ad14e2d79c294bb8"></a><!-- doxytag: member="Ogre::SceneManager::mNullShadowTexture" ref="67ade0caa6fe5a91ad14e2d79c294bb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1TexturePtr.html">TexturePtr</a> <a class="el" href="classOgre_1_1SceneManager.html#67ade0caa6fe5a91ad14e2d79c294bb8">Ogre::SceneManager::mNullShadowTexture</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00662">662</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="5a89503b16636ebf9a99605b707b2d9d"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCameras" ref="5a89503b16636ebf9a99605b707b2d9d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#19a90448272159c7f2e2c7573b181151">ShadowTextureCameraList</a> <a class="el" href="classOgre_1_1SceneManager.html#5a89503b16636ebf9a99605b707b2d9d">Ogre::SceneManager::mShadowTextureCameras</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00664">664</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a14bcf591faa2d30fefc0fcb7c5857c4"></a><!-- doxytag: member="Ogre::SceneManager::mCurrentShadowTexture" ref="a14bcf591faa2d30fefc0fcb7c5857c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Texture.html">Texture</a>* <a class="el" href="classOgre_1_1SceneManager.html#a14bcf591faa2d30fefc0fcb7c5857c4">Ogre::SceneManager::mCurrentShadowTexture</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00665">665</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e71bff7c7babb2f8a92346427d8c5fa1"></a><!-- doxytag: member="Ogre::SceneManager::mShadowUseInfiniteFarPlane" ref="e71bff7c7babb2f8a92346427d8c5fa1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#e71bff7c7babb2f8a92346427d8c5fa1">Ogre::SceneManager::mShadowUseInfiniteFarPlane</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00666">666</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3159f28f48646517418ce319b9b7dec8"></a><!-- doxytag: member="Ogre::SceneManager::mShadowCasterRenderBackFaces" ref="3159f28f48646517418ce319b9b7dec8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#3159f28f48646517418ce319b9b7dec8">Ogre::SceneManager::mShadowCasterRenderBackFaces</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00667">667</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="933194ab15d699b1be5142ae705a010e"></a><!-- doxytag: member="Ogre::SceneManager::mShadowAdditiveLightClip" ref="933194ab15d699b1be5142ae705a010e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#933194ab15d699b1be5142ae705a010e">Ogre::SceneManager::mShadowAdditiveLightClip</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00668">668</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9c12c8a290ce0ea51efef380760f27c8"></a><!-- doxytag: member="Ogre::SceneManager::mLightClippingInfoMap" ref="9c12c8a290ce0ea51efef380760f27c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#c2e1d3390dfc6b3d58fdb934d75ce760">LightClippingInfoMap</a> <a class="el" href="classOgre_1_1SceneManager.html#9c12c8a290ce0ea51efef380760f27c8">Ogre::SceneManager::mLightClippingInfoMap</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00680">680</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c7fe720c6553bf245b058b9f5281b220"></a><!-- doxytag: member="Ogre::SceneManager::mLightClippingInfoMapFrameNumber" ref="c7fe720c6553bf245b058b9f5281b220" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classOgre_1_1SceneManager.html#c7fe720c6553bf245b058b9f5281b220">Ogre::SceneManager::mLightClippingInfoMapFrameNumber</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00681">681</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ed1f03f6ccf8735715458aae3cd720ec"></a><!-- doxytag: member="Ogre::SceneManager::mDefaultShadowCameraSetup" ref="ed1f03f6ccf8735715458aae3cd720ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SharedPtr.html">ShadowCameraSetupPtr</a> <a class="el" href="classOgre_1_1SceneManager.html#ed1f03f6ccf8735715458aae3cd720ec">Ogre::SceneManager::mDefaultShadowCameraSetup</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
default shadow camera setup 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00684">684</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e6d775195f3f8831650e4baaebf89433"></a><!-- doxytag: member="Ogre::SceneManager::mShadowCasterList" ref="e6d775195f3f8831650e4baaebf89433" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager.html#25fa6eff947e61a00179e65b7a466100">ShadowCasterList</a> <a class="el" href="classOgre_1_1SceneManager.html#e6d775195f3f8831650e4baaebf89433">Ogre::SceneManager::mShadowCasterList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00736">736</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f0e984eaa8115c9753bcd84b4bd3cc11"></a><!-- doxytag: member="Ogre::SceneManager::mShadowCasterSphereQuery" ref="f0e984eaa8115c9753bcd84b4bd3cc11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SphereSceneQuery.html">SphereSceneQuery</a>* <a class="el" href="classOgre_1_1SceneManager.html#f0e984eaa8115c9753bcd84b4bd3cc11">Ogre::SceneManager::mShadowCasterSphereQuery</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00737">737</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c6f6e1290244f6d0dd1347d8ce3453b"></a><!-- doxytag: member="Ogre::SceneManager::mShadowCasterAABBQuery" ref="1c6f6e1290244f6d0dd1347d8ce3453b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1AxisAlignedBoxSceneQuery.html">AxisAlignedBoxSceneQuery</a>* <a class="el" href="classOgre_1_1SceneManager.html#1c6f6e1290244f6d0dd1347d8ce3453b">Ogre::SceneManager::mShadowCasterAABBQuery</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00738">738</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="155f9c139734d33fc7d9f03c6364cc4c"></a><!-- doxytag: member="Ogre::SceneManager::mDefaultShadowFarDist" ref="155f9c139734d33fc7d9f03c6364cc4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="classOgre_1_1SceneManager.html#155f9c139734d33fc7d9f03c6364cc4c">Ogre::SceneManager::mDefaultShadowFarDist</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00739">739</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="fd8165b0623ae10088f400f8a9d5b592"></a><!-- doxytag: member="Ogre::SceneManager::mDefaultShadowFarDistSquared" ref="fd8165b0623ae10088f400f8a9d5b592" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="classOgre_1_1SceneManager.html#fd8165b0623ae10088f400f8a9d5b592">Ogre::SceneManager::mDefaultShadowFarDistSquared</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00740">740</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0fd0fee334159816771d34a2a03e1abe"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureOffset" ref="0fd0fee334159816771d34a2a03e1abe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="classOgre_1_1SceneManager.html#0fd0fee334159816771d34a2a03e1abe">Ogre::SceneManager::mShadowTextureOffset</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00741">741</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2f270a0f22844b6690c835c80ab51145"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureFadeStart" ref="2f270a0f22844b6690c835c80ab51145" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="classOgre_1_1SceneManager.html#2f270a0f22844b6690c835c80ab51145">Ogre::SceneManager::mShadowTextureFadeStart</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00742">742</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8fc134ed20d116daefa494b06554b7c8"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureFadeEnd" ref="8fc134ed20d116daefa494b06554b7c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> <a class="el" href="classOgre_1_1SceneManager.html#8fc134ed20d116daefa494b06554b7c8">Ogre::SceneManager::mShadowTextureFadeEnd</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00743">743</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2d366a01e2b7fea9e7eae781a25268a6"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureSelfShadow" ref="2d366a01e2b7fea9e7eae781a25268a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#2d366a01e2b7fea9e7eae781a25268a6">Ogre::SceneManager::mShadowTextureSelfShadow</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00744">744</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0ea1617bdda02c23a72330a647ea09a0"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCustomCasterPass" ref="0ea1617bdda02c23a72330a647ea09a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* <a class="el" href="classOgre_1_1SceneManager.html#0ea1617bdda02c23a72330a647ea09a0">Ogre::SceneManager::mShadowTextureCustomCasterPass</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00745">745</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8ea12599e955972ac959ef94c52e35af"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCustomReceiverPass" ref="8ea12599e955972ac959ef94c52e35af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* <a class="el" href="classOgre_1_1SceneManager.html#8ea12599e955972ac959ef94c52e35af">Ogre::SceneManager::mShadowTextureCustomReceiverPass</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00746">746</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="12145dec119385784c27245b380ddc5a"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCustomCasterVertexProgram" ref="12145dec119385784c27245b380ddc5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1SceneManager.html#12145dec119385784c27245b380ddc5a">Ogre::SceneManager::mShadowTextureCustomCasterVertexProgram</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00747">747</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cc8a7c17bedf51c442ed02ed23ef30e3"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCustomReceiverVertexProgram" ref="cc8a7c17bedf51c442ed02ed23ef30e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1SceneManager.html#cc8a7c17bedf51c442ed02ed23ef30e3">Ogre::SceneManager::mShadowTextureCustomReceiverVertexProgram</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00748">748</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b6c7dec2b7a7d8122ae3784e56e59918"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCustomReceiverFragmentProgram" ref="b6c7dec2b7a7d8122ae3784e56e59918" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1SceneManager.html#b6c7dec2b7a7d8122ae3784e56e59918">Ogre::SceneManager::mShadowTextureCustomReceiverFragmentProgram</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00749">749</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="dcadb2b43a58490f9975ac44b553eedd"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCustomCasterVPParams" ref="dcadb2b43a58490f9975ac44b553eedd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a> <a class="el" href="classOgre_1_1SceneManager.html#dcadb2b43a58490f9975ac44b553eedd">Ogre::SceneManager::mShadowTextureCustomCasterVPParams</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00750">750</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="e12d0d35465b9395c984263db68ab752"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCustomReceiverVPParams" ref="e12d0d35465b9395c984263db68ab752" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a> <a class="el" href="classOgre_1_1SceneManager.html#e12d0d35465b9395c984263db68ab752">Ogre::SceneManager::mShadowTextureCustomReceiverVPParams</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00751">751</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="67563d09f914c80b7c007f08433b9e23"></a><!-- doxytag: member="Ogre::SceneManager::mShadowTextureCustomReceiverFPParams" ref="67563d09f914c80b7c007f08433b9e23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a> <a class="el" href="classOgre_1_1SceneManager.html#67563d09f914c80b7c007f08433b9e23">Ogre::SceneManager::mShadowTextureCustomReceiverFPParams</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00752">752</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="f330714bd5a60cf8fcdcb8998ae88fc3"></a><!-- doxytag: member="Ogre::SceneManager::mVisibilityMask" ref="f330714bd5a60cf8fcdcb8998ae88fc3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#df2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="el" href="classOgre_1_1SceneManager.html#f330714bd5a60cf8fcdcb8998ae88fc3">Ogre::SceneManager::mVisibilityMask</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Visibility mask used to show / hide objects. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00755">755</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d2a6d7cc9535ac69dc7e445b1cead58e"></a><!-- doxytag: member="Ogre::SceneManager::mFindVisibleObjects" ref="d2a6d7cc9535ac69dc7e445b1cead58e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#d2a6d7cc9535ac69dc7e445b1cead58e">Ogre::SceneManager::mFindVisibleObjects</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00756">756</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2f08653c064e776174c4881148f6e1ec"></a><!-- doxytag: member="Ogre::SceneManager::mSuppressRenderStateChanges" ref="2f08653c064e776174c4881148f6e1ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#2f08653c064e776174c4881148f6e1ec">Ogre::SceneManager::mSuppressRenderStateChanges</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suppress render state changes? 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00759">759</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0220be54b3b9c8be805be65e60f136d0"></a><!-- doxytag: member="Ogre::SceneManager::mSuppressShadows" ref="0220be54b3b9c8be805be65e60f136d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#0220be54b3b9c8be805be65e60f136d0">Ogre::SceneManager::mSuppressShadows</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suppress shadows? 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00761">761</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="a1886fd36b6128c7714ec1508f45821f"></a><!-- doxytag: member="Ogre::SceneManager::mInfiniteExtrusionParams" ref="a1886fd36b6128c7714ec1508f45821f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a> <a class="el" href="classOgre_1_1SceneManager.html#a1886fd36b6128c7714ec1508f45821f">Ogre::SceneManager::mInfiniteExtrusionParams</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00764">764</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b90bf0fcf5aa2c3597a811863ed0d274"></a><!-- doxytag: member="Ogre::SceneManager::mFiniteExtrusionParams" ref="b90bf0fcf5aa2c3597a811863ed0d274" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SharedPtr.html">GpuProgramParametersSharedPtr</a> <a class="el" href="classOgre_1_1SceneManager.html#b90bf0fcf5aa2c3597a811863ed0d274">Ogre::SceneManager::mFiniteExtrusionParams</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00765">765</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="35ebd62722964590cef05e5d0eb236f2"></a><!-- doxytag: member="Ogre::SceneManager::mShadowCasterQueryListener" ref="35ebd62722964590cef05e5d0eb236f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager_1_1ShadowCasterSceneQueryListener.html">ShadowCasterSceneQueryListener</a>* <a class="el" href="classOgre_1_1SceneManager.html#35ebd62722964590cef05e5d0eb236f2">Ogre::SceneManager::mShadowCasterQueryListener</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00799">799</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="585632a1f5cff9ab48205a7503ff1e69"></a><!-- doxytag: member="Ogre::SceneManager::mActiveQueuedRenderableVisitor" ref="585632a1f5cff9ab48205a7503ff1e69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a>* <a class="el" href="classOgre_1_1SceneManager.html#585632a1f5cff9ab48205a7503ff1e69">Ogre::SceneManager::mActiveQueuedRenderableVisitor</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The active renderable visitor class - subclasses could override this. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00894">894</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="ed9fbb65aff18fd3b1659f68c32bcef4"></a><!-- doxytag: member="Ogre::SceneManager::mDefaultQueuedRenderableVisitor" ref="ed9fbb65aff18fd3b1659f68c32bcef4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">SceneMgrQueuedRenderableVisitor</a> <a class="el" href="classOgre_1_1SceneManager.html#ed9fbb65aff18fd3b1659f68c32bcef4">Ogre::SceneManager::mDefaultQueuedRenderableVisitor</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Storage for default renderable visitor. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00896">896</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="dc88adbe55e6569c9b4d6b0e249a28df"></a><!-- doxytag: member="Ogre::SceneManager::mCameraRelativeRendering" ref="dc88adbe55e6569c9b4d6b0e249a28df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1SceneManager.html#dc88adbe55e6569c9b4d6b0e249a28df">Ogre::SceneManager::mCameraRelativeRendering</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether to use camera-relative rendering. 
<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00899">899</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="44e222e6fe97d76b98f031b72c9c2d7a"></a><!-- doxytag: member="Ogre::SceneManager::mCachedViewMatrix" ref="44e222e6fe97d76b98f031b72c9c2d7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Matrix4.html">Matrix4</a> <a class="el" href="classOgre_1_1SceneManager.html#44e222e6fe97d76b98f031b72c9c2d7a">Ogre::SceneManager::mCachedViewMatrix</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00900">900</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="54d12f1b064fdf8bf735f5fcfc95134a"></a><!-- doxytag: member="Ogre::SceneManager::mCameraRelativePosition" ref="54d12f1b064fdf8bf735f5fcfc95134a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Vector3.html">Vector3</a> <a class="el" href="classOgre_1_1SceneManager.html#54d12f1b064fdf8bf735f5fcfc95134a">Ogre::SceneManager::mCameraRelativePosition</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreSceneManager_8h-source.html#l00901">901</a> of file <a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="OgreSceneManager_8h-source.html">OgreSceneManager.h</a></ul>
<hr>
<p>
Copyright &copy; 2008 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Thu Jan 22 21:27:12 2009
</p>
</body>
</html>
