<html>
<head>
<title>OGRE: Ogre::Technique Class Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespaceOgre.html">Ogre</a>::<a class="el" href="classOgre_1_1Technique.html">Technique</a></div>
<h1>Ogre::Technique Class Reference</h1><!-- doxytag: class="Ogre::Technique" --><!-- doxytag: inherits="Ogre::AllocatedObject" -->Class representing an approach to rendering this particular <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Ogre::Technique:</div>
<div class="dynsection">
<p><center><img src="classOgre_1_1Technique__inherit__graph.gif" border="0" usemap="#Ogre_1_1Technique__inherit__map" alt="Inheritance graph"></center>
<map name="Ogre_1_1Technique__inherit__map">
<area shape="rect" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new..." alt="" coords="9,5,124,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classOgre_1_1Technique-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a> { <a class="el" href="classOgre_1_1Technique.html#1ade219e17b5e8d73d079d11f64a2a2dbd4cc2de655eff5194cda7ea50d00ee3">INCLUDE</a> =  0, 
<a class="el" href="classOgre_1_1Technique.html#1ade219e17b5e8d73d079d11f64a2a2d043f697946b7a6d01bb858768e6646a3">EXCLUDE</a> =  1
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directive used to manually control technique support based on the inclusion or exclusion of some factor.  <a href="classOgre_1_1Technique.html#1ade219e17b5e8d73d079d11f64a2a2d">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br>
&lt; <a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br>
&lt; <a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
<a class="el" href="classOgre_1_1VectorIterator.html">VectorIterator</a><br>
&lt; <a class="el" href="classOgre_1_1Technique.html#b6823bce807c243c04e544ee99eea1d1">Passes</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#3b4640d3383f331657fd9ee05cb835c2">PassIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
<a class="el" href="classOgre_1_1VectorIterator.html">VectorIterator</a><br>
&lt; <a class="el" href="namespaceOgre.html#ff4cf78f2520e56a8c45721e2dc419c9">IlluminationPassList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#77a239a5901d2c67add2e7cea0bf3468">IlluminationPassIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
<a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstVectorIterator</a><br>
&lt; <a class="el" href="classOgre_1_1Technique.html#02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#2497a0043902e9d2af0757d769da655c">GPUVendorRuleIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
<a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstVectorIterator</a><br>
&lt; <a class="el" href="classOgre_1_1Technique.html#19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#63da4eb10f7272486a9806374b09bab6">GPUDeviceNameRuleIterator</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#4bf5eef2cd88abdf3408234f2bb0899c">Technique</a> (<a class="el" href="classOgre_1_1Material.html">Material</a> *parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#4bf5eef2cd88abdf3408234f2bb0899c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#0e0fe6b1b297d9c8e81287d7c7a7b377">Technique</a> (<a class="el" href="classOgre_1_1Material.html">Material</a> *parent, const <a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;oth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#0e0fe6b1b297d9c8e81287d7c7a7b377"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#3942999affa2e3a81d122ac58f181f11">~Technique</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#7f64b7cc4743ee7cc5d6782ba687d841">isSupported</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicates if this technique is supported by the current graphics card.  <a href="#7f64b7cc4743ee7cc5d6782ba687d841"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#bec5e34e76944eb89ac0c6d370e3b1d5">_compile</a> (bool autoManageTextureUnits)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal compilation method; see <a class="el" href="classOgre_1_1Material.html#1f51926064eaa39f9d85393b41bb8870" title="&#39;Compiles&#39; this Material.">Material::compile</a>.  <a href="#bec5e34e76944eb89ac0c6d370e3b1d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a99b43fb531b833bc7e7ce939af2d069">checkGPURules</a> (<a class="el" href="classOgre_1_1StringUtil.html#ad3e31a0bb6592035b9e646a2bd9f0dc">StringUtil::StrStreamType</a> &amp;errors)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for checking GPU vendor / device rules.  <a href="#a99b43fb531b833bc7e7ce939af2d069"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#55699308ac7d558e4715356270204078">checkHardwareSupport</a> (bool autoManageTextureUnits, <a class="el" href="classOgre_1_1StringUtil.html#ad3e31a0bb6592035b9e646a2bd9f0dc">StringUtil::StrStreamType</a> &amp;compileErrors)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for checking hardware support.  <a href="#55699308ac7d558e4715356270204078"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#8143f16e1759f3b5731389d59a66f309">_compileIlluminationPasses</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for splitting the passes into illumination passes.  <a href="#8143f16e1759f3b5731389d59a66f309"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#51466b61bfe2dbcdb1afbf21b1dd3253">createPass</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> for this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#51466b61bfe2dbcdb1afbf21b1dd3253"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#3ce84da25bb6b5762af714adaf70874a">getPass</a> (unsigned short index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the given index.  <a href="#3ce84da25bb6b5762af714adaf70874a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Pass.html">Pass</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#70cead1f1ccc258c493306fb4570b522">getPass</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> matching name.  <a href="#70cead1f1ccc258c493306fb4570b522"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#7c787f22ac8d5efceebb65ae35ac6ef4">getNumPasses</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of passes.  <a href="#7c787f22ac8d5efceebb65ae35ac6ef4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#f6cff3e7cbf0b677433ca0a0da04c6aa">removePass</a> (unsigned short index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the given index.  <a href="#f6cff3e7cbf0b677433ca0a0da04c6aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#1eaae1583cf2e6e310ae911d34da00be">removeAllPasses</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all Passes from this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#1eaae1583cf2e6e310ae911d34da00be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#6fe998209ba33ea38fdcef68743d678c">movePass</a> (const unsigned short sourceIndex, const unsigned short destinationIndex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move a pass from source index to destination index.  <a href="#6fe998209ba33ea38fdcef68743d678c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classOgre_1_1VectorIterator.html">PassIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#84f0ff4e856f6965c7ae8dcab67e6cf2">getPassIterator</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets an iterator over the passes in this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#84f0ff4e856f6965c7ae8dcab67e6cf2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <br>
<a class="el" href="classOgre_1_1VectorIterator.html">IlluminationPassIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a864634545c3b7d57888cb8118d4af0a">getIlluminationPassIterator</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets an iterator over the illumination-stage categorised passes.  <a href="#a864634545c3b7d57888cb8118d4af0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Material.html">Material</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#603fb40984083fbdfa1bf570cc602563">getParent</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the parent <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  <a href="#603fb40984083fbdfa1bf570cc602563"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#c251efbed20452a6efb1361ea5d27496">operator=</a> (const <a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overloaded operator to copy on <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> to another.  <a href="#c251efbed20452a6efb1361ea5d27496"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ad5c43b5aa506b6304204f3874a251df">getResourceGroup</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the resource group of the ultimate parent <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  <a href="#ad5c43b5aa506b6304204f3874a251df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#d22ecac74653f9d1a4c955cf865f41d4">isTransparent</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> involves transparency.  <a href="#d22ecac74653f9d1a4c955cf865f41d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#7411b79f49c7136a55bd17eef1cc53ce">isTransparentSortingEnabled</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting enabled.  <a href="#7411b79f49c7136a55bd17eef1cc53ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#5833abf80056c4a18b6eafb137b590bb">_prepare</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal prepare method, derived from call to <a class="el" href="classOgre_1_1Resource.html#33a4b8cf8c372e1fc104d9387dda67e1" title="Prepares the resource for load, if it is not already.">Material::prepare</a>.  <a href="#5833abf80056c4a18b6eafb137b590bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#d78f99fe8c81b1dffaf2d9bfc3cfabb4">_unprepare</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal unprepare method, derived from call to Material::unprepare.  <a href="#d78f99fe8c81b1dffaf2d9bfc3cfabb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#92b98b4f291fa76b02d2adeb822998af">_load</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal load method, derived from call to <a class="el" href="classOgre_1_1Resource.html#699d1c851f494a8d5d23d23b695ceb47" title="Loads the resource, if it is not already.">Material::load</a>.  <a href="#92b98b4f291fa76b02d2adeb822998af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#73c19a7dd382f37226f307c3afc98794">_unload</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal unload method, derived from call to <a class="el" href="classOgre_1_1Resource.html#a31bef1bfaa87731622e56f11b548e27" title="Unloads the resource; this is not permanent, the resource can be reloaded later if...">Material::unload</a>.  <a href="#73c19a7dd382f37226f307c3afc98794"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ac374abdbf430a519dafb578f36239ff">isLoaded</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a5ad18f720bba21676f3424ed7b2382d">_notifyNeedsRecompile</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells the technique that it needs recompilation.  <a href="#a5ad18f720bba21676f3424ed7b2382d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#4186641fe103b4ffcee48c708d1e8f42">getShadowCasterMaterial</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return this material specific shadow casting specific material  <a href="#4186641fe103b4ffcee48c708d1e8f42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#c0e017f3810451861191fedfe1d51a30">setShadowCasterMaterial</a> (<a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a> val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set this material specific shadow casting specific material  <a href="#c0e017f3810451861191fedfe1d51a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#7913e8419619f0b074e67a638d54eb0f">setShadowCasterMaterial</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set this material specific shadow casting specific material  <a href="#7913e8419619f0b074e67a638d54eb0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#e40e12c1d7a1a3194bdf5ad68ba58fd0">getShadowReceiverMaterial</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return this material specific shadow receiving specific material  <a href="#e40e12c1d7a1a3194bdf5ad68ba58fd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#14cb59e4b8d1073f5379378ccf43f103">setShadowReceiverMaterial</a> (<a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a> val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set this material specific shadow receiving specific material  <a href="#14cb59e4b8d1073f5379378ccf43f103"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#03a7f4c6fa69c36b2b92a79917c34ace">setShadowReceiverMaterial</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set this material specific shadow receiving specific material  <a href="#03a7f4c6fa69c36b2b92a79917c34ace"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#1b7d1d264b34c50b7606c646415a50e8">setPointSize</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> ps)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the point size properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#1b7d1d264b34c50b7606c646415a50e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#28bab7548009bc18723bc0dc20a44f6a">setAmbient</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the ambient colour reflectance properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#28bab7548009bc18723bc0dc20a44f6a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#c5d459624ede01672c78846825cc0f96">setAmbient</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;ambient)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the ambient colour reflectance properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#c5d459624ede01672c78846825cc0f96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#177ced7bb28cba1562a6d036a1b692f9">setDiffuse</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the diffuse colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#177ced7bb28cba1562a6d036a1b692f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#f5e13d58c70bbeeb1708e1479185a959">setDiffuse</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;diffuse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the diffuse colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#f5e13d58c70bbeeb1708e1479185a959"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#7f58112618978a38cb9396936a54586a">setSpecular</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> alpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the specular colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#7f58112618978a38cb9396936a54586a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#0add9d092f47eb2b654d936a66902d00">setSpecular</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;specular)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the specular colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#0add9d092f47eb2b654d936a66902d00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ed27a55db91366ee2f95a608f946bc86">setShininess</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the shininess properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#ed27a55db91366ee2f95a608f946bc86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a987bf7df6c05a27a25ee334527498a0">setSelfIllumination</a> (<a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> red, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> green, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> blue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the amount of self-illumination of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#a987bf7df6c05a27a25ee334527498a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#9e5d7120bf501c5796bb461ec16ca22d">setSelfIllumination</a> (const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;selfIllum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the amount of self-illumination of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#9e5d7120bf501c5796bb461ec16ca22d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#8ccefe2b6bb5b6e66e2dcb081f92847f">setDepthCheckEnabled</a> (bool enabled)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> renders with depth-buffer checking on or not.  <a href="#8ccefe2b6bb5b6e66e2dcb081f92847f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#17ab42d4b777c0782a2d0170ae5a0970">setDepthWriteEnabled</a> (bool enabled)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> renders with depth-buffer writing on or not.  <a href="#17ab42d4b777c0782a2d0170ae5a0970"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#1f8f52bd7bc067a8f6dac99757063a06">setDepthFunction</a> (<a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a> func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the function used to compare depth values when depth checking is on.  <a href="#1f8f52bd7bc067a8f6dac99757063a06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#155d2bb172e767eab0880667b8669057">setColourWriteEnabled</a> (bool enabled)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not colour buffer writing is enabled for each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>.  <a href="#155d2bb172e767eab0880667b8669057"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#e3ab7639e71d6118834a9164a7c1c8f9">setCullingMode</a> (<a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a> mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the culling mode for each pass based on the 'vertex winding'.  <a href="#e3ab7639e71d6118834a9164a7c1c8f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#9d9340f9b31f6189e28d62ab00937ab0">setManualCullingMode</a> (<a class="el" href="namespaceOgre.html#07ec94cf178172a6778223e6f70f23fc">ManualCullingMode</a> mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the manual culling mode, performed by CPU rather than hardware.  <a href="#9d9340f9b31f6189e28d62ab00937ab0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#b6f31b910ad3b0a22219210290622482">setLightingEnabled</a> (bool enabled)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether or not dynamic lighting is enabled for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>.  <a href="#b6f31b910ad3b0a22219210290622482"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#4c3bb63365c701842d4539e32cc1480e">setShadingMode</a> (<a class="el" href="namespaceOgre.html#7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a> mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the type of light shading required.  <a href="#4c3bb63365c701842d4539e32cc1480e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#42c07e62db4e2cbeb75f8253b30e5c3b">setFog</a> (bool overrideScene, <a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a> mode=FOG_NONE, const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;colour=<a class="el" href="classOgre_1_1ColourValue.html#8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a>, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> expDensity=0.001, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearStart=0.0, <a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearEnd=1.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the fogging mode applied to each pass.  <a href="#42c07e62db4e2cbeb75f8253b30e5c3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#58b4e86384ca3e7a9f03c3fb2a5b3f0d">setDepthBias</a> (float constantBias, float slopeScaleBias)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the depth bias to be used for each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>.  <a href="#58b4e86384ca3e7a9f03c3fb2a5b3f0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#67d7464ef321b859c33c3c1e9334c5f2">setTextureFiltering</a> (<a class="el" href="namespaceOgre.html#21a0186392e9c9ce16d29c5568a773c5">TextureFilterOptions</a> filterType)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set texture filtering for every texture unit in every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>.  <a href="#67d7464ef321b859c33c3c1e9334c5f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#60e62cb6b00f8ae9e9da077d0ecc08ec">setTextureAnisotropy</a> (unsigned int maxAniso)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the anisotropy level to be used for all textures.  <a href="#60e62cb6b00f8ae9e9da077d0ecc08ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#8d44a97049862fc9c5eb64caf5cbbc2f">setSceneBlending</a> (const <a class="el" href="namespaceOgre.html#c46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the kind of blending every pass has with the existing contents of the scene.  <a href="#8d44a97049862fc9c5eb64caf5cbbc2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#dd4cd758dc843921da3a331bcc1bee1d">setSeparateSceneBlending</a> (const <a class="el" href="namespaceOgre.html#c46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbt, const <a class="el" href="namespaceOgre.html#c46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbta)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the kind of blending every pass has with the existing contents of the scene, using individual factors both color and alpha channels.  <a href="#dd4cd758dc843921da3a331bcc1bee1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#50815d7c51c153e2a6ab1b581507d28f">setSceneBlending</a> (const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows very fine control of blending every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the existing contents of the scene.  <a href="#50815d7c51c153e2a6ab1b581507d28f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#5df9ffbf40cbce69799b3be95cf4b701">setSeparateSceneBlending</a> (const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor, const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactorAlpha, const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactorAlpha)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows very fine control of blending every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the existing contents of the scene, using individual factors both color and alpha channels.  <a href="#5df9ffbf40cbce69799b3be95cf4b701"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#b72db7823cc9a8e872aed1ca6ae2cff8">setLodIndex</a> (unsigned short index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns a level-of-detail (LOD) index to this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#b72db7823cc9a8e872aed1ca6ae2cff8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#f70e2e5fec4b833152ec435b4d105be7">getLodIndex</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the level-of-detail index assigned to this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="#f70e2e5fec4b833152ec435b4d105be7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#43b6c4e9e48c4e56f96633b916ee90a3">setSchemeName</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;schemeName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the 'scheme name' for this technique.  <a href="#43b6c4e9e48c4e56f96633b916ee90a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#2b3e4ec269e9f88a5a53a301ddb601a4">getSchemeName</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the scheme to which this technique is assigned.  <a href="#2b3e4ec269e9f88a5a53a301ddb601a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#bab9570d1a0eb73194afa59c8e20de19">_getSchemeIndex</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for getting the scheme index.  <a href="#bab9570d1a0eb73194afa59c8e20de19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#a49639c4945e7d904bfcefe2d7ff3dd6">isDepthWriteEnabled</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is depth writing going to occur on this technique?  <a href="#a49639c4945e7d904bfcefe2d7ff3dd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#483a1f2f5c7b197c2623850e4fdced1f">isDepthCheckEnabled</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is depth checking going to occur on this technique?  <a href="#483a1f2f5c7b197c2623850e4fdced1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#8a55bcf42608e33443dcfc03b9a47269">hasColourWriteDisabled</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exists colour writing disabled pass on this technique?  <a href="#8a55bcf42608e33443dcfc03b9a47269"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#365b0e6313b646d0ecc13c1c52a6d3ad">setName</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name of the technique.  <a href="#365b0e6313b646d0ecc13c1c52a6d3ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#f577087e6a66bd0a29a58d042b3a6d16">getName</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the name of the technique.  <a href="#f577087e6a66bd0a29a58d042b3a6d16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#d2358b1ad69456e1ad0b73dff5522c95">applyTextureAliases</a> (const <a class="el" href="namespaceOgre.html#5dafc9e68bde8099ec5ad6c94e4cf19b">AliasTextureNamePairList</a> &amp;aliasList, const bool apply=true) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies texture names to <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State with matching texture name aliases.  <a href="#d2358b1ad69456e1ad0b73dff5522c95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#fe3b09baa8cd8566f994ad4ee5d125d1">addGPUVendorRule</a> (<a class="el" href="namespaceOgre.html#c4c251bcc05376f701348bfe0f4a53b4">GPUVendor</a> vendor, <a class="el" href="classOgre_1_1Technique.html#1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a> includeOrExclude)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a GPU vendor.  <a href="#fe3b09baa8cd8566f994ad4ee5d125d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#c6a82a8dedd6ecc9228e392aec08bd52">addGPUVendorRule</a> (const <a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a> &amp;rule)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a GPU vendor.  <a href="#c6a82a8dedd6ecc9228e392aec08bd52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#eaadeb93509d6fc3ca27686ca83e76be">removeGPUVendorRule</a> (<a class="el" href="namespaceOgre.html#c4c251bcc05376f701348bfe0f4a53b4">GPUVendor</a> vendor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a matching vendor rule.  <a href="#eaadeb93509d6fc3ca27686ca83e76be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1ConstVectorIterator.html">GPUVendorRuleIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#bc1e584d7310c4d80cf09d6fa1dc0585">getGPUVendorRuleIterator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the currently registered vendor rules.  <a href="#bc1e584d7310c4d80cf09d6fa1dc0585"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#b6be978dbdbe321f7e8e9803aa29c2d1">addGPUDeviceNameRule</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;devicePattern, <a class="el" href="classOgre_1_1Technique.html#1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a> includeOrExclude, bool caseSensitive=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g.  <a href="#b6be978dbdbe321f7e8e9803aa29c2d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#d0b1efd013753818ae29fd15a27c9744">addGPUDeviceNameRule</a> (const <a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a> &amp;rule)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g.  <a href="#d0b1efd013753818ae29fd15a27c9744"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#593e0e3c8e9d7a43155be8c6fdbfa8f7">removeGPUDeviceNameRule</a> (const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;devicePattern)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a matching device name rule.  <a href="#593e0e3c8e9d7a43155be8c6fdbfa8f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1ConstVectorIterator.html">GPUDeviceNameRuleIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#ddfd85590b126fb42c0cbffac10fff41">getGPUDeviceNameRuleIterator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the currently registered device name rules.  <a href="#ddfd85590b126fb42c0cbffac10fff41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#421b197ca3a38da17e2eb1531a645fa2">operator new</a> (size_t sz, const char *file, int line, const char *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">operator new, with debug line info  <a href="#421b197ca3a38da17e2eb1531a645fa2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#c4bdf968b7b9af8a5239a27da73d5711">operator new</a> (size_t sz)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#b78a921e54419be677839cdf15d1f0b8">operator new</a> (size_t sz, void *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">placement operator new  <a href="#b78a921e54419be677839cdf15d1f0b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#4be37baef81876985aa1071ad5acc6dd">operator new[]</a> (size_t sz, const char *file, int line, const char *func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">array operator new, with debug line info  <a href="#4be37baef81876985aa1071ad5acc6dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#fa2943846ba6a2b5824a12857139cf5e">operator new[]</a> (size_t sz)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#8357fe4fb4849772b94baa4bf47c7ded">operator delete</a> (void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#1c727e879a260c37b00ce5505fe8e144">operator delete</a> (void *ptr, void *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#cb46d4b0a597156d9ba5abc39d127792">operator delete</a> (void *ptr, const char *, int, const char *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#93e6a86dde5483c053ca0f2a85bbfd6c">operator delete[]</a> (void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1AllocatedObject.html#595ea4c05da8aa987d3800e65d23355d">operator delete[]</a> (void *ptr, const char *, int, const char *)</td></tr>

<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#8dee9e7ef067309148721ed733264d23">IlluminationPassesState</a> { <a class="el" href="classOgre_1_1Technique.html#8dee9e7ef067309148721ed733264d2375b214ee6385d48d7ac8ffe63956ef9d">IPS_COMPILE_DISABLED</a> =  -1, 
<a class="el" href="classOgre_1_1Technique.html#8dee9e7ef067309148721ed733264d236d7b35400e16649614a7b7d2ff935c93">IPS_NOT_COMPILED</a> =  0, 
<a class="el" href="classOgre_1_1Technique.html#8dee9e7ef067309148721ed733264d23bbba3e91e244942ff28459e90885ede7">IPS_COMPILED</a> =  1
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector<br>
&lt; <a class="el" href="classOgre_1_1Pass.html">Pass</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#b6823bce807c243c04e544ee99eea1d1">Passes</a></td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#2aab03fdccbf1973eb19ceecd264af30">clearIlluminationPasses</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for clearing illumination pass list.  <a href="#2aab03fdccbf1973eb19ceecd264af30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#98175339d8f896cd76055316b03a6937">checkManuallyOrganisedIlluminationPasses</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method - check for manually assigned illumination passes.  <a href="#98175339d8f896cd76055316b03a6937"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html#b6823bce807c243c04e544ee99eea1d1">Passes</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#45f4c97bd9168c67c4e7d5e68b2d0deb">mPasses</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of primary passes.  <a href="#45f4c97bd9168c67c4e7d5e68b2d0deb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#ff4cf78f2520e56a8c45721e2dc419c9">IlluminationPassList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#6221e827be4159d329ae7909a542b10b">mIlluminationPasses</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List of derived passes, categorised into IlluminationStage (ordered).  <a href="#6221e827be4159d329ae7909a542b10b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Material.html">Material</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#19396048e38ac2ee8c49a1beeec22a1a">mParent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#b0140f0bcb0875742de251050440d546">mIsSupported</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html#8dee9e7ef067309148721ed733264d23">IlluminationPassesState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#20375ceabd360a6b536a626da5033158">mIlluminationPassesCompilationPhase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#640ffe897c7889af3e6c6c9d322afcf7">mLodIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LOD level.  <a href="#640ffe897c7889af3e6c6c9d322afcf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#0660deaa1aec81d2b440ab175d63514a">mSchemeIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheme index, derived from scheme name but the names are held on <a class="el" href="classOgre_1_1MaterialManager.html" title="Class for managing Material settings for Ogre.">MaterialManager</a>, for speed an index is used here.  <a href="#0660deaa1aec81d2b440ab175d63514a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#386fbbee39283e296f9fb8bb3f4383f6">mName</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1MaterialPtr.html">MaterialPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#619d28fcc7d7763a6858f2e1a9499454">mShadowCasterMaterial</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When casting shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow casting material, or nor using fixed function casting, mShadowCasterMaterial let you customize per material shadow caster behavior.  <a href="#619d28fcc7d7763a6858f2e1a9499454"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#7abd113d2ad69679463a9928b546d2ac">mShadowCasterMaterialName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When casting shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow casting material, or nor using fixed function casting, mShadowCasterMaterial let you customize per material shadow caster behavior.There only material name is stored so that it can be loaded once all file parsed in a resource group.  <a href="#7abd113d2ad69679463a9928b546d2ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1MaterialPtr.html">MaterialPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#4d1b3ffc258b9a2430326d0bb903dbb1">mShadowReceiverMaterial</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When receiving shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow receiving material, or nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material shadow caster behavior.  <a href="#4d1b3ffc258b9a2430326d0bb903dbb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#6c4cb6c2977637223069c538986aa59e">mShadowReceiverMaterialName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When receiving shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow receiving material, or nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material shadow caster behavior.  <a href="#6c4cb6c2977637223069c538986aa59e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html#02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#874f049c7a6b21f3b91e12ca5860330e">mGPUVendorRules</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Technique.html#19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1Technique.html#75739b100b635fbfd9760265239c34f3">mGPUDeviceNameRules</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule controlling whether technique is deemed supported based on GPU device name.  <a href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rule controlling whether technique is deemed supported based on GPU vendor.  <a href="structOgre_1_1Technique_1_1GPUVendorRule.html#_details">More...</a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class representing an approach to rendering this particular <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="namespaceOgre.html">Ogre</a> will attempt to use the best technique supported by the active hardware, unless you specifically request a lower detail technique (say for distant rendering). </dd></dl>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00047">47</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="b6823bce807c243c04e544ee99eea1d1"></a><!-- doxytag: member="Ogre::Technique::Passes" ref="b6823bce807c243c04e544ee99eea1d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classOgre_1_1Pass.html">Pass</a>*&gt; <a class="el" href="classOgre_1_1Technique.html#b6823bce807c243c04e544ee99eea1d1">Ogre::Technique::Passes</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00058">58</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="02400e8fcd433054c6559331858a782e"></a><!-- doxytag: member="Ogre::Technique::GPUVendorRuleList" ref="02400e8fcd433054c6559331858a782e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a>&gt; <a class="el" href="classOgre_1_1Technique.html#02400e8fcd433054c6559331858a782e">Ogre::Technique::GPUVendorRuleList</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00133">133</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="19e4233dcb87fbb8d592133ca7f10626"></a><!-- doxytag: member="Ogre::Technique::GPUDeviceNameRuleList" ref="19e4233dcb87fbb8d592133ca7f10626" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a>&gt; <a class="el" href="classOgre_1_1Technique.html#19e4233dcb87fbb8d592133ca7f10626">Ogre::Technique::GPUDeviceNameRuleList</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00134">134</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="3b4640d3383f331657fd9ee05cb835c2"></a><!-- doxytag: member="Ogre::Technique::PassIterator" ref="3b4640d3383f331657fd9ee05cb835c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1VectorIterator.html">VectorIterator</a>&lt;<a class="el" href="classOgre_1_1Technique.html#b6823bce807c243c04e544ee99eea1d1">Passes</a>&gt; <a class="el" href="classOgre_1_1VectorIterator.html">Ogre::Technique::PassIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00189">189</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="77a239a5901d2c67add2e7cea0bf3468"></a><!-- doxytag: member="Ogre::Technique::IlluminationPassIterator" ref="77a239a5901d2c67add2e7cea0bf3468" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1VectorIterator.html">VectorIterator</a>&lt;<a class="el" href="namespaceOgre.html#ff4cf78f2520e56a8c45721e2dc419c9">IlluminationPassList</a>&gt; <a class="el" href="classOgre_1_1VectorIterator.html">Ogre::Technique::IlluminationPassIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00192">192</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="2497a0043902e9d2af0757d769da655c"></a><!-- doxytag: member="Ogre::Technique::GPUVendorRuleIterator" ref="2497a0043902e9d2af0757d769da655c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstVectorIterator</a>&lt;<a class="el" href="classOgre_1_1Technique.html#02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a>&gt; <a class="el" href="classOgre_1_1ConstVectorIterator.html">Ogre::Technique::GPUVendorRuleIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00635">635</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="63da4eb10f7272486a9806374b09bab6"></a><!-- doxytag: member="Ogre::Technique::GPUDeviceNameRuleIterator" ref="63da4eb10f7272486a9806374b09bab6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOgre_1_1ConstVectorIterator.html">ConstVectorIterator</a>&lt;<a class="el" href="classOgre_1_1Technique.html#19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a>&gt; <a class="el" href="classOgre_1_1ConstVectorIterator.html">Ogre::Technique::GPUDeviceNameRuleIterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00676">676</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="8dee9e7ef067309148721ed733264d23"></a><!-- doxytag: member="Ogre::Technique::IlluminationPassesState" ref="8dee9e7ef067309148721ed733264d23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOgre_1_1Technique.html#8dee9e7ef067309148721ed733264d23">Ogre::Technique::IlluminationPassesState</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="8dee9e7ef067309148721ed733264d2375b214ee6385d48d7ac8ffe63956ef9d"></a><!-- doxytag: member="IPS_COMPILE_DISABLED" ref="8dee9e7ef067309148721ed733264d2375b214ee6385d48d7ac8ffe63956ef9d" args="" -->IPS_COMPILE_DISABLED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="8dee9e7ef067309148721ed733264d236d7b35400e16649614a7b7d2ff935c93"></a><!-- doxytag: member="IPS_NOT_COMPILED" ref="8dee9e7ef067309148721ed733264d236d7b35400e16649614a7b7d2ff935c93" args="" -->IPS_NOT_COMPILED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="8dee9e7ef067309148721ed733264d23bbba3e91e244942ff28459e90885ede7"></a><!-- doxytag: member="IPS_COMPILED" ref="8dee9e7ef067309148721ed733264d23bbba3e91e244942ff28459e90885ede7" args="" -->IPS_COMPILED</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00051">51</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1ade219e17b5e8d73d079d11f64a2a2d"></a><!-- doxytag: member="Ogre::Technique::IncludeOrExclude" ref="1ade219e17b5e8d73d079d11f64a2a2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classOgre_1_1Technique.html#1ade219e17b5e8d73d079d11f64a2a2d">Ogre::Technique::IncludeOrExclude</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Directive used to manually control technique support based on the inclusion or exclusion of some factor. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="1ade219e17b5e8d73d079d11f64a2a2dbd4cc2de655eff5194cda7ea50d00ee3"></a><!-- doxytag: member="INCLUDE" ref="1ade219e17b5e8d73d079d11f64a2a2dbd4cc2de655eff5194cda7ea50d00ee3" args="" -->INCLUDE</em>&nbsp;</td><td>
Inclusive - only support if present. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="1ade219e17b5e8d73d079d11f64a2a2d043f697946b7a6d01bb858768e6646a3"></a><!-- doxytag: member="EXCLUDE" ref="1ade219e17b5e8d73d079d11f64a2a2d043f697946b7a6d01bb858768e6646a3" args="" -->EXCLUDE</em>&nbsp;</td><td>
Exclusive - do not support if present. </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00105">105</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4bf5eef2cd88abdf3408234f2bb0899c"></a><!-- doxytag: member="Ogre::Technique::Technique" ref="4bf5eef2cd88abdf3408234f2bb0899c" args="(Material *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Technique::Technique           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Material.html">Material</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="0e0fe6b1b297d9c8e81287d7c7a7b377"></a><!-- doxytag: member="Ogre::Technique::Technique" ref="0e0fe6b1b297d9c8e81287d7c7a7b377" args="(Material *parent, const Technique &amp;oth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Technique::Technique           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Material.html">Material</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>oth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="3942999affa2e3a81d122ac58f181f11"></a><!-- doxytag: member="Ogre::Technique::~Technique" ref="3942999affa2e3a81d122ac58f181f11" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Technique::~Technique           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2aab03fdccbf1973eb19ceecd264af30"></a><!-- doxytag: member="Ogre::Technique::clearIlluminationPasses" ref="2aab03fdccbf1973eb19ceecd264af30" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::clearIlluminationPasses           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for clearing illumination pass list. 
<p>

</div>
</div><p>
<a class="anchor" name="98175339d8f896cd76055316b03a6937"></a><!-- doxytag: member="Ogre::Technique::checkManuallyOrganisedIlluminationPasses" ref="98175339d8f896cd76055316b03a6937" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::checkManuallyOrganisedIlluminationPasses           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method - check for manually assigned illumination passes. 
<p>

</div>
</div><p>
<a class="anchor" name="7f64b7cc4743ee7cc5d6782ba687d841"></a><!-- doxytag: member="Ogre::Technique::isSupported" ref="7f64b7cc4743ee7cc5d6782ba687d841" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isSupported           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates if this technique is supported by the current graphics card. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This will only be correct after the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has been compiled, which is usually done from <a class="el" href="classOgre_1_1Material.html#1f51926064eaa39f9d85393b41bb8870" title="&#39;Compiles&#39; this Material.">Material::compile</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bec5e34e76944eb89ac0c6d370e3b1d5"></a><!-- doxytag: member="Ogre::Technique::_compile" ref="bec5e34e76944eb89ac0c6d370e3b1d5" args="(bool autoManageTextureUnits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> Ogre::Technique::_compile           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoManageTextureUnits</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal compilation method; see <a class="el" href="classOgre_1_1Material.html#1f51926064eaa39f9d85393b41bb8870" title="&#39;Compiles&#39; this Material.">Material::compile</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> information explaining problems with the compile. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a99b43fb531b833bc7e7ce939af2d069"></a><!-- doxytag: member="Ogre::Technique::checkGPURules" ref="a99b43fb531b833bc7e7ce939af2d069" args="(StringUtil::StrStreamType &amp;errors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::checkGPURules           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1StringUtil.html#ad3e31a0bb6592035b9e646a2bd9f0dc">StringUtil::StrStreamType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>errors</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for checking GPU vendor / device rules. 
<p>

</div>
</div><p>
<a class="anchor" name="55699308ac7d558e4715356270204078"></a><!-- doxytag: member="Ogre::Technique::checkHardwareSupport" ref="55699308ac7d558e4715356270204078" args="(bool autoManageTextureUnits, StringUtil::StrStreamType &amp;compileErrors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::checkHardwareSupport           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autoManageTextureUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1StringUtil.html#ad3e31a0bb6592035b9e646a2bd9f0dc">StringUtil::StrStreamType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>compileErrors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for checking hardware support. 
<p>

</div>
</div><p>
<a class="anchor" name="8143f16e1759f3b5731389d59a66f309"></a><!-- doxytag: member="Ogre::Technique::_compileIlluminationPasses" ref="8143f16e1759f3b5731389d59a66f309" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_compileIlluminationPasses           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for splitting the passes into illumination passes. 
<p>

</div>
</div><p>
<a class="anchor" name="51466b61bfe2dbcdb1afbf21b1dd3253"></a><!-- doxytag: member="Ogre::Technique::createPass" ref="51466b61bfe2dbcdb1afbf21b1dd3253" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* Ogre::Technique::createPass           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> for this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>A <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> is a single rendering pass, i.e. a single draw of the given material. Note that if you create a pass without a fragment program, during compilation of the material the pass may be split into multiple passes if the graphics card cannot handle the number of texture units requested. For passes with fragment programs, however, the number of passes you create will never be altered, so you have to make sure that you create an alternative fallback <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> for if a card does not have enough facilities for what you're asking for. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ce84da25bb6b5762af714adaf70874a"></a><!-- doxytag: member="Ogre::Technique::getPass" ref="3ce84da25bb6b5762af714adaf70874a" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* Ogre::Technique::getPass           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the given index. 
<p>

</div>
</div><p>
<a class="anchor" name="70cead1f1ccc258c493306fb4570b522"></a><!-- doxytag: member="Ogre::Technique::getPass" ref="70cead1f1ccc258c493306fb4570b522" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Pass.html">Pass</a>* Ogre::Technique::getPass           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> matching name. 
<p>
Returns 0 if name match is not found. 
</div>
</div><p>
<a class="anchor" name="7c787f22ac8d5efceebb65ae35ac6ef4"></a><!-- doxytag: member="Ogre::Technique::getNumPasses" ref="7c787f22ac8d5efceebb65ae35ac6ef4" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Technique::getNumPasses           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the number of passes. 
<p>

</div>
</div><p>
<a class="anchor" name="f6cff3e7cbf0b677433ca0a0da04c6aa"></a><!-- doxytag: member="Ogre::Technique::removePass" ref="f6cff3e7cbf0b677433ca0a0da04c6aa" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removePass           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the given index. 
<p>

</div>
</div><p>
<a class="anchor" name="1eaae1583cf2e6e310ae911d34da00be"></a><!-- doxytag: member="Ogre::Technique::removeAllPasses" ref="1eaae1583cf2e6e310ae911d34da00be" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removeAllPasses           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all Passes from this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="6fe998209ba33ea38fdcef68743d678c"></a><!-- doxytag: member="Ogre::Technique::movePass" ref="6fe998209ba33ea38fdcef68743d678c" args="(const unsigned short sourceIndex, const unsigned short destinationIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::movePass           </td>
          <td>(</td>
          <td class="paramtype">const unsigned short&nbsp;</td>
          <td class="paramname"> <em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&nbsp;</td>
          <td class="paramname"> <em>destinationIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move a pass from source index to destination index. 
<p>
If successful then returns true. 
</div>
</div><p>
<a class="anchor" name="84f0ff4e856f6965c7ae8dcab67e6cf2"></a><!-- doxytag: member="Ogre::Technique::getPassIterator" ref="84f0ff4e856f6965c7ae8dcab67e6cf2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1VectorIterator.html">PassIterator</a> Ogre::Technique::getPassIterator           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets an iterator over the passes in this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="a864634545c3b7d57888cb8118d4af0a"></a><!-- doxytag: member="Ogre::Technique::getIlluminationPassIterator" ref="a864634545c3b7d57888cb8118d4af0a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOgre_1_1VectorIterator.html">IlluminationPassIterator</a> Ogre::Technique::getIlluminationPassIterator           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets an iterator over the illumination-stage categorised passes. 
<p>

</div>
</div><p>
<a class="anchor" name="603fb40984083fbdfa1bf570cc602563"></a><!-- doxytag: member="Ogre::Technique::getParent" ref="603fb40984083fbdfa1bf570cc602563" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Material.html">Material</a>* Ogre::Technique::getParent           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the parent <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>. 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00196">196</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c251efbed20452a6efb1361ea5d27496"></a><!-- doxytag: member="Ogre::Technique::operator=" ref="c251efbed20452a6efb1361ea5d27496" args="(const Technique &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html">Technique</a>&amp; Ogre::Technique::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1Technique.html">Technique</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Overloaded operator to copy on <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> to another. 
<p>

</div>
</div><p>
<a class="anchor" name="ad5c43b5aa506b6304204f3874a251df"></a><!-- doxytag: member="Ogre::Technique::getResourceGroup" ref="ad5c43b5aa506b6304204f3874a251df" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Technique::getResourceGroup           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the resource group of the ultimate parent <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="d22ecac74653f9d1a4c955cf865f41d4"></a><!-- doxytag: member="Ogre::Technique::isTransparent" ref="d22ecac74653f9d1a4c955cf865f41d4" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isTransparent           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> involves transparency. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This basically boils down to whether the first pass has a scene blending factor. Even if the other passes do not, the base colour, including parts of the original scene, may be used for blending, therefore we have to treat the whole <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> as transparent. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7411b79f49c7136a55bd17eef1cc53ce"></a><!-- doxytag: member="Ogre::Technique::isTransparentSortingEnabled" ref="7411b79f49c7136a55bd17eef1cc53ce" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isTransparentSortingEnabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting enabled. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>This basically boils down to whether the first pass has transparent sorting enabled or not </dd></dl>

</div>
</div><p>
<a class="anchor" name="5833abf80056c4a18b6eafb137b590bb"></a><!-- doxytag: member="Ogre::Technique::_prepare" ref="5833abf80056c4a18b6eafb137b590bb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_prepare           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal prepare method, derived from call to <a class="el" href="classOgre_1_1Resource.html#33a4b8cf8c372e1fc104d9387dda67e1" title="Prepares the resource for load, if it is not already.">Material::prepare</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="d78f99fe8c81b1dffaf2d9bfc3cfabb4"></a><!-- doxytag: member="Ogre::Technique::_unprepare" ref="d78f99fe8c81b1dffaf2d9bfc3cfabb4" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_unprepare           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal unprepare method, derived from call to Material::unprepare. 
<p>

</div>
</div><p>
<a class="anchor" name="92b98b4f291fa76b02d2adeb822998af"></a><!-- doxytag: member="Ogre::Technique::_load" ref="92b98b4f291fa76b02d2adeb822998af" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_load           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal load method, derived from call to <a class="el" href="classOgre_1_1Resource.html#699d1c851f494a8d5d23d23b695ceb47" title="Loads the resource, if it is not already.">Material::load</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="73c19a7dd382f37226f307c3afc98794"></a><!-- doxytag: member="Ogre::Technique::_unload" ref="73c19a7dd382f37226f307c3afc98794" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_unload           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal unload method, derived from call to <a class="el" href="classOgre_1_1Resource.html#a31bef1bfaa87731622e56f11b548e27" title="Unloads the resource; this is not permanent, the resource can be reloaded later if...">Material::unload</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="ac374abdbf430a519dafb578f36239ff"></a><!-- doxytag: member="Ogre::Technique::isLoaded" ref="ac374abdbf430a519dafb578f36239ff" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isLoaded           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a5ad18f720bba21676f3424ed7b2382d"></a><!-- doxytag: member="Ogre::Technique::_notifyNeedsRecompile" ref="a5ad18f720bba21676f3424ed7b2382d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_notifyNeedsRecompile           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tells the technique that it needs recompilation. 
<p>

</div>
</div><p>
<a class="anchor" name="4186641fe103b4ffcee48c708d1e8f42"></a><!-- doxytag: member="Ogre::Technique::getShadowCasterMaterial" ref="4186641fe103b4ffcee48c708d1e8f42" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a> Ogre::Technique::getShadowCasterMaterial           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return this material specific shadow casting specific material 
<p>

</div>
</div><p>
<a class="anchor" name="c0e017f3810451861191fedfe1d51a30"></a><!-- doxytag: member="Ogre::Technique::setShadowCasterMaterial" ref="c0e017f3810451861191fedfe1d51a30" args="(Ogre::MaterialPtr val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowCasterMaterial           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a>&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set this material specific shadow casting specific material 
<p>

</div>
</div><p>
<a class="anchor" name="7913e8419619f0b074e67a638d54eb0f"></a><!-- doxytag: member="Ogre::Technique::setShadowCasterMaterial" ref="7913e8419619f0b074e67a638d54eb0f" args="(const Ogre::String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowCasterMaterial           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set this material specific shadow casting specific material 
<p>

</div>
</div><p>
<a class="anchor" name="e40e12c1d7a1a3194bdf5ad68ba58fd0"></a><!-- doxytag: member="Ogre::Technique::getShadowReceiverMaterial" ref="e40e12c1d7a1a3194bdf5ad68ba58fd0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a> Ogre::Technique::getShadowReceiverMaterial           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return this material specific shadow receiving specific material 
<p>

</div>
</div><p>
<a class="anchor" name="14cb59e4b8d1073f5379378ccf43f103"></a><!-- doxytag: member="Ogre::Technique::setShadowReceiverMaterial" ref="14cb59e4b8d1073f5379378ccf43f103" args="(Ogre::MaterialPtr val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowReceiverMaterial           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a>&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set this material specific shadow receiving specific material 
<p>

</div>
</div><p>
<a class="anchor" name="03a7f4c6fa69c36b2b92a79917c34ace"></a><!-- doxytag: member="Ogre::Technique::setShadowReceiverMaterial" ref="03a7f4c6fa69c36b2b92a79917c34ace" args="(const Ogre::String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowReceiverMaterial           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set this material specific shadow receiving specific material 
<p>

</div>
</div><p>
<a class="anchor" name="1b7d1d264b34c50b7606c646415a50e8"></a><!-- doxytag: member="Ogre::Technique::setPointSize" ref="1b7d1d264b34c50b7606c646415a50e8" args="(Real ps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setPointSize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>ps</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the point size properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#2b0cfe1d55b1c03e59c4e3f546d2ec78" title="Sets the point size of this pass.">Pass::setPointSize</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="28bab7548009bc18723bc0dc20a44f6a"></a><!-- doxytag: member="Ogre::Technique::setAmbient" ref="28bab7548009bc18723bc0dc20a44f6a" args="(Real red, Real green, Real blue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setAmbient           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the ambient colour reflectance properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#606695927fbf85ee64c361abf66ac10e" title="Sets the ambient colour reflectance properties of this pass.">Pass::setAmbient</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c5d459624ede01672c78846825cc0f96"></a><!-- doxytag: member="Ogre::Technique::setAmbient" ref="c5d459624ede01672c78846825cc0f96" args="(const ColourValue &amp;ambient)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setAmbient           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ambient</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the ambient colour reflectance properties for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#606695927fbf85ee64c361abf66ac10e" title="Sets the ambient colour reflectance properties of this pass.">Pass::setAmbient</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="177ced7bb28cba1562a6d036a1b692f9"></a><!-- doxytag: member="Ogre::Technique::setDiffuse" ref="177ced7bb28cba1562a6d036a1b692f9" args="(Real red, Real green, Real blue, Real alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDiffuse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the diffuse colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#e371bb189752872dfa2e02694f6841f1" title="Sets the diffuse colour reflectance properties of this pass.">Pass::setDiffuse</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5e13d58c70bbeeb1708e1479185a959"></a><!-- doxytag: member="Ogre::Technique::setDiffuse" ref="f5e13d58c70bbeeb1708e1479185a959" args="(const ColourValue &amp;diffuse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDiffuse           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>diffuse</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the diffuse colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#e371bb189752872dfa2e02694f6841f1" title="Sets the diffuse colour reflectance properties of this pass.">Pass::setDiffuse</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7f58112618978a38cb9396936a54586a"></a><!-- doxytag: member="Ogre::Technique::setSpecular" ref="7f58112618978a38cb9396936a54586a" args="(Real red, Real green, Real blue, Real alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSpecular           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the specular colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#8c079dd718b5839e1be10ee077a620b7" title="Sets the specular colour reflectance properties of this pass.">Pass::setSpecular</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0add9d092f47eb2b654d936a66902d00"></a><!-- doxytag: member="Ogre::Technique::setSpecular" ref="0add9d092f47eb2b654d936a66902d00" args="(const ColourValue &amp;specular)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSpecular           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>specular</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the specular colour reflectance properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#8c079dd718b5839e1be10ee077a620b7" title="Sets the specular colour reflectance properties of this pass.">Pass::setSpecular</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed27a55db91366ee2f95a608f946bc86"></a><!-- doxytag: member="Ogre::Technique::setShininess" ref="ed27a55db91366ee2f95a608f946bc86" args="(Real val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShininess           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the shininess properties of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#8202cf155d20602fd9c0ec53273a442f" title="Sets the shininess of the pass, affecting the size of specular highlights.">Pass::setShininess</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a987bf7df6c05a27a25ee334527498a0"></a><!-- doxytag: member="Ogre::Technique::setSelfIllumination" ref="a987bf7df6c05a27a25ee334527498a0" args="(Real red, Real green, Real blue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSelfIllumination           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>blue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the amount of self-illumination of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#511812da930186cb3fe15e286bc2d244" title="Sets the amount of self-illumination an object has.">Pass::setSelfIllumination</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e5d7120bf501c5796bb461ec16ca22d"></a><!-- doxytag: member="Ogre::Technique::setSelfIllumination" ref="9e5d7120bf501c5796bb461ec16ca22d" args="(const ColourValue &amp;selfIllum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSelfIllumination           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>selfIllum</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the amount of self-illumination of every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> in every <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#511812da930186cb3fe15e286bc2d244" title="Sets the amount of self-illumination an object has.">Pass::setSelfIllumination</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ccefe2b6bb5b6e66e2dcb081f92847f"></a><!-- doxytag: member="Ogre::Technique::setDepthCheckEnabled" ref="8ccefe2b6bb5b6e66e2dcb081f92847f" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthCheckEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> renders with depth-buffer checking on or not. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#e454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not.">Pass::setDepthCheckEnabled</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="17ab42d4b777c0782a2d0170ae5a0970"></a><!-- doxytag: member="Ogre::Technique::setDepthWriteEnabled" ref="17ab42d4b777c0782a2d0170ae5a0970" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthWriteEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> renders with depth-buffer writing on or not. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#ad3e6c7c7b59e2c303c348b4850b1a3a" title="Sets whether or not this pass renders with depth-buffer writing on or not.">Pass::setDepthWriteEnabled</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1f8f52bd7bc067a8f6dac99757063a06"></a><!-- doxytag: member="Ogre::Technique::setDepthFunction" ref="1f8f52bd7bc067a8f6dac99757063a06" args="(CompareFunction func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthFunction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#0212b4eb264f207d84c1df9425208c7a">CompareFunction</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the function used to compare depth values when depth checking is on. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#ef6c591b069aa6f7c65afc1419d47de6" title="Sets the function used to compare depth values when depth checking is on.">Pass::setDepthFunction</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="155d2bb172e767eab0880667b8669057"></a><!-- doxytag: member="Ogre::Technique::setColourWriteEnabled" ref="155d2bb172e767eab0880667b8669057" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setColourWriteEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not colour buffer writing is enabled for each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#3bbe37daba7e3be4349177374d4e40ee" title="Sets whether or not colour buffer writing is enabled for this Pass.">Pass::setColourWriteEnabled</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e3ab7639e71d6118834a9164a7c1c8f9"></a><!-- doxytag: member="Ogre::Technique::setCullingMode" ref="e3ab7639e71d6118834a9164a7c1c8f9" args="(CullingMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setCullingMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#c173244ed7d950d0acd726e4f323ecdb">CullingMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the culling mode for each pass based on the 'vertex winding'. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#8942abf3ede0f3cb43584c85c4071734" title="Sets the culling mode for this pass based on the &#39;vertex winding&#39;.">Pass::setCullingMode</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9d9340f9b31f6189e28d62ab00937ab0"></a><!-- doxytag: member="Ogre::Technique::setManualCullingMode" ref="9d9340f9b31f6189e28d62ab00937ab0" args="(ManualCullingMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setManualCullingMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#07ec94cf178172a6778223e6f70f23fc">ManualCullingMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the manual culling mode, performed by CPU rather than hardware. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#3b528827b54f17b72bb204321640a6f7" title="Sets the manual culling mode, performed by CPU rather than hardware.">Pass::setManualCullingMode</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6f31b910ad3b0a22219210290622482"></a><!-- doxytag: member="Ogre::Technique::setLightingEnabled" ref="b6f31b910ad3b0a22219210290622482" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setLightingEnabled           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether or not dynamic lighting is enabled for every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Pass::setLightingEnabled</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4c3bb63365c701842d4539e32cc1480e"></a><!-- doxytag: member="Ogre::Technique::setShadingMode" ref="4c3bb63365c701842d4539e32cc1480e" args="(ShadeOptions mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadingMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#7afd4c7d428baaee13f3a0dbcae5f560">ShadeOptions</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the type of light shading required. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#de6c00297cd5d46bb365d981cd1764a6" title="Sets the type of light shading required.">Pass::setShadingMode</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="42c07e62db4e2cbeb75f8253b30e5c3b"></a><!-- doxytag: member="Ogre::Technique::setFog" ref="42c07e62db4e2cbeb75f8253b30e5c3b" args="(bool overrideScene, FogMode mode=FOG_NONE, const ColourValue &amp;colour=ColourValue::White, Real expDensity=0.001, Real linearStart=0.0, Real linearEnd=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setFog           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>overrideScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#83edeb2e5d33a3ca8f15834ba40020ba">FogMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FOG_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOgre_1_1ColourValue.html">ColourValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>colour</em> = <code><a class="el" href="classOgre_1_1ColourValue.html#8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>expDensity</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>linearStart</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#a3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&nbsp;</td>
          <td class="paramname"> <em>linearEnd</em> = <code>1.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the fogging mode applied to each pass. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#32b0cabffa642b0f3743ac5d82392a1d" title="Sets the fogging mode applied to this pass.">Pass::setFog</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="58b4e86384ca3e7a9f03c3fb2a5b3f0d"></a><!-- doxytag: member="Ogre::Technique::setDepthBias" ref="58b4e86384ca3e7a9f03c3fb2a5b3f0d" args="(float constantBias, float slopeScaleBias)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthBias           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>constantBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>slopeScaleBias</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the depth bias to be used for each <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#a35a3242a45176f8605bd8c866198b67" title="Sets the depth bias to be used for this material.">Pass::setDepthBias</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="67d7464ef321b859c33c3c1e9334c5f2"></a><!-- doxytag: member="Ogre::Technique::setTextureFiltering" ref="67d7464ef321b859c33c3c1e9334c5f2" args="(TextureFilterOptions filterType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setTextureFiltering           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#21a0186392e9c9ce16d29c5568a773c5">TextureFilterOptions</a>&nbsp;</td>
          <td class="paramname"> <em>filterType</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set texture filtering for every texture unit in every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> class For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> and <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> instances and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1TextureUnitState.html#30757c168b734902d03720e3f36c27d4" title="Set the texture filtering for this unit, using the simplified interface.">TextureUnitState::setTextureFiltering</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="60e62cb6b00f8ae9e9da077d0ecc08ec"></a><!-- doxytag: member="Ogre::Technique::setTextureAnisotropy" ref="60e62cb6b00f8ae9e9da077d0ecc08ec" args="(unsigned int maxAniso)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setTextureAnisotropy           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>maxAniso</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the anisotropy level to be used for all textures. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property has been moved to the <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> class, which is accessible via the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> and <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>. For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>, <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> and <a class="el" href="classOgre_1_1TextureUnitState.html" title="Class representing the state of a single texture unit during a Pass of a Technique...">TextureUnitState</a> instances and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1TextureUnitState.html#bb2bc03bc72f2098e37c4240f637c5e5" title="Sets the anisotropy level to be used for this texture level.">TextureUnitState::setTextureAnisotropy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8d44a97049862fc9c5eb64caf5cbbc2f"></a><!-- doxytag: member="Ogre::Technique::setSceneBlending" ref="8d44a97049862fc9c5eb64caf5cbbc2f" args="(const SceneBlendType sbt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSceneBlending           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#c46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&nbsp;</td>
          <td class="paramname"> <em>sbt</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the kind of blending every pass has with the existing contents of the scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#e21d6f29c89eeff54ab6de5562818c02" title="Sets the kind of blending this pass has with the existing contents of the scene.">Pass::setSceneBlending</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd4cd758dc843921da3a331bcc1bee1d"></a><!-- doxytag: member="Ogre::Technique::setSeparateSceneBlending" ref="dd4cd758dc843921da3a331bcc1bee1d" args="(const SceneBlendType sbt, const SceneBlendType sbta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSeparateSceneBlending           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#c46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&nbsp;</td>
          <td class="paramname"> <em>sbt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#c46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&nbsp;</td>
          <td class="paramname"> <em>sbta</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the kind of blending every pass has with the existing contents of the scene, using individual factors both color and alpha channels. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#efbd80d762d78838df626482df1ac81b" title="Sets the kind of blending this pass has with the existing contents of the scene,...">Pass::setSeparateSceneBlending</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="50815d7c51c153e2a6ab1b581507d28f"></a><!-- doxytag: member="Ogre::Technique::setSceneBlending" ref="50815d7c51c153e2a6ab1b581507d28f" args="(const SceneBlendFactor sourceFactor, const SceneBlendFactor destFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSceneBlending           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>destFactor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows very fine control of blending every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the existing contents of the scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#e21d6f29c89eeff54ab6de5562818c02" title="Sets the kind of blending this pass has with the existing contents of the scene.">Pass::setSceneBlending</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5df9ffbf40cbce69799b3be95cf4b701"></a><!-- doxytag: member="Ogre::Technique::setSeparateSceneBlending" ref="5df9ffbf40cbce69799b3be95cf4b701" args="(const SceneBlendFactor sourceFactor, const SceneBlendFactor destFactor, const SceneBlendFactor sourceFactorAlpha, const SceneBlendFactor destFactorAlpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSeparateSceneBlending           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>destFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>sourceFactorAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&nbsp;</td>
          <td class="paramname"> <em>destFactorAlpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows very fine control of blending every <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with the existing contents of the scene, using individual factors both color and alpha channels. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This property actually exists on the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> within this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> instance and set the property there. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Pass.html#efbd80d762d78838df626482df1ac81b" title="Sets the kind of blending this pass has with the existing contents of the scene,...">Pass::setSeparateSceneBlending</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b72db7823cc9a8e872aed1ca6ae2cff8"></a><!-- doxytag: member="Ogre::Technique::setLodIndex" ref="b72db7823cc9a8e872aed1ca6ae2cff8" args="(unsigned short index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setLodIndex           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns a level-of-detail (LOD) index to this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>As noted previously, as well as providing fallback support for various graphics cards, multiple <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> objects can also be used to implement material LOD, where the detail of the material diminishes with distance to save rendering power. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>By default, all Techniques have a LOD index of 0, which means they are the highest level of detail. Increasing LOD indexes are lower levels of detail. You can assign more than one <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> to the same LOD index, meaning that the best <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> that is supported at that LOD index is used. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>You should not leave gaps in the LOD sequence; <a class="el" href="namespaceOgre.html">Ogre</a> will allow you to do this and will continue to function as if the LODs were sequential, but it will confuse matters. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f70e2e5fec4b833152ec435b4d105be7"></a><!-- doxytag: member="Ogre::Technique::getLodIndex" ref="f70e2e5fec4b833152ec435b4d105be7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Technique::getLodIndex           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the level-of-detail index assigned to this <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00541">541</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="43b6c4e9e48c4e56f96633b916ee90a3"></a><!-- doxytag: member="Ogre::Technique::setSchemeName" ref="43b6c4e9e48c4e56f96633b916ee90a3" args="(const String &amp;schemeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSchemeName           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>schemeName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the 'scheme name' for this technique. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd><a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> schemes are used to control top-level switching from one set of techniques to another. For example, you might use this to define 'high', 'medium' and 'low' complexity levels on materials to allow a user to pick a performance / quality ratio. Another possibility is that you have a fully HDR-enabled pipeline for top machines, rendering all objects using unclamped shaders, and a simpler pipeline for others; this can be implemented using schemes. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Every technique belongs to a scheme - if you don't specify one, the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> belongs to the scheme called 'Default', which is also the scheme used to render by default. The active scheme is set one of two ways - either by calling <a class="el" href="classOgre_1_1Viewport.html#8e8577fd81c45b05de880106f364a281" title="Set the material scheme which the viewport should use.">Viewport::setMaterialScheme</a>, or by manually calling <a class="el" href="classOgre_1_1MaterialManager.html#95decc3900f547bb68b74ba28d3013e0" title="Sets the name of the active material scheme.">MaterialManager::setActiveScheme</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b3e4ec269e9f88a5a53a301ddb601a4"></a><!-- doxytag: member="Ogre::Technique::getSchemeName" ref="2b3e4ec269e9f88a5a53a301ddb601a4" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Technique::getSchemeName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the scheme to which this technique is assigned. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Technique.html#43b6c4e9e48c4e56f96633b916ee90a3" title="Set the &#39;scheme name&#39; for this technique.">Technique::setSchemeName</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bab9570d1a0eb73194afa59c8e20de19"></a><!-- doxytag: member="Ogre::Technique::_getSchemeIndex" ref="bab9570d1a0eb73194afa59c8e20de19" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Technique::_getSchemeIndex           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method for getting the scheme index. 
<p>

</div>
</div><p>
<a class="anchor" name="a49639c4945e7d904bfcefe2d7ff3dd6"></a><!-- doxytag: member="Ogre::Technique::isDepthWriteEnabled" ref="a49639c4945e7d904bfcefe2d7ff3dd6" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isDepthWriteEnabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is depth writing going to occur on this technique? 
<p>

</div>
</div><p>
<a class="anchor" name="483a1f2f5c7b197c2623850e4fdced1f"></a><!-- doxytag: member="Ogre::Technique::isDepthCheckEnabled" ref="483a1f2f5c7b197c2623850e4fdced1f" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isDepthCheckEnabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is depth checking going to occur on this technique? 
<p>

</div>
</div><p>
<a class="anchor" name="8a55bcf42608e33443dcfc03b9a47269"></a><!-- doxytag: member="Ogre::Technique::hasColourWriteDisabled" ref="8a55bcf42608e33443dcfc03b9a47269" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::hasColourWriteDisabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exists colour writing disabled pass on this technique? 
<p>

</div>
</div><p>
<a class="anchor" name="365b0e6313b646d0ecc13c1c52a6d3ad"></a><!-- doxytag: member="Ogre::Technique::setName" ref="365b0e6313b646d0ecc13c1c52a6d3ad" args="(const String &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setName           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the name of the technique. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The use of technique name is optional. Its useful in material scripts where a material could inherit from another material and only want to modify a particular technique. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f577087e6a66bd0a29a58d042b3a6d16"></a><!-- doxytag: member="Ogre::Technique::getName" ref="f577087e6a66bd0a29a58d042b3a6d16" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::Technique::getName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the name of the technique. 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00585">585</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="d2358b1ad69456e1ad0b73dff5522c95"></a><!-- doxytag: member="Ogre::Technique::applyTextureAliases" ref="d2358b1ad69456e1ad0b73dff5522c95" args="(const AliasTextureNamePairList &amp;aliasList, const bool apply=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::applyTextureAliases           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#5dafc9e68bde8099ec5ad6c94e4cf19b">AliasTextureNamePairList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aliasList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>apply</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies texture names to <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit State with matching texture name aliases. 
<p>
All passes, and <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> Unit States within the technique are checked. If matching texture aliases are found then true is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aliasList</em>&nbsp;</td><td>is a map container of texture alias, texture name pairs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>apply</em>&nbsp;</td><td>set true to apply the texture aliases else just test to see if texture alias matches are found. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if matching texture aliases were found in the <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe3b09baa8cd8566f994ad4ee5d125d1"></a><!-- doxytag: member="Ogre::Technique::addGPUVendorRule" ref="fe3b09baa8cd8566f994ad4ee5d125d1" args="(GPUVendor vendor, IncludeOrExclude includeOrExclude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUVendorRule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#c4c251bcc05376f701348bfe0f4a53b4">GPUVendor</a>&nbsp;</td>
          <td class="paramname"> <em>vendor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Technique.html#1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a>&nbsp;</td>
          <td class="paramname"> <em>includeOrExclude</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a rule which manually influences the support for this technique based on a GPU vendor. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU vendor. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same vendor will be removed before adding this one. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vendor</em>&nbsp;</td><td>The GPU vendor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>includeOrExclude</em>&nbsp;</td><td>Whether this is an inclusive or exclusive rule </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c6a82a8dedd6ecc9228e392aec08bd52"></a><!-- doxytag: member="Ogre::Technique::addGPUVendorRule" ref="c6a82a8dedd6ecc9228e392aec08bd52" args="(const GPUVendorRule &amp;rule)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUVendorRule           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">GPUVendorRule</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rule</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a rule which manually influences the support for this technique based on a GPU vendor. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU vendor. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same vendor will be removed before adding this one. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eaadeb93509d6fc3ca27686ca83e76be"></a><!-- doxytag: member="Ogre::Technique::removeGPUVendorRule" ref="eaadeb93509d6fc3ca27686ca83e76be" args="(GPUVendor vendor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removeGPUVendorRule           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOgre.html#c4c251bcc05376f701348bfe0f4a53b4">GPUVendor</a>&nbsp;</td>
          <td class="paramname"> <em>vendor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a matching vendor rule. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Technique.html#fe3b09baa8cd8566f994ad4ee5d125d1" title="Add a rule which manually influences the support for this technique based on a GPU...">addGPUVendorRule</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc1e584d7310c4d80cf09d6fa1dc0585"></a><!-- doxytag: member="Ogre::Technique::getGPUVendorRuleIterator" ref="bc1e584d7310c4d80cf09d6fa1dc0585" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ConstVectorIterator.html">GPUVendorRuleIterator</a> Ogre::Technique::getGPUVendorRuleIterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the currently registered vendor rules. 
<p>

</div>
</div><p>
<a class="anchor" name="b6be978dbdbe321f7e8e9803aa29c2d1"></a><!-- doxytag: member="Ogre::Technique::addGPUDeviceNameRule" ref="b6be978dbdbe321f7e8e9803aa29c2d1" args="(const String &amp;devicePattern, IncludeOrExclude includeOrExclude, bool caseSensitive=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUDeviceNameRule           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>devicePattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOgre_1_1Technique.html#1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a>&nbsp;</td>
          <td class="paramname"> <em>includeOrExclude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>caseSensitive</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. 
<p>
'*8800*'). <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU device name pattern. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. The pattern you supply can include wildcard characters ('*') if you only want to match part of the device name. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same device pattern will be removed before adding this one. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>devicePattern</em>&nbsp;</td><td>The GPU vendor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>includeOrExclude</em>&nbsp;</td><td>Whether this is an inclusive or exclusive rule </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>caseSensitive</em>&nbsp;</td><td>Whether the match is case sensitive or not </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d0b1efd013753818ae29fd15a27c9744"></a><!-- doxytag: member="Ogre::Technique::addGPUDeviceNameRule" ref="d0b1efd013753818ae29fd15a27c9744" args="(const GPUDeviceNameRule &amp;rule)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUDeviceNameRule           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">GPUDeviceNameRule</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rule</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. 
<p>
'*8800*'). <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU device name pattern. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. The pattern you supply can include wildcard characters ('*') if you only want to match part of the device name. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same device pattern will be removed before adding this one. </dd></dl>

</div>
</div><p>
<a class="anchor" name="593e0e3c8e9d7a43155be8c6fdbfa8f7"></a><!-- doxytag: member="Ogre::Technique::removeGPUDeviceNameRule" ref="593e0e3c8e9d7a43155be8c6fdbfa8f7" args="(const String &amp;devicePattern)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removeGPUDeviceNameRule           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>devicePattern</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a matching device name rule. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOgre_1_1Technique.html#b6be978dbdbe321f7e8e9803aa29c2d1" title="Add a rule which manually influences the support for this technique based on a pattern...">addGPUDeviceNameRule</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ddfd85590b126fb42c0cbffac10fff41"></a><!-- doxytag: member="Ogre::Technique::getGPUDeviceNameRuleIterator" ref="ddfd85590b126fb42c0cbffac10fff41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1ConstVectorIterator.html">GPUDeviceNameRuleIterator</a> Ogre::Technique::getGPUDeviceNameRuleIterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the currently registered device name rules. 
<p>

</div>
</div><p>
<a class="anchor" name="421b197ca3a38da17e2eb1531a645fa2"></a><!-- doxytag: member="Ogre::Technique::operator new" ref="421b197ca3a38da17e2eb1531a645fa2" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
operator new, with debug line info 
<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00062">62</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4bdf968b7b9af8a5239a27da73d5711"></a><!-- doxytag: member="Ogre::Technique::operator new" ref="c4bdf968b7b9af8a5239a27da73d5711" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00067">67</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b78a921e54419be677839cdf15d1f0b8"></a><!-- doxytag: member="Ogre::Technique::operator new" ref="b78a921e54419be677839cdf15d1f0b8" args="(size_t sz, void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
placement operator new 
<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00073">73</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4be37baef81876985aa1071ad5acc6dd"></a><!-- doxytag: member="Ogre::Technique::operator new[]" ref="4be37baef81876985aa1071ad5acc6dd" args="(size_t sz, const char *file, int line, const char *func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
array operator new, with debug line info 
<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00079">79</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="fa2943846ba6a2b5824a12857139cf5e"></a><!-- doxytag: member="Ogre::Technique::operator new[]" ref="fa2943846ba6a2b5824a12857139cf5e" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator new[]           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>sz</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00084">84</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="8357fe4fb4849772b94baa4bf47c7ded"></a><!-- doxytag: member="Ogre::Technique::operator delete" ref="8357fe4fb4849772b94baa4bf47c7ded" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00089">89</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c727e879a260c37b00ce5505fe8e144"></a><!-- doxytag: member="Ogre::Technique::operator delete" ref="1c727e879a260c37b00ce5505fe8e144" args="(void *ptr, void *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00095">95</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="cb46d4b0a597156d9ba5abc39d127792"></a><!-- doxytag: member="Ogre::Technique::operator delete" ref="cb46d4b0a597156d9ba5abc39d127792" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00101">101</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="93e6a86dde5483c053ca0f2a85bbfd6c"></a><!-- doxytag: member="Ogre::Technique::operator delete[]" ref="93e6a86dde5483c053ca0f2a85bbfd6c" args="(void *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[]           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00106">106</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="595ea4c05da8aa987d3800e65d23355d"></a><!-- doxytag: member="Ogre::Technique::operator delete[]" ref="595ea4c05da8aa987d3800e65d23355d" args="(void *ptr, const char *, int, const char *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alloc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject</a>&lt; Alloc &gt;::operator delete[]           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreMemoryAllocatedObject_8h-source.html#l00112">112</a> of file <a class="el" href="OgreMemoryAllocatedObject_8h-source.html">OgreMemoryAllocatedObject.h</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="45f4c97bd9168c67c4e7d5e68b2d0deb"></a><!-- doxytag: member="Ogre::Technique::mPasses" ref="45f4c97bd9168c67c4e7d5e68b2d0deb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html#b6823bce807c243c04e544ee99eea1d1">Passes</a> <a class="el" href="classOgre_1_1Technique.html#45f4c97bd9168c67c4e7d5e68b2d0deb">Ogre::Technique::mPasses</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of primary passes. 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00060">60</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6221e827be4159d329ae7909a542b10b"></a><!-- doxytag: member="Ogre::Technique::mIlluminationPasses" ref="6221e827be4159d329ae7909a542b10b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#ff4cf78f2520e56a8c45721e2dc419c9">IlluminationPassList</a> <a class="el" href="classOgre_1_1Technique.html#6221e827be4159d329ae7909a542b10b">Ogre::Technique::mIlluminationPasses</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
List of derived passes, categorised into IlluminationStage (ordered). 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00062">62</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="19396048e38ac2ee8c49a1beeec22a1a"></a><!-- doxytag: member="Ogre::Technique::mParent" ref="19396048e38ac2ee8c49a1beeec22a1a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Material.html">Material</a>* <a class="el" href="classOgre_1_1Technique.html#19396048e38ac2ee8c49a1beeec22a1a">Ogre::Technique::mParent</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00063">63</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="b0140f0bcb0875742de251050440d546"></a><!-- doxytag: member="Ogre::Technique::mIsSupported" ref="b0140f0bcb0875742de251050440d546" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOgre_1_1Technique.html#b0140f0bcb0875742de251050440d546">Ogre::Technique::mIsSupported</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00064">64</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="20375ceabd360a6b536a626da5033158"></a><!-- doxytag: member="Ogre::Technique::mIlluminationPassesCompilationPhase" ref="20375ceabd360a6b536a626da5033158" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html#8dee9e7ef067309148721ed733264d23">IlluminationPassesState</a> <a class="el" href="classOgre_1_1Technique.html#20375ceabd360a6b536a626da5033158">Ogre::Technique::mIlluminationPassesCompilationPhase</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00065">65</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="640ffe897c7889af3e6c6c9d322afcf7"></a><!-- doxytag: member="Ogre::Technique::mLodIndex" ref="640ffe897c7889af3e6c6c9d322afcf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short <a class="el" href="classOgre_1_1Technique.html#640ffe897c7889af3e6c6c9d322afcf7">Ogre::Technique::mLodIndex</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
LOD level. 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00067">67</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="0660deaa1aec81d2b440ab175d63514a"></a><!-- doxytag: member="Ogre::Technique::mSchemeIndex" ref="0660deaa1aec81d2b440ab175d63514a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short <a class="el" href="classOgre_1_1Technique.html#0660deaa1aec81d2b440ab175d63514a">Ogre::Technique::mSchemeIndex</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scheme index, derived from scheme name but the names are held on <a class="el" href="classOgre_1_1MaterialManager.html" title="Class for managing Material settings for Ogre.">MaterialManager</a>, for speed an index is used here. 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00071">71</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="386fbbee39283e296f9fb8bb3f4383f6"></a><!-- doxytag: member="Ogre::Technique::mName" ref="386fbbee39283e296f9fb8bb3f4383f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1Technique.html#386fbbee39283e296f9fb8bb3f4383f6">Ogre::Technique::mName</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00072">72</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="619d28fcc7d7763a6858f2e1a9499454"></a><!-- doxytag: member="Ogre::Technique::mShadowCasterMaterial" ref="619d28fcc7d7763a6858f2e1a9499454" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MaterialPtr.html">MaterialPtr</a> <a class="el" href="classOgre_1_1Technique.html#619d28fcc7d7763a6858f2e1a9499454">Ogre::Technique::mShadowCasterMaterial</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When casting shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow casting material, or nor using fixed function casting, mShadowCasterMaterial let you customize per material shadow caster behavior. 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00084">84</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="7abd113d2ad69679463a9928b546d2ac"></a><!-- doxytag: member="Ogre::Technique::mShadowCasterMaterialName" ref="7abd113d2ad69679463a9928b546d2ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1Technique.html#7abd113d2ad69679463a9928b546d2ac">Ogre::Technique::mShadowCasterMaterialName</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When casting shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow casting material, or nor using fixed function casting, mShadowCasterMaterial let you customize per material shadow caster behavior.There only material name is stored so that it can be loaded once all file parsed in a resource group. 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00089">89</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="4d1b3ffc258b9a2430326d0bb903dbb1"></a><!-- doxytag: member="Ogre::Technique::mShadowReceiverMaterial" ref="4d1b3ffc258b9a2430326d0bb903dbb1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1MaterialPtr.html">MaterialPtr</a> <a class="el" href="classOgre_1_1Technique.html#4d1b3ffc258b9a2430326d0bb903dbb1">Ogre::Technique::mShadowReceiverMaterial</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When receiving shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow receiving material, or nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material shadow caster behavior. 
<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00094">94</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="6c4cb6c2977637223069c538986aa59e"></a><!-- doxytag: member="Ogre::Technique::mShadowReceiverMaterialName" ref="6c4cb6c2977637223069c538986aa59e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOgre.html#f73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> <a class="el" href="classOgre_1_1Technique.html#6c4cb6c2977637223069c538986aa59e">Ogre::Technique::mShadowReceiverMaterialName</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When receiving shadow, if not using default <a class="el" href="namespaceOgre.html">Ogre</a> shadow receiving material, or nor using fixed function texture projection receiving, mShadowReceiverMaterial let you customize per material shadow caster behavior. 
<p>
There only material name is stored so that it can be loaded once all file parsed in a resource group. 
<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00099">99</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="874f049c7a6b21f3b91e12ca5860330e"></a><!-- doxytag: member="Ogre::Technique::mGPUVendorRules" ref="874f049c7a6b21f3b91e12ca5860330e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html#02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a> <a class="el" href="classOgre_1_1Technique.html#874f049c7a6b21f3b91e12ca5860330e">Ogre::Technique::mGPUVendorRules</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00136">136</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="75739b100b635fbfd9760265239c34f3"></a><!-- doxytag: member="Ogre::Technique::mGPUDeviceNameRules" ref="75739b100b635fbfd9760265239c34f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOgre_1_1Technique.html#19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a> <a class="el" href="classOgre_1_1Technique.html#75739b100b635fbfd9760265239c34f3">Ogre::Technique::mGPUDeviceNameRules</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Definition at line <a class="el" href="OgreTechnique_8h-source.html#l00137">137</a> of file <a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="OgreTechnique_8h-source.html">OgreTechnique.h</a></ul>
<hr>
<p>
Copyright &copy; 2008 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Thu Jan 22 21:27:45 2009
</p>
</body>
</html>
